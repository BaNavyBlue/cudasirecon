<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <TITLE>WMMenu Programming Library</TITLE>
  <LINK REV=MADE HREF="mailto:ive@msg.ucsf.edu">
</HEAD>
<BODY>
<H1>WMMenu Programming Library</H1>
<H2>Contents</H2>
<UL>
  <LI><A HREF="#Introduction">Introduction</A><UL>
    <LI><A HREF="#I. Menu creation">Creating Menus</A>
    <LI><A HREF="#II. Widget creation">Putting Widgets in the Menu</A><UL>
       <LI><A HREF="#A. Adding Widgets">Adding Widgets</A>
       <LI><A HREF="#B. Widget Modifications">Modifying Widgets</A>
       <LI><A HREF="#C. Widget Positioning">Positioning Widgets</A>
    </UL>
    <LI><A HREF="#III. Menu Display">Displaying the Menu</A>
    <LI><A HREF="#IV. Processing Events">Processing Events</A>
    <LI><A HREF="#V. Error and Info popups">Error and Info popups</A>
    <LI><A HREF="#VI. File Selection">File Selection</A>
    <LI><A HREF="#VII. Monitor event handling">Monitor Event Handling</A>
  </UL>
  <LI><A HREF="#Remote Process Event Handling">Remote Process Event Handling</A>
  <LI><A HREF="#CompilingLinking">Compiling and Linking</A>
  <LI><A HREF="#ReleaseNotes">Release Notes</A>
  <LI><A HREF="#Function Calls By Category">Function call reference list</A>
</UL>
<HR>

<H2><A NAME="Introduction">Introduction</A></H2>
<P>The Widget Menu Library is a set of GUI convenience routines written
for the IVE package. WML is Motif based and uses events and callbacks to
control the flow of user input into your program. The library provides
the tools to create menus with a variety of different user input items
(widgets ), and establishes an event link between the user and IWL monitors.
One more feature of the library is an Information widget which allows for
context sensitive help.

<P>The steps to needed to create a menu are:
<OL>
  <LI>Initialize the menu with <A HREF="#WMInit">WMInit</A>.
  <LI>Add widgets.
  <LI>Display the menu with <A HREF="#WMDisplay">WMDisplay</A>.
  <LI>Use <A HREF="#WMAppMainLoop">WMAppMainLoop</A> or
    <A HREF="#WMProcEvent">WMProcEvent</A> to get events
</OL>

<P>Example Program: Hello World
<PRE>
#include "WMInclude.h"
#include &lt;stdlib.h&gt;    /* exit */

int end_program()
{
    exit(0);
    return 0;
}


int main(int argc, char* argv[])
{
    int maxlen = 12;
    int group = 1;

    <A HREF="#WMInit">WMInit</A>("Hello World Demo");
    <A HREF="#WMAddText">WMAddText</A>("Hello World", maxlen, group);
    <A HREF="#WMAddFuncButton">WMAddFuncButton</A>("quit", end_program, NULL, 0, 0);
    <A HREF="#WMDisplay">WMDisplay</A>();
    <A HREF="#WMAppMainLoop">WMAppMainLoop</A>();
    return 1;
}
</PRE>

<P>This program creates a menu, containing a text widget that says "Hello
World". Next to the Text Widget is a quit button. The menu will remain
on the screen until the quit button is pushed, then the end_program routine
will be called and the program ends.

<H3><A NAME="I. Menu creation">I. Menu creation</A></H3>
<P>A call to <A HREF="#WMInit">WMInit</A> creates the first menu. Other
submenus may be created in the same program by calling
<A HREF="#WMInitSubMenu">WMInitSubMenu</A>.  Optional calls which affect the
behavior of WMInit and WMInitSubMenu are:

<DL>
  <DT><A HREF="#WMSetLoc">WMSetLoc</A><DD>Sets the position of the menu on the
    screen.
  <DT><A HREF="#WMNoTitleBar">WMNoTitleBar</A><DD>Causes the all subsequent
    menus without titles to be created without title bars.
  <DT><A HREF="#WMOverrideRedirect">WMOverrideRedirect</A><DD>Causes the next
    menu created to pop up (as a warning or error dialog would) even if the
    user has instructed the window manager to cause interactive placement
    of normal menus.
  <DT><A HREF="#WMSetOverlayUse">WMSetOverlayUse</A><DD>Sets whether or not
    dialogs or pulldowns should be put in the overlay planes.
</DL>

<H3><A NAME="II. Widget creation">II. Widget creation</A></H3>
<H4><A NAME="A. Adding Widgets">A. Adding Widgets</A></H4>
<P>All of the functions, with the prefix WMAdd, add a new widget to the
current menu and return a widget index. The widget index can be referenced
later for updates to that widget. The types of widgets that are provided
in the widget set include input fields, output fields, selection, function
buttons and drawing areas. An example will be provided below for the use
of each type. Each Widget function has a set of parameters unique to that
widget but there are several parameters that most of the widgets share
in common. These general parameters are described here.

<P>First of all, many widgets are associated with some variable or variables.
In the input field example below, the first parameter requires the address
of the variable it will represent. The second variable tells how many variables
the first parameter refers to, ie. whether it is a single variable or an
array. In this case the Widget will display a single floating point variable
which is initially 5.9. The user will be able to enter a different number
into this widget and the variable will be changed.

<P>The next parameter common to most widgets is the callback. This will
be the name of the function that should be called whenever a user enters
something into this widget. If you do not wish to call any function when
this widget is changed simply enter NULL for this parameter. The parameter
immediately following the callback, is the parameters to pass to the callback.
Obviously if the callback is NULL, the params should be NULL as well. But
if you do have a callback function and want to pass parameters to it, remember
this. You can pass just one integer pointer to the callback. If you only
want to pass one integer, that's ok, but cast it as an integer pointer.
Otherwise you can pass the address of any variable type, pass an array
of variables, or organize multiple variables into a structure and pass
its address. Functions used as callbacks must always be of type integer.

<P>The third pair of variables used by most widgets has to do with grouping.
In the input field example, update and group are the variables involved.
The Widgets can be put into groups such that you can disable or update
all the widgets in one group with a single call. Widgets are attached to
a group by entering an integer number in the group parameter. Grouping
is done using binary masking meaning....
<P>group computer sees 1 00001 2 00010 4 00100 ..........etc.
<P>To keep the groups independent of each other, it is best to number them
in powers of 2: 1,2,4,8... For example, if you give a command to update
group 3(00011). Groups 1 and 2 will both be updated since the one's and
the two's positions each are true in binary. This can be used to your advantage
to group and subgroup. You can also avoid the grouping thing entirely by
putting a zero in the group field.

<P>The update field can be set to zero or one. If it is set to one, then
any time the widget is changed by the user, after its callback has been
executed, if any variables of other widgets in the same group have been
changed, those widgets will be updated to reflect the new value.

<P>Example I
<PRE>
#include "WMInclude.h"
#include &lt;stdio.h&gt;   /* sprintf */
#include &lt;stdlib.h&gt;  /* exit */

static char result_string[20] = "0.0000";

int end_program()
{
    exit(0);
    return 0;
}


int update_square(float *fvar)
{
    float value = *fvar;
    float result = value * value;

    sprintf(result_string, "%f", result);
}


int main(int argc, char* argv[])
{
    float fvar = 0.0;
    int maxlen = 10;
    int dislen = 12;
    int decimal = 2;
    float min = 0;
    float max = 0;

    <A HREF="#WMInit">WMInit</A>("Squares Program");
    <A HREF="#WMAddInfoButton">WMAddInfoButton</A>("Input:", NULL);
    <A HREF="#WMAddFloatField">WMAddFloatField</A>(
        &amp;fvar, 1, dislen, maxlen, &amp;min, &amp;max, &amp;decimal, update_square, (int*) &amp;fvar, 1, 2
    );
    <A HREF="#WMNewRow">WMNewRow</A>();
    <A HREF="#WMAddInfoButton">WMAddInfoButton</A>("Result", NULL);
    <A HREF="#WMAddText">WMAddText</A>(result_string, dislen, 2);
    <A HREF="#WMNewRow">WMNewRow</A>();
    <A HREF="#WMAddFuncButton">WMAddFuncButton</A>("quit", end_program, NULL, 0, 0);
    <A HREF="#WMAttachRightSide">WMAttachRightSide</A>();
    <A HREF="#WMDisplay">WMDisplay</A>();
    <A HREF="#WMAppMainLoop">WMAppMainLoop</A>();
    return 1;
}
</PRE>
<P>Example I demonstrates the use of input field, output field, and function
button widgets along with the use of callbacks and group updating. The
input field <A HREF="#WMAddFloatField">WMAddFloatField</A> calls update_square
when a user enters a value into it.  Because the update field is set to 1, and
the group number is 2, any other widget in group 2 will be automatically
updated after the callback routine has been executed, the callback
"update_square" calculates the square of the last value entered into the
input field, and writes the result to the result_string which is reported by
the control added by <A HREF="#WMAddText">WMAddText</A>.  The user can keep
entering input and getting results until the user presses the function button
to quit. Then the function end_program is called and the program ends.

<P>There are several different classes of widgets.  Input fields allow
users to type in information; the calls to create these fields are:
<DL>
  <DT><A HREF="#WMAddCharField">WMAddCharField</A><DD>Holds a character string.
  <DT><A HREF="#WMAddFloatField">WMAddFloatField</A><DD>Holds one or more
    floating point variables.
  <DT><A HREF="#WMAddIntField">WMAddIntField</A><DD>Holds one or more integer
    variables
</DL>

<P>Output fields report the current state to the user but do not accept input
and do not have an associated callback routine.  The calls to create output
fields are:
<DL>
  <DT><A HREF="#WMAddOnOffStatus">WMAddOnOffStatus</A><DD>Is an indicator light
    to show status
  <DT><A HREF="#WMAddText">WMAddText</A><DD>Shows one line of text.
  <DT><A HREF="#WMAddScrolledText">WMAddScrolledText</A><DD>Is a scrollable
    widget to show multiple lines of text.
  <DT><A HREF="#WMAddStatusBar">WMAddStatusBar</A><DD>Is a thermometer-style
    bar for showing how far along a process is.
</DL>

<P>Function buttons cause something to happen (generally whatever the
registered callback function does).  The calls to create function
buttons are:
<DL>
  <DT><A HREF="#WMAddArrowButton">WMAddArrowButton</A><DD>Creates a button
    labeled with an arrow symbol pointing in one of four directions.
  <DT><A HREF="#WMAddDoButton">WMAddDoButton</A><DD>Creates a button which
    starts an external program when pressed.
  <DT><A HREF="#WMAddFuncButton">WMAddFuncButton</A><DD>Creates a button
    with a label; when pressed the button will cause the registered callback
    to be invoked.
  <DT><A HREF="#WMAddFuncList">WMAddFuncList</A><DD>Shows a list of options
    to the user and calls the function associated with the option chosen.
  <DT><A HREF="#WMAddInfoButton">WMAddInfoButton</A><DD>Frequently used as
    a label; when pressed will display online help.
  <DT><A HREF="#WMAddSaveButton">WMAddSaveButton</A><DD>Creates two buttons.
    Pressing one saves the values of all the parameters associated with
    the widgets in the menu; the other restores the values that were previously
    saved.
</DL>

<P>Selection widgets are a grab bag of widgets.  Some are similar in function
to input fields, but generally do not require the input to be typed.  Others
are similar in function to lists of function buttons.  The calls to create
selection widgets are

<DL>
  <DT><A HREF="#WMAddGetFile">WMAddGetFile</A><DD>Creates a function button
    which will open a file selection dialog and an adjacent character field
    in which the last file selection is shown and which may be used to
    change the file selection directly.
  <DT><A HREF="#WMAddHorSlider">WMAddHorSlider</A><DD>Creates a horizontal
    slider bar.
  <DT><A HREF="#WMAddOptionMenu">WMAddOptionMenu</A><DD>Creates a pulldown
    set of options; the last selection is displayed on top.
  <DT><A HREF="#WMAddPulldown">WMAddPulldown</A><DD>Creates a single pulldown
    menu.
  <DT><A HREF="#WMAddPulldownMenu">WMAddPulldownMenu</A><DD>Creates a cascade
    of menus.
  <DT><A HREF="#WMAddScrolledChoices">WMAddScrolledChoices</A><DD>Creates a
    scrolled list of options which lets the user select an option by clicking
    on it.
  <DT><A HREF="#WMAddToggleButton">WMAddToggleButton</A><DD>Creates a toggle
    button which may be turned on or off by the user.
</DL>

<P>Drawing areas are blank canvases which can be used for customized drawing.
The calls to create drawing ares are:
<DL>
  <DT><A HREF="#WMAddDrawingArea">WMAddDrawingArea</A><DD>Creates an area in
    your menu for drawing using X, Xt, and Motif library calls.
  <DT><A HREF="#WMAddGLwMDrawWidget">WMAddGLwMDrawWidget</A><DD>Creates an
    area in your menu for drawing using OpenGL library calls.
</DL>

<H4><A NAME="B. Widget Modifications">B. Widget Modifications</A></H4>
<P>Once widgets have been created, the programmer may need to control the
conditions under which a user can input into the widgets.
<A HREF="#WMEnableField">WMEnableField</A> and
<A HREF="#WMDisableField">WMDisableField</A> do just that, enable and disable
the widget for user input. The widget will dim slightly when its disabled
<A HREF="#WMEnableGroup">WMEnableGroup</A> and
<A HREF="#WMDisableGroup">WMDisableGroup</A> do the same thing only now one
call effects all the widgets that belong to that group.
<A HREF="#WMUnpasteWidget">WMUnpasteWidget</A> and
<A HREF="#WMPasteWidget">WMPasteWidget</A> completely remove and restore
(respectively) a widget from the menu.

<P>The information that a widget shows a user may change and need updating.
<A HREF="#WMUpdateField">WMUpdateField</A> and
<A HREF="#WMUpdateGroup">WMUpdateGroup</A> when called will recheck the
variables that are being looked at through a widget (or widgets) and update the
widget(s) if the value is different from the currently displayed value.
<A HREF="#WMChangeText">WMChangeText</A> can be used to change the text on any
widget that uses a string to write a label on the widget. These are toggle
button, onoff status, function button, infobutton, dobutton.
<A HREF="#WMChangeTitle">WMChangeTitle</A> lets you change the title for the
slider and the statusbar

<P>If after you have already created your menu, you later want to insert
a widget or delete a widget from the menu, you can do that with
<A HREF="#WMInsertWidget">WMInsertWidget</A>,
<A HREF="#WMEndInsert">WMEndInsert</A> and
<A HREF="#WMDeleteWidget">WMDeleteWidget</A>.

<P>There are several modifications functions that are for a particular
widget. These functions will be described in the Widget Section after the
Widget it affects.

<H4><A NAME="C. Widget Positioning">C. Widget Positioning</A></H4>
<P>The first widget added to the menu will be in the top left hand corner.
Widgets added after that are added to the right side of the previous widget.
To start a new row of widgets, there is a call <A HREF="#WMNewRow">WMNewRow</A>
which puts the next widget after that against the left side of the menu and
below the other widgets.  So the general order of widget creation is left to
right and top to bottom.  There are two other calls that are used in
positioning of widgets.  <A HREF="#WMSetOffset">WMSetOffset</A> lets you
specify the spacing between widgets.
<A HREF="#WMAttachRightSide">WMAttachRightSide</A> extends the last widget
created to the right side of the menu.  Finally
<A HREF="#WMAddSeparator">WMAddSeparator</A> draws a horizontal line between
two rows of widgets. Use it in place of <A HREF="#WMNewRow">WMNewRow</A> if you
want a line separating sections of the menu.

<H3><A NAME="III. Menu Display">III. Menu Display</A></H3>
<P>In order to see the menu that's been created you have to make a display
call.  <A HREF="#WMDisplay">WMDisplay</A> will display the menu created by
calling <A HREF="#WMInit">WMInit</A>.
<A HREF="#WMDisplaySubMenu">WMDisplaySubMenu</A> will display submenus created
by <A HREF="#WMInitSubMenu">WMInitSubMenu</A>.
<A HREF="#WMUndisplaySubMenu">WMUndisplaySubMenu</A> will hide a menu again
until the next time <A HREF="#WMDisplaySubMenu">WMDisplaySubMenu</A> is called.
With multiple menus, the menus are numbered sequentially by order of creation,
and this number is returned by <A HREF="#WMInitSubMenu">WMInitSubMenu</A>.
You can hide the main menu by calling
<A HREF="#WMUndisplaySubMenu">WMUndisplaySubMenu</A> with an argument of
zero.

<H3><A NAME="IV. Processing Events">IV. Processing Events</A></H3>
<P>The menu system is based on the ability to process events from the user,
since callbacks will only be called as a response to an event. There are
two ways to handle events.  <A HREF="#WMAppMainLoop">WMAppMainLoop</A> starts
an event processing loop.  Once started, the event loop will keep handling
events until a function is called to exit the program.
<A HREF="#WMProcEvent">WMProcEvent</A> provides a way to check for a single
event. This is particularly useful when a program is doing some
other type of looping and you need to check for user interrupt.  Then once
in every loop cycle, you can make this call to check for an event.

<P>For controls created by <A HREF="#WMAddArrowButton">WMAddArrowButton</A> or
<A HREF="#WMAddFuncButton">WMAddFuncButton</A>, you can get more information
about the event that activated the button using
<A HREF="#WMRetLastButEvent">WMRetLastButEvent</A> or
<A HREF="#WMGetLastButNum">WMGetLastButNum</A>.

<H3><A NAME="V. Error and Info popups">V. Error and Info popups</A></H3>
<P>There are several window pop ups available to display special
information to the user about what is currently happening in the program.
<A HREF="#WMConfirm">WMConfirm</A> is used to check with the user if what the
program is about to do is ok. The user can respond ok or cancel, and the
function will return the response back to the program so you can respond
accordingly.  <A HREF="#WMConfirmError">WMConfirmError</A> pops up a message
to the user letting them know that there is some error in what they are
trying to do so they can do it correctly.  <A HREF="#WMPostInfo">WMPostInfo</A>
lets the program give some information to the user such as some task is done.

<P>To have an application cause the help viewer to display a specific topic,
use <A HREF="#WMDisplayHelp">WMDisplayHelp</A>.

<H3><A NAME="VI. File Selection">VI. File Selection</A></H3>
<P>There is a file selection menu that can be popped up directly by calling
<A HREF="#WMGetFile">WMGetFile</A> or pops up when a user hits the GetFile
button created by a call to <A HREF="#WMAddGetFile">WMAddGetFile</A>.  This 
menu by default, will show the user the list of files in the users home
directory, using the file filter *.dat. The user can change the file filter
and directory in the menu and select the file they are looking for. In order
to start with a directory and file filter other than the defaults, there is
another call you can set in your program.
<A HREF="#WMSetGetFileSrc">WMSetGetFileSrc</A> can be used to set a key to
find the last directory and file filter the user used for file selection with
your program. In each users home directory is a file called .ivestartup.  (If
there is not, there will be one after the first time they run Priism).  This is
an ASCII file containing a list of directory and filter keys associated with
the last directory and filter used by the user when these keys were set.
Every time a new set of keys is used, they will be added to the list.
Every time the user runs the program they will start in the directory
currently associated with the key in the file, and if they end with a
different directory, .ivestartup will be updated with the new settings.
You can create a different key name for every program or every type of file.

<H3><A NAME="VII. Monitor event handling">VII. Monitor event handling</A></H3>
<P>WMMenu provides a way for your program to keep track of user interaction
with the IVE monitor. This allows your program to handle tasks such as data
picking and region selection in the image as well as updating information
based on the changing state of the monitor.

<P>You must use <A HREF="#WMEnableIWLEvent">WMEnableIWLEvent</A> before any of
the following events can be sent from the monitor to your program.  In case
that you wish to stop receiving events from the monitor, use
<A HREF="#WMDisableIWLEvent">WMDisableIWLEvent</A>.

<P>For events such as change in zoom, section, image shift, resize, expose
etc. use <A HREF="#WMProcDisplayChange">WMProcDisplayChange</A> to associate a
callback routine with the event.  Use
<A HREF="#WMCancelDisplayChange">WMCancelDisplayChange</A> when you no longer
need this type of event. **we need to look into some constants for the
different kinds of display changes

<P>For events such as mouse actions in the window, and keypress events
use <A HREF="#WMAddEventHandler">WMAddEventHandler</A> and use
<A HREF="#WMCancelEventHandler">WMCancelEventHandler</A> when you no longer
need this kind of event.

<H3><A NAME="Remote Process Event Handling">VIII. Remote Process Event Handling</A></H3>
<P>This set of calls lets you run and communicate with a remote program from
an interactive session. This provides a way to make use of faster machines for
data processing while viewing results on a machine that can display the images
with IVE.  The remote program can use regular imsubs calls to read and write to
your image windows.  See the
<A HREF="IM_ref2.html#IMOpen">documentation for IMOpen</A> in
<A HREF="IM_ref2.html">IM_ref2.html</A> for a description of using imsubs from
a remote program.

<P>In order for communication to work, both the session side program and
remote program must call WMInit to initialize the event handling.  The session
side program starts up the remote program using the call
<A HREF="#WMStartRemoteProgram">WMStartRemoteProgram</A>. After all callbacks
are set up on both sides, <A HREF="#WMProcEvent">WMProcEvent</A>
or <A HREF="#WMAppMainLoop">WMAppMainLoop</A> can be used to get the input
events.

<P>Callbacks are setup using the function
<A HREF="#WMAddInputEventHandler">WMAddInputEventHandler</A>.  Both the
session program (prog1) and the remote program (prog2) can set up callback
functions to receive information from the other side.  Each
WMAddInputEventHandler call registers a different function to be called upon
receipt of an input event and associates the function with a reference id.
A program can set up as many callback functions as it needs.  Prog1 needs to
know the prog2 reference ids and vice versa so that they can use
these ids to specify which function the data is intended for. 

<P><A HREF="#WMRemoteSendData">WMRemoteSendData</A> is used to send the
data to the other side using the reference id.  Any number, except zero,
may be used as a reference id, by
<A HREF="#WMAddInputEventHandler">WMAddInputEventHandler</A>.  Zero may be used
as the reference id by <A HREF="#WMRemoteSendData">WMRemoteSendData</A> when
data is being sent synchronously.  In this case, the receiving program should
be waiting for the data with a <A HREF="#WMRemoteGetInt2">WMRemoteGetInt2</A>,
<A HREF="#WMRemoteGetInt4">WMRemoteGetInt4</A> or
<A HREF="#WMRemoteGetBytes">WMRemoteGetBytes</A> call, instead of waiting for
the next input event.

<P>Functions called by the event handler, will receive as a parameter the
number of bytes that are being sent to this function. The function should
know what kind of data it is receiving, ie integers, reals, character data.
The function will then get the data using the calls
<A HREF="#WMRemoteGetInt2">WMRemoteGetInt2</A>,
<A HREF="#WMRemoteGetInt4">WMRemoteGetInt4</A>
and <A HREF="#WMRemoteGetBytes">WMRemoteGetBytes</A> as appropriate.

<HR>
<H2><A NAME="CompilingLinking">Compiling and Linking</A></H2>
<P>Programs written in C/C++ which use the WM functions should include
WMInclude.h to provide prototypes and define structures and macros used
with the WM functions. For programs written in Fortran, WM.inc defines the
WM_* and key symbol constants.

<P>When linking your application, link against libWM.a or libWM.so
(libWM.dylib on Mac OS X).

<H3>Platform Specifics</H3>

<H4><A NAME="CompilingLinking_x86Linux">x86 Linux</A></H4>
<P>To use the x86 Linux library, you will need an x86 Linux system that
supports compiling ELF executables, has glibc2.1, and has the X, OpenGL (or
Mesa) libraries and headers installed.

<P>The headers are located in the Linux/x86/INCLUDE directory of the Priism
distribution.  For C/C++ programs, including WMInclude.h has the side effect
of including X and OpenGL headers; if the path to those headers is not in the
default search path then it will be necessary to include it in the search path
(in most cases, adding

<PRE>
    -I/usr/X11R6/include
</PRE>

<P>to the compilation options will do this).

<P>The library is located in the Linux/x86/LIB directory of the Priism
distribution.  If you link against libWM.so, it is necessary to instruct
the linker to search Linux/x86/LIB and lesstif/Linux/x86/lib for libraries
that libWM.so uses.  If you invoke the linker directly, this can be done by
adding

<PRE>
    -rpath-link <VAR>install_dir</VAR>/Linux/x86/LIB -rpath-link <VAR>install_dir</VAR>/lesstif/Linux/x86/lib
</PRE>

<P>to the linker options (replace <VAR>install_dir</VAR> with the path to
the Priism distribution).  If the compiler is used to invoke the linker, then
you will need to determine how to instruct the compiler to pass the above
option to the linker; for most compilers it can be done with

<PRE>
    -Wl,-rpath-link,<VAR>install_dir</VAR>/Linux/x86/LIB -Wl,-rpath-link,<VAR>install_dir</VAR>/lesstif/Linux/x86/lib
</PRE>

<P>libWM.so also depends on the X and OpenGL libraries; if the paths to those
libraries are not in the directory search path, it will be necessary to supply
additional -rpath-link options.

<P>If you use the archive library, libWM.a, it is necessary to link against
the libraries that those libraries use.  For libWM.a, these additional
libraries can be specified on the command line as

<PRE>
    -lIWL -live -lGLw -lXm -lXt -lX11 -lGL
</PRE>

<P>(the IWL, ive, and GLw libraries are in the same directory as the WM
library; the Xm library can be found in lesstif/Linux/x86/lib within the
Priism directories; the others are assumed to be in the default search path;
if they are not it will be necessary to add them).

<H4><A NAME="CompilingLinking_x86_64Linux">x86_64 Linux</A></H4>
<P>To use the x86_64 Linux library, you will need an x86_64 Linux system that
has glibc2.3, and has the X, OpenGL (or Mesa) libraries and headers installed.

<P>The headers are located in the Linux/x86_64/INCLUDE directory of the Priism
distribution.  For C/C++ programs, including WMInclude.h has the side effect
of including X and OpenGL headers; if the path to those headers is not in the
default search path then it will be necessary to include it in the search path
(in most cases, adding

<PRE>
    -I/usr/X11R6/include
</PRE>

<P>to the compilation options will do this).

<P>The library is located in the Linux/x86_64/LIB directory of the Priism
distribution.  If you link against libWM.so, it is necessary to instruct
the linker to search Linux/x86_64/LIB and lesstif/Linux/x86_64/lib for
libraries that libWM.so uses.  If you invoke the linker directly, this can be
done by adding

<PRE>
    -rpath-link <VAR>install_dir</VAR>/Linux/x86_64/LIB -rpath-link <VAR>install_dir</VAR>/lesstif/Linux/x86_64/lib
</PRE>

<P>to the linker options (replace <VAR>install_dir</VAR> with the path to
the Priism distribution).  If the compiler is used to invoke the linker, then
you will need to determine how to instruct the compiler to pass the above
option to the linker; for most compilers it can be done with

<PRE>
    -Wl,-rpath-link,<VAR>install_dir</VAR>/Linux/x86_64/LIB -Wl,-rpath-link,<VAR>install_dir</VAR>/lesstif/Linux/x86_64/lib
</PRE>

<P>libWM.so also depends on the X and OpenGL libraries; if the paths to those
libraries are not in the directory search path, it will be necessary to supply
additional -rpath-link options.

<P>If you use the archive library, libWM.a, it is necessary to link against
the libraries that those libraries use.  For libWM.a, these additional
libraries can be specified on the command line as

<PRE>
    -lIWL -live -lGLw -lXm -lXt -lX11 -lGL
</PRE>

<P>(the IWL, ive, and GLw libraries are in the same directory as the WM
library; the Xm library can be found in lesstif/Linux/x86_64/lib within the
Priism directories; the others are assumed to be in the default search path;
if they are not it will be necessary to add them).

<H4><A NAME="CompilingLinking_MacOSX">Mac OS X</A></H4>
<P>To use the WM library on Mac OS X, it is necessary to have the X and
OpenGL (or Mesa) libraries and header files installed.  Apple's X11, included
on the installation disks since 10.3, has the X and OpenGL libraries.  The
header files are part of a separate component, the X11 for Mac OS X SDK.

<P>The WM header files for 32-bit applications are located in the
Darwin/INCLUDE directory of the Priism distribution.  The header files for
64-bit applications are located in the Darwin64/INCLUDE directory.  For
C/C++ programs, including WMInclude.h has the side effect of including X and
OpenGL headers; if the path to those headers is not in the default search path
than it will be necessary to include it in the search path (in most cases,
adding

<PRE>
    -I/usr/X11R6/include
</PRE>

<P>to the compilation options will do this).

<P>The 32-bit WM libraries are located in the Darwin/LIB directory of the
Priism distribution.  The 64-bit WM libraries are located in the Darwin64/LIB
directory.  Because of the way libWM.dylib was built, it is necessary to
mention some of the libraries libWM.dylib depends upon when linking
with libWM.dylib.  One way to do so is to include the following after in the
command-line options when linking:

<PRE>
    -lIWL -live -lGLw -L<VAR>install_dir</VAR>/lesstif/Darwin/lib -lXm
</PRE>

<P>where you would replace <VAR>install_dir</VAR> with the path to where
Priism is installed.  The above method has the slight disadvantage that your
application will have an explicit dependence on those additional libraries;
an alternative method which avoids the explicit dependencies at the expense
of more involved command-line options is used in the
<A HREF="../EXAMPLE/makefile">sample Makefile for Priism applications</A>.

<P>If you use libWM.a, it is necessary to link with all the libraries
necessary for libWM.dylib and also libXt, libX11, and libGL, i.e. add
<PRE>
    -lIWL -live -lGLw -L<VAR>install_dir</VAR>/lesstif/Darwin/lib -lXm -L<VAR>xpath</VAR> -lXt -lX11 -lGL
</PRE>

<P>to the link options.  In the above expression, replace <VAR>xpath</VAR> with
the path the X11 libraries and OpenGL library for X11; with Apple's X11 or
XDarwin, <VAR>xpath</VAR> is /usr/X11R6/lib.

<HR>
<H2><A NAME="ReleaseNotes">Release Notes</A></H2>
<P>The following changes break backward compatibility between IVE 4 and
IVE 3.3:
<UL>
  <LI>The handling of Widget return values and arguments in the Fortran
    interface changed in Priism 4.2.0.  The change will be transparent
    except for the case where you pass Widget values between C/C++ and Fortran
    on 64-bit systems.  The solution, which can be used either on 32-bit
    or 64-bit systems is to use
    <A HREF="IVE/IVEFtnIdToPtr.html">IVEFtnIdToPtr</A> to convert a Fortran
    integer to a Widget value and
    <A HREF="IVE/IVEPtrToFtnId.html">IVEPtrToFtnId</A> to convert a Widget
     value to a Fortran integer.
  <LI>In 4.1.9, changed the value of the WM_RIGHT_ARROW and WM_LEFT_ARROW
    constants for Fortran.
  <LI>The handling of shell widgets changed in Priism 4.1.4.  The primary
    effects are:
    <UL>
      <LI>All shells created with <A HREF="#WMInit">WMInit</A>,
        <A HREF="#WMInitSubMenu">WMInitSubMenu</A>, or WMGetShellWidget
        are now created with XtCreatePopupShell rather than XtAppCreateShell.
        Code that pops up one of these shells with XtRealizeWidget should
        be modified to use <A HREF="#WMDisplay">WMDisplay</A>,
        <A HREF="#WMDisplaySubMenu">WMDisplaySubMenu</A>, or XtPopup
        instead.  Code that pops down one of these shells with
        XtUnrealizeWidget should be modified to use
        <A HREF="#WMUndisplaySubMenu">WMUndisplaySubMenu</A> or XtPopdown
        instead.
      <LI>An undocumented feature allowed multiple functions to be
        registered with <A HREF="#WMSetExitFunction">WMSetExitFunction</A>;
        now only the last function registered with
        <A HREF="#WMSetExitFunction">WMSetExitFunction</A> has an effect.
        Another undocumented feature passed the shell widget, the Display
        pointer (as an XtPointer), and another XtPointer as arguments to
        the callback.  Now nothing is passed.  Both changes make
        <A HREF="#WMSetExitFunction">WMSetExitFunction</A> behave like
        <A HREF="#WMSetSubExitFunc">WMSetSubExitFunc</A>.
      <LI>Adding your own handler for the WM_DELETE_WINDOW protocol with
        XmAddWMProtocolCallback (or equivalent) on the shell
        returned by <A HREF="#WMInit">WMInit</A> is not guaranteed to
        work:  the order of callbacks is not specified by Xt and the callback
        added by the WM library forces the program to exit.  Use
        <A HREF="#WMSetExitFunction">WMSetExitFunction</A> instead.
      <LI>File dialogs popped up by <A HREF="#WMAddGetFile">WMAddGetFile</A>
        controls are now created as children of the push button.  That, in
        turn, required a modification to the
        <A HREF="FAQ/index.html">Priism FAQ's</A> procedure for adjusting
        fonts.
    </UL>
  <LI>Certain functions and data items, which were visible in the library
    but not mentioned in the documentation or header files, were removed
    in 4.1.2.  The functions removed were add_item, clear_rec_data,
    create_and_run_remote_command_script, get_char_attr, get_float,
    get_float_attr, get_int, get_ive_def, get_long_attr, get_parm, get_rec,
    get_text, hide, init_GL_widget, put_char_attr, put_float_attr,
    put_long_attr, save_ive_def, set_wm_switch_format (renamed to
    wm_set_switch_format), skip_line, and wr_res.  The data items removed were
    form, form1, Head, hold_form, hold_left, hold_top, hold_xstart, left, top,
    and xstart.
  <LI>When a file was successfully selected with
    <A HREF="#WMGetFile">WMGetFile</A> (the function returned 1), IVE 3.3 and
    previous versions had the undocumented side effect that the contents of
    the string passed as the second argument to
    <A HREF="#WMGetFile">WMGetFile</A> were copied (via strcpy) to the fourth
    argument.  That is no longer the case; the second, third, and fourth
    arguments of <A HREF="#WMGetFile">WMGetFile</A> are not examined or used in
    any way.  This change was introduced in 4.0.7.
  <LI>The following functions, declared in WMFunc.h in previous versions but
    apparently only used internally within the library, are no longer
    available:  strip_spaces, WM_choices_callback, WMadditem, WMarrowcallback,
    WMattachtoform, WMbutcallback, WMcancel, WMcancelreadfile,
    WMdecodeforstring, WMdragcallback, WMexecbut, WMflcallback, WMfixforstring,
    WMgetfile, WMgetfloats, WMgethelp, WMgetints, WMgetstring, WMgettimeout,
    WMhelpcallback, WMinsensitive, WMpcallback, WMreadfile, WMrestore,
    WMretfilename, WMsave, WMsavedefdirpat, WMscallback, WMsensitive,
    WMstopproc, WMtogglefunc, and WMupdatefield.
  <LI>The following functions, which were not mentioned in WM header but which
    were visible in the library, are no longer accessible:  CopyScale,
    determine_switch_format, GetDefDirPat, getfilename, and SaveDefDirPat.
    The following data items, which were not mentioned in a WM header but which
    were visible in the library are no longer accessible: app_file, buf,
    note_f, and res_dir.
  <LI>Including WMInclude.h no longer has the side effect of include Xm/Xm.h.
  <LI>The locations of the headers and libraries has changed.  In previous
    versions, the headers were in the INCLUDE subdirectory and the libraries
    were in the LIB (or LIB_IRIX) subdirectory for IRIX.
  <LI>libWM.a was called WM.a.  The old name is still available as symbolic
    link to the new one but may be removed in a future release.
</UL>

<P>Additions to the library in IVE 4 are:
<UL>
  <LI>Added the function <A HREF="#WMDisplayHelp">WMDisplayHelp</A>.  It
    may be a satisfactory replacement for applications which previously
    called WMhelpcallback.
  <LI>In 4.0.7, added the functions
    <A HREF="#WMGetMenuSize">WMGetMenuSize</A> and
    <A HREF="#WMGetScreenSize">WMGetScreenSize</A>.
  <LI>In 4.0.10, extended <A HREF="#WMRegMouseButton">WMRegMouseButton</A> and
    <A HREF="#WMUnRegMouseButton">WMUnRegMouseButton</A> to handle buttons 4
    and 5 (often mapped to the scroll wheel on mice which have one).
  <LI>In 4.1.3, added <A HREF="#WMChangeScrolledChoicesSelection">WMChangeScrolledChoicesSelection</A>.
  <LI>In 4.2.0, added <A HREF="#WMGetPulldownShowChoice">WMGetPulldownShowChoice</A>
    and Fortran interfaces for XtParent,
    <A HREF="#WMAddNestedPulldown">WMAddNestedPulldown</A>,
    <A HREF="#WMAddPullRight">WMAddPullRight</A>,
    <A HREF="#WMAddPulldownMenu">WMAddPulldownMenu</A>,
    <A HREF="#WMChangePulldown">WMChangePulldown</A>,
    <A HREF="#WMDeleteWidget">WMDeleteWidget</A>,
    <A HREF="#WMEndInsert">WMEndInsert</A>,
    <A HREF="#WMInsertWidget">WMInsertWidget</A>,
    <A HREF="#WMSetExitFunction">WMSetExitFunction</A>, and
    <A HREF="#WMSetSubExitFunc">WMSetSubExitFunc</A>.
</UL>

<P>Changes made to both IVE 4 and IVE 3.3:
<UL>
  <LI>In IVE 4.1.6 and the November 2003 release of IVE 3.3, modified
    <A HREF="#WMAddIntField">WMAddIntField</A> and
    <A HREF="#WMAddFloatField">WMAddFloatField</A> to dynamically determine
    the length needed rather than relying on their maximum length argument.
</UL>

<P>Changes made in IVE 3.3 were:
<UL>
  <LI>The October 1999 release included modifications to
    <A HREF="#WMConfirm">WMConfirm</A>,
    <A HREF="#WMConfirmError">WMConfirmError</A>,
    <A HREF="#WMPostInfo">WMPostInfo</A>, and
    <A HREF="#WMShowInfo">WMShowInfo</A> to support messages with multiple
    lines.
  <LI>The June 1999 release included modifications to
    <A HREF="#WMAddNestedPulldown">WMAddNestedPulldown</A> and
    <A HREF="#WMAddPullRight">WMAddPullRight</A> to support insertion of
    separators.
  <LI>The January 1999 release added the calls
    <A HREF="#WMSetOverlayUse">WMSetOverlayUse</A> and
    <A HREF="#WMOverlayDepth">WMOverlayDepth</A>.
  <LI>The October 1998 release added the <A HREF="#WMGetLoc">WMGetLoc</A>
    call; the return type and arguments for that call were modified for the
    October 1999 release.
</UL>

<HR>
<H2><A NAME="Function Calls By Category">Function Calls By Category</A></H2>
<H3>Menu Creation</H3>
<PRE>
<A HREF="#WMInit">WMInit</A>
<A HREF="#WMInitSubMenu">WMInitSubMenu</A>
<A HREF="#WMNoTitleBar">WMNoTitleBar</A>
<A HREF="#WMOverrideRedirect">WMOverrideRedirect</A>
<A HREF="#WMSetLoc">WMSetLoc</A>
<A HREF="#WMSetOverlayUse">WMSetOverlayUse</A>
</PRE>

<H3>Widgets</H3>
<PRE>
<A HREF="#WMAddArrowButton">WMAddArrowButton</A>                   <A HREF="#WMAddOptionMenu">WMAddOptionMenu</A>
<A HREF="#WMAddCharField">WMAddCharField</A>                     <A HREF="#WMAddNestedPulldown">WMAddNestedPulldown</A>
<A HREF="#WMAddDoButton">WMAddDoButton</A>                      <A HREF="#WMAddPullRight">WMAddPullRight</A>
<A HREF="#WMAddDrawingArea">WMAddDrawingArea</A>                   <A HREF="#WMAddPulldown">WMAddPulldown</A>
<A HREF="#WMAddFloatField">WMAddFloatField</A>                    <A HREF="#WMSetPulldownShowChoice">WMSetPulldownShowChoice</A>
<A HREF="#WMAddFuncButton">WMAddFuncButton</A>                    <A HREF="#WMGetPulldownShowChoice">WMGetPulldownShowChoice</A>
<A HREF="#WMAddFuncList">WMAddFuncList</A>                      <A HREF="#WMAddPulldownMenu">WMAddPulldownMenu</A>
<A HREF="#WMAddGetFile">WMAddGetFile</A>                       <A HREF="#WMAddSaveButton">WMAddSaveButton</A>
<A HREF="#WMAddGLwMDrawWidget">WMAddGLwMDrawWidget</A>                <A HREF="#WMAddScrolledChoices">WMAddScrolledChoices</A>
<A HREF="#WMAddHorSlider">WMAddHorSlider</A>                     <A HREF="#WMAddScrolledText">WMAddScrolledText</A>
<A HREF="#WMSliderShowValue">WMSliderShowValue</A>                  <A HREF="#WMAddSeparator">WMAddSeparator</A>
<A HREF="#WMAddInfoButton">WMAddInfoButton</A>                    <A HREF="#WMAddStatusBar">WMAddStatusBar</A>
<A HREF="#WMAddIntField">WMAddIntField</A>                      <A HREF="#WMAddText">WMAddText</A>
<A HREF="#WMAddOnOffStatus">WMAddOnOffStatus</A>                   <A HREF="#WMAddToggleButton">WMAddToggleButton</A>
</PRE>

<H3>Widget Modification</H3>
<PRE>
<A HREF="#WMDisableField">WMDisableField</A>                     <A HREF="#WMUpdateField">WMUpdateField</A>
<A HREF="#WMEnableField">WMEnableField</A>                      <A HREF="#WMChangePulldown">WMChangePulldown</A>
<A HREF="#WMDisableGroup">WMDisableGroup</A>                     <A HREF="#WMChangeScrolledChoicesSelection">WMChangeScrolledChoicesSelection</A>
<A HREF="#WMEnableGroup">WMEnableGroup</A>                      <A HREF="#WMChangeText">WMChangeText</A>
<A HREF="#WMUnpasteWidget">WMUnpasteWidget</A>                    <A HREF="#WMChangeTitle">WMChangeTitle</A>
<A HREF="#WMPasteWidget">WMPasteWidget</A>                      <A HREF="#WMInsertWidget">WMInsertWidget</A>
<A HREF="#WMSensitiveGroup">WMSensitiveGroup</A>                   <A HREF="#WMEndInsert">WMEndInsert</A>
<A HREF="#WMInsensitiveGroup">WMInsensitiveGroup</A>                 <A HREF="#WMDeleteWidget">WMDeleteWidget</A>
<A HREF="#WMUpdateGroup">WMUpdateGroup</A>
</PRE>

<H3>Widget Positioning</H3>
<PRE>
<A HREF="#WMAttachRightSide">WMAttachRightSide</A>
<A HREF="#WMNewRow">WMNewRow</A>
<A HREF="#WMSetOffset">WMSetOffset</A>
</PRE>

<H3>Menu Display</H3>
<PRE>
<A HREF="#WMDisplay">WMDisplay</A>
<A HREF="#WMDisplaySubMenu">WMDisplaySubMenu</A>
<A HREF="#WMUndisplaySubMenu">WMUndisplaySubMenu</A>
</PRE>

<H3>Processing Events</H3>
<PRE>
<A HREF="#WMAppMainLoop">WMAppMainLoop</A>                      <A HREF="#WMGetLastButNum">WMGetLastButNum</A>
<A HREF="#WMProcEvent">WMProcEvent</A>                        <A HREF="#WMRetLastButEvent">WMRetLastButEvent</A>
</PRE>

<H3>Error and Info Popups</H3>
<PRE>
<A HREF="#WMConfirm">WMConfirm</A>                          <A HREF="#WMShowInfo">WMShowInfo</A>
<A HREF="#WMConfirmError">WMConfirmError</A>                     <A HREF="#WMRemoveInfo">WMRemoveInfo</A>
<A HREF="#WMPostInfo">WMPostInfo</A>                         <A HREF="#WMDisplayHelp">WMDisplayHelp</A>
<A HREF="#WMRingBell">WMRingBell</A>
</PRE>

<H3>File Selection</H3>
<PRE>
<A HREF="#WMGetFile">WMGetFile</A>
<A HREF="#WMSetGetFileSrc">WMSetGetFileSrc</A>
</PRE>

<H3>Monitor Event Handling</H3>
<PRE>
<A HREF="#WMEnableIWLEvent">WMEnableIWLEvent</A>                   <A HREF="#WMCancelEventHandler">WMCancelEventHandler</A>
<A HREF="#WMDisableIWLEvent">WMDisableIWLEvent</A>                  <A HREF="#WMProcDisplayChange">WMProcDisplayChange</A>
<A HREF="#WMAddEventHandler">WMAddEventHandler</A>                  <A HREF="#WMCancelDisplayChange">WMCancelDisplayChange</A>
<A HREF="#WMRegMouseButton">WMRegMouseButton</A>                   <A HREF="#WMUnRegMouseButton">WMUnRegMouseButton</A>
</PRE>

<H3>Remote Process Event Handling</H3>
<PRE>
<A HREF="#WMStartRemoteProgram">WMStartRemoteProgram</A>               <A HREF="#WMRemoteSendData">WMRemoteSendData</A>
<A HREF="#WMAddInputEventHandler">WMAddInputEventHandler</A>             <A HREF="#WMRemoteGetBytes">WMRemoteGetBytes</A>
<A HREF="#WMCancelInputEventHandler">WMCancelInputEventHandler</A>          <A HREF="#WMRemoteGetInt2">WMRemoteGetInt2</A>
<A HREF="#WMRemoteGetInt4">WMRemoteGetInt4</A>
</PRE>

<H3>Window Manager Control</H3>
<PRE>
<A HREF="#WMSetExitFunction">WMSetExitFunction</A>
<A HREF="#WMSetSubExitFunc">WMSetSubExitFunc</A>
</PRE>

<H3>Display/Dialog/Widget Information</H3>
<PRE>
<A HREF="#WMGetLoc">WMGetLoc</A>                           <A HREF="#WMGetMenuSize">WMGetMenuSize</A>
<A HREF="#WMGetScreenSize">WMGetScreenSize</A>                    <A HREF="#WMOverlayDepth">WMOverlayDepth</A>
</PRE>

<HR>
<H2>Menu Creation Functions</H2>

<H3><A NAME="WMInit">WMInit</A></H3>
<H4>Overview</H4>
<P>Initializes the WM library if necessary and creates the container (a Motif
form widget) for the main dialog window.  This function must be called before
creating other user interface controls.  Calling WMInit more than once from a
program will lead to undefined behavior.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMInit(const char* title);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMInit(title)</CODE>
<BR><CODE>character*(*) title</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>title</VAR><DD>(in) Is the title to display on the main dialog
    window.  If <VAR>title</VAR> is a null pointer (or, in Fortran, if title
    is all spaces or the first character of title is a null character) and
    <A HREF="#WMNoTitleBar">WMNoTitleBar</A> has been called, the window manager
    will be instructed to only display resize handles on the main dialog.  If
    you use the Fortran interface and want to be compatible with IVE 3.3 or
    versions of IVE 4 earlier than 4.2.0, <VAR>title</VAR> must include a null
    character (i.e. char(0)) to mark the end of the title when <VAR>title</VAR>
    is not a null pointer.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the container created.

<HR>
<H3><A NAME="WMInitSubMenu">WMInitSubMenu</A></H3>
<H4>Overview</H4>
<P>Initializes the WM library if necessary and creates the container for
a child dialog window.  If an insertion initiated with
<A HREF="#WMInsertWidget">WMInsertWidget</A> is still active, the call to
WMInitSubMenu implicitly terminates the insertion as if you had explicitly
called <A HREF="#WMEndInsert">WMEndInsert</A> with an argument of one.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMInitSubMenu(const char* title);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMInitSubMenu(title)</CODE>
<BR><CODE>character*(*) title</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>title</VAR><DD>(in) Is the title to display on the child dialog
    window.  If <VAR>title</VAR> is a null pointer (or, in Fortran, if title
    is all spaces or the first character of title is a null character) and
    <A HREF="#WMNoTitleBar">WMNoTitleBar</A> has been called, the window manager
    will be instructed to only display resize handles on the dialog.  If
    you use the Fortran interface and want to be compatible with IVE 3.3 or
    versions of IVE 4 earlier than 4.2.0, <VAR>title</VAR> must include a null
    character (i.e. char(0)) to mark the end of the title when <VAR>title</VAR>
    is not a null pointer.
</DL>
<H4>Return Value</H4>
<P>Returns the zero-based index of the dialog created.  You can use this
index with <A HREF="#WMDisplaySubMenu">WMDisplaySubMenu</A> or
<A HREF="#WMUndisplaySubMenu">WMUndisplaySubMenu</A>.

<HR>
<H3><A NAME="WMNoTitleBar">WMNoTitleBar</A></H3>
<H4>Overview</H4>
<P>If you call WMNoTitleBar, all subsequent calls to
<A HREF="#WMInit">WMInit</A> and <A HREF="#WMInitSubMenu">WMInitSubMenu</A>
will instruct the window manager to only display resize handles on the dialog
when a null pointer (or, in Fortran, a character array containing all spaces
or which has a null character as the first element) is passed for the dialog
title.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMNoTitleBar(void);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMNoTitleBar()</CODE>
<H4>Return Value</H4>
<P>Returns zero.

<HR>
<H3><A NAME="WMOverrideRedirect">WMOverrideRedirect</A></H3>
<H4>Overview</H4>
<P>WMOverrideRedirect turns on or off window manager intervention when dialogs
are displayed with <A HREF="#WMDisplay">WMDisplay</A> or
<A HREF="#WMDisplaySubMenu">WMDisplaySubMenu</A>.  Normally when you display
a dialog, the window manager is responsible for positioning and decorating
the dialog.  You may not want that behavior for some types of dialogs (a dialog
which emulates a popup menu, for instance); you would then call
WMOverrideRedirect(1) before displaying the dialog and call
WMOverrideRedirect(0) to restore the default behavior after the dialog has
been displayed.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMOverrideRedirect(int flag);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMOverrideRedirect(flag)</CODE>
<BR><CODE>integer flag</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>flag</VAR><DD>(in) If <VAR>flag</VAR> is not zero, subsequent calls
    to <A HREF="#WMInit">WMInit</A> or
    <A HREF="#WMInitSubMenu">WMInitSubMenu</A> will create dialogs that are
    displayed without window manager intervention.  If <VAR>flag</VAR> is zero,
    subsequent calls to the <A HREF="#WMInit">WMInit</A> or
    <A HREF="#WMInitSubMenu">WMInitSubMenu</A> will create dialogs that
    will be decorated and positioned by the window manager.
</DL>
<H4>Return Value</H4>
<P>Returns zero.

<HR>
<H3><A NAME="WMSetLoc">WMSetLoc</A></H3>
<H4>Overview</H4>
<P>Sets the screen location for the dialog created by the latest call to
a <A HREF="#WMInit">WMInit</A> or <A HREF="#WMInitSubMenu">WMInitSubMenu</A>.
To accommodate different screen sizes, it is best to determine the size of the
screen (<A HREF="#WMGetScreenSize">WMGetScreenSize</A> will do this for the
default screen) and use that as a basis for the location.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMSetLoc(int x, int y);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMSetLoc(x, y)</CODE>
<BR><CODE>integer x, y</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>x</VAR><DD>(in) Is the position, in pixels, of the left edge of the
    dialog.  A value of zero is equivalent to the left edge of the screen;
    positive values shift of <VAR>x</VAR> shift the dialog to the right
    from the left of the screen.
  <DT><VAR>y</VAR><DD>(in) Is the position, in pixels, of the top edge of the
    dialog.  A value of zero is equivalent to the top edge of the screen;
    positive values shift of <VAR>y</VAR> shift the dialog downward
    from the top of the screen.
</DL>
<H4>Return Value</H4>
<P>Returns negative one and has no effect if <VAR>x</VAR> or <VAR>y</VAR> is
less than zero; otherwise, returns zero.

<HR>
<H3><A NAME="WMSetOverlayUse">WMSetOverlayUse</A></H3>
<H4>Overview</H4>
<P>What is visible on the screen consists of one or more layers, depending
on the graphics hardware and drivers.  A layer can be updated
independently without affecting the contents of the other layers.
The overlay planes are a layer whose contents can obscure the contents of the
layers normally used for drawing.  The overlay planes are especially useful
for drawing on top of windows that are time-consuming to redraw.
A disadvantage of the overlay planes is that they may have a limited
number of available colors.
<P>Use WMSetOverlayUse to control whether or not dialogs or pulldown menus
created after the call to WMSetOverlayUse will attempt to use the overlay
planes.  To test whether or not overlay planes are available and the number
of colors in the overlay planes, you can use
<A HREF="#WMOverlayDepth">WMOverlayDepth</A>.
<P>This function was added in January 1999.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMSetOverlayUse(int flag);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>include 'WM.inc'</CODE>
<BR><CODE>integer function WMSetOverlayUse(flag)</CODE>
<BR><CODE>integer flag</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>flag</VAR><DD>(in) If <VAR>flag</VAR> is equal to WM_OVERLAY_YES,
    subsequent calls (until the next call to WMSetOverlayUse) to
    <A HREF="#WMInit">WMInit</A>,
    <A HREF="#WMInitSubMenu">WMInitSubMenu</A>,
    <A HREF="#WMConfirm">WMConfirm</A>,
    <A HREF="#WMConfirmError">WMConfirmError</A>,
    <A HREF="#WMShowInfo">WMShowInfo</A>,
    <A HREF="#WMPostInfo">WMPostInfo</A>,
    <A HREF="#WMAddOptionMenu">WMAddOptionMenu</A>,
    <A HREF="#WMAddPulldown">WMAddPulldown</A>,
    <A HREF="#WMAddPulldownMenu">WMAddPulldownMenu</A>,
    <A HREF="#WMAddNestedPulldown">WMAddNestedPulldown</A>,
    <A HREF="#WMAddPullRight">WMAddPullRight</A> will attempt to use
    the overlay planes (if the system does not support overlay planes
    the listed functions will operate normally).  If <VAR>flag</VAR> is
    WM_OVERLAY_NO (or any other value not equal to WM_OVERLAY_YES), calls
    to create dialogs and pulldown menus will function normally:  pulldowns
    will use the same planes as their parent dialogs and dialogs will use
    the normal planes.
</DL>
<H4>Return Value</H4>
<P>If WMSetOverlayUse has been called before, returns WM_OVERLAY_YES if the
argument to the last call to WMSetOverlayUse was WM_OVERLAY_YES and returns
WM_OVERLAY_NO if the argument to the last call to WMSetOverlayUse was something
other than WM_OVERLAY_YES.  Otherwise, returns WM_OVERLAY_NO.

<HR>
<H2>Widgets Creation Functions</H2>

<H3><A NAME="WMAddArrowButton">WMAddArrowButton</A></H3>
<H4>Overview</H4>
<P>Creates a button labeled with a picture of an arrow (pointing up, down,
left, or right).  When the user presses the button, a routine registered
by the user will be called.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddArrowButton(int dir, int (*callback)(), int* param);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>include 'WM.inc'</CODE>
<BR><CODE>integer function WMAddArrowButton(dir, callback, param)</CODE>
<BR><CODE>integer dir, callback, param</CODE>
<BR><CODE>external callback</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>dir</VAR><DD>(in) Sets the direction of the arrow shown on the
    button.  Possible values are WM_UP_ARROW, WM_DOWN_ARROW, WM_RIGHT_ARROW,
    and WM_LEFT_ARROW.
  <DT><VAR>callback</VAR><DD>(in) After the user presses the button, the WM
    library will call <VAR>callback</VAR>.  The WM library will pass
    <VAR>callback</VAR> a single argument, the value of <VAR>param</VAR> (i.e.
    a pointer to an integer in C and a reference to an integer in Fortran),
    and will expect <VAR>callback</VAR> to return an integer value (the
    particular value returned, however, has no effect on the behavior of the WM
    library).  When WMAddArrowButton is called from C, <VAR>callback</VAR> may
    be zero to signal that no callback should be performed by the WM library
    when the button is pressed.
  <DT><VAR>param</VAR><DD>(in) Is passed as the argument to <VAR>callback</VAR>
    when the user presses the arrow button.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the button created.

<HR>
<H3><A NAME="WMAddCharField">WMAddCharField</A></H3>
<H4>Overview</H4>
<P>Creates a field which will display a single line of text that the user
can modify.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddCharField(char* text, int maxlen, int dislen, int (*callback)(), int* params, int update, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddCharField(text, maxlen, dislen, callback, params, update, group)</CODE>
<BR><CODE>character*(*) text</CODE>
<BR><CODE>integer maxlen, dislen, callback, params, update, group</CODE>
<BR><CODE>external callback</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>text</VAR><DD>(in/out) Is the storage for the text displayed in the
    field.  If you call WMAddCharField from C or C++, <VAR>text</VAR> should
    be a null-terminated string capable of holding at least <VAR>maxlen</VAR>
    characters (including the terminating null character).  If you call
    WMAddCharField from Fortran, <VAR>text</VAR> should be a character array,
    and, if you want to be compatible with IVE 3.3 or versions of IVE 4
    earlier than 4.2.0, <VAR>text</VAR> must include a null character
    (i.e. char(0)) to mark the end of the text.
  <DT><VAR>maxlen</VAR><DD>(in) Is the maximum number of characters
    <VAR>text</VAR> can hold.  If WMAddCharField is called from C or C++,
    <VAR>maxlen</VAR> should include the space needed for the terminating null.
    If WMAddCharField is called from Fortran, WMAddCharField will use the
    smaller of <VAR>maxlen</VAR> and the maximum length of <VAR>text</VAR>
    as the maximum number of characters to store in <VAR>text</VAR>.
  <DT><VAR>dislen</VAR><DD>(in) Is the number of characters from
    <VAR>text</VAR> to display at one time.
  <DT><VAR>callback</VAR><DD>(in) When the user finishes editing the contents
    of the field (either explicitly by pressing Return when the field has input
    focus or implicitly by causing the field to lose input focus) and the
    contents of the field have changed since the later of the last edit or the
    last program-initiated update (via one of the WMUpdate routines), the WM
    library will call <VAR>callback</VAR>.  The WM library will pass
    <VAR>callback</VAR> a single argument, the value of <VAR>params</VAR> (i.e.
    a pointer to an integer in C and a reference to an integer in Fortran), and
    will expect <VAR>callback</VAR> to return an integer value (the particular
    value returned, however, has no effect on the behavior of the WM library).
    When WMAddCharField is called from C, <VAR>callback</VAR> may be zero to
    signal that no callback should be performed by the WM library when the
    user edits the text field.
  <DT><VAR>params</VAR><DD>(in) Is passed as the argument to
     <VAR>callback</VAR>.
  <DT><VAR>update</VAR><DD>(in) If <VAR>update</VAR> is nonzero and the user
    finishes an edit that modifies the contents of the text field, the WM
    library will call <A HREF="#WMUpdateGroup">WMUpdateGroup</A> with the value
    of <VAR>group</VAR> as the argument.  If <VAR>update</VAR> is zero, the
    WM library will not call <A HREF="#WMUpdateGroup">WMUpdateGroup</A>
    internally when a change occurs.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the field will belong.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the field created.

<HR>
<H3><A NAME="WMAddDoButton">WMAddDoButton</A></H3>
<H4>Overview</H4>
<P>Creates a push button, labeled "Do it", that when pushed will generate
a script.  The library will then execute the script via the command
given by <VAR>qcom</VAR>.  Until the command completes, the button
will be labeled "Cancel", and pressing the button will open a confirmation
dialog for the user to indicate whether or not to kill the running
command.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddDoButton(int (*build_com)(), int* param, const char* qcom, char* command);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddDoButton(build_com, param, qcom, command)</CODE>
<BR><CODE>integer build_com, param</CODE>
<BR><CODE>character*(*) qcom, command</CODE>
<BR><CODE>external build_com</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>build_com</VAR><DD>(in) Is the routine the library will call
    to generate the script.  The library passes the routine two arguments
    and expects an integer return value.  The first argument is the value of
    <VAR>param</VAR> (i.e. a pointer to an integer in C and a reference to
    an integer in Fortran).  The second argument is the value of
    <VAR>command</VAR>, the name of the script file (represented as a pointer
    to a character in C and a character*(*) array in Fortran).  If the returned
    value is greater than or equal to zero, the WM library will proceed
    to operate upon the script as described in the overview of WMAddButton.
    Otherwise, the library does nothing with the generated script.  When
    WMAddDoButton is called from C, <VAR>build_com</VAR> may be zero; in that
    case, the WM library will not call user code before executing the script.
  <DT><VAR>param</VAR><DD>(in) Is passed as the first argument to
    <VAR>build_com</VAR>.
  <DT><VAR>qcom</VAR><DD>(in) If <VAR>qcom</VAR> does not equal "NULL",
    <VAR>qcom</VAR> holds the command line to use when executing the
    script.  A space and then the name of the script is appended to this
    command line before execution.  If <VAR>qcom</VAR> is "NULL", the script
    is executed directly.  If you call WMAddDoButton from Fortran and you
    want to be compatible with IVE 3.3 or versions of IVE 4 earlier than
    4.2.0, <VAR>qcom</VAR> must include a null character (i.e. char(0)) to
    mark the end of the command line.
  <DT><VAR>command</VAR><DD>(in) Is the name of the script file.  If you
    call WMAddDoButton from Fortran and you want to be compatible with IVE 3.3
    or versions of IVE 4 earlier than 4.2.0, <VAR>command</VAR> must include a
    null character (i.e. char(0)) to mark the end of the file name.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the button created.

<HR>
<H3><A NAME="WMAddDrawingArea">WMAddDrawingArea</A></H3>
<H4>Overview</H4>
<P>Creates a canvas (an instance of an XmDrawingArea) where you can do custom
drawing via direct calls to the X libraries.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddDrawingArea(int width, int height);</CODE>
<H4>Fortran Prototype</H4>
<P>No Fortran interface is available.
<H4>Parameters</H4>
<DL>
  <DT><VAR>width</VAR><DD>(in) Is the width, in pixels, of the drawing area.
  <DT><VAR>height</VAR><DD>(in) Is the height, in pixels, of the drawing area.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the drawing area created.

<HR>
<H3><A NAME="WMAddFloatField">WMAddFloatField</A></H3>
<H4>Overview</H4>
<P>Creates a field which will display one or more floating-point values that
the user can modify.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<P><CODE>Widget WMAddFloatField(float* fptr, int num, int dislen, int maxlen, float* min, float* max, int* decimal, int (*callback)(), int* param, int update, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddFloatField(fptr, num, dislen, maxlen, min, max, decimal, callback, param, update, group)</CODE>
<BR><CODE>integer num, dislen, maxlen, decimal, callback, param, update, group</CODE>
<BR><CODE>real fptr(num), min, max</CODE>
<BR><CODE>external callback</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>fptr</VAR><DD>(in/out) Is the storage for the floating-point values
    displayed in the field.  Must have space for at least <VAR>num</VAR>
    values.
  <DT><VAR>num</VAR><DD>(in) Is the number of floating-point values to display.
  <DT><VAR>dislen</VAR><DD>(in) Is the width of the field in characters.
  <DT><VAR>maxlen</VAR><DD>(in) Is the maximum number of characters to use
    for the textual representation of the floating-point values.  In version
    4.1.6 and later of IVE 4 and the November 2003 or later versions of
    IVE 3.3, the value of <VAR>maxlen</VAR> has no effect.
  <DT><VAR>min</VAR><DD>(in) If the user modifies the floating-point values
    and <VAR>min</VAR> is not equal to <VAR>max</VAR>, the changes will be
    reversed if one or more of the newly entered values is less than
    <VAR>min</VAR>.  When <VAR>min</VAR> is equal to <VAR>max</VAR>, no such
    check is done.  The storage location referenced by <VAR>min</VAR> must
    remain valid as long as the field exists.
  <DT><VAR>max</VAR><DD>(in) If the user modifies the floating-point values
    and <VAR>min</VAR> is not equal to <VAR>max</VAR>, the changes will be
    reversed if one or more of the newly entered values is greater than
    <VAR>max</VAR>.  When <VAR>min</VAR> is equal to <VAR>max</VAR>, no such
    check is done.  The storage location referenced by <VAR>max</VAR> must
    remain valid as long as the field exists.
  <DT><VAR>decimal</VAR><DD>(in) Holds the number of decimal places to display
    for each value.  If the value referenced by <VAR>decimal</VAR> is less than
    zero, zero decimal places are shown.  The storage location referenced
    by <VAR>decimal</VAR> must remain valid as long as the field exists.
  <DT><VAR>callback</VAR><DD>(in) When the user finishes editing the contents
    of the field (either explicitly by pressing Return when the field has input
    focus or implicitly by causing the field to lose input focus), the WM
    library will call <VAR>callback</VAR> if one or more of the values has
    changed since the later of the last edit or the last program-initiated
    update (via one of the WMUpdate routines).  The WM library will pass
    <VAR>callback</VAR> a single argument, the value of <VAR>param</VAR>
    (i.e. a pointer to an integer in C and a reference to an integer in
    Fortran), and expects <VAR>callback</VAR> to return an integer value (the
    particular value returned, however, has no effect on the behavior of the
    WM library).  When WMAddFloatField is called from C, <VAR>callback</VAR>
    may be zero to signal that no callback should be performed by the WM
    library when the user edits the field.
  <DT><VAR>param</VAR><DD>(in) Is passed as the argument to
     <VAR>callback</VAR>.
  <DT><VAR>update</VAR><DD>(in) If <VAR>update</VAR> is nonzero and the user
    finishes an edit that modifies the contents of the field, the WM
    library will call <A HREF="#WMUpdateGroup">WMUpdateGroup</A> with the value
    of <VAR>group</VAR> as the argument.  If <VAR>update</VAR> is zero, the
    WM library will not call <A HREF="#WMUpdateGroup">WMUpdateGroup</A>
    internally when a change occurs.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the field will belong.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the created field.

<HR>
<H3><A NAME="WMAddFuncButton">WMAddFuncButton</A></H3>
<H4>Overview</H4>
<P>Creates a push button that performs an arbitrary action when pressed.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddFuncButton(char* label, int (*callback)(), int* param, int update, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddFuncButton(label, callback, param, update, group)</CODE>
<BR><CODE>integer callback, param, update, group</CODE>
<BR><CODE>character*(*) label</CODE>
<BR><CODE>external callback</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>label</VAR><DD>(in/out) Is the label that will appear on the button.
    If you call WMAddFuncButton from Fortran and you want to be compatible with
    IVE 3.3 or versions of IVE 4 earlier than 4.2.0, <VAR>label</VAR> must
    include a null character (i.e. char(0)) to mark the end of the label.
    <VAR>label</VAR> must remain valid for the lifetime of the button.  Calls
    to <A HREF="#WMUpdateField">WMUpdateField</A> or
    <A HREF="#WMUpdateGroup">WMUpdateGroup</A> which affect the button will
    update the label on the button with the current contents of
    <VAR>label</VAR>.  If you use
    <A HREF="#WMAddSaveButton">WMAddSaveButton</A> in your application, it
    is dangerous to use a constant string for <VAR>label</VAR>:  if the
    user loads previous state, the WM library will write to <VAR>label</VAR>
    if the saved state has a different label than the current one.
  <DT><VAR>callback</VAR><DD>(in) When the user presses the button, the WM
    library will call <VAR>callback</VAR>.  The WM library will pass
    <VAR>callback</VAR> a single argument, the value of <VAR>param</VAR> (i.e.
    a pointer to an integer in C and a reference to an integer in Fortran), and
    expects <VAR>callback</VAR> to return an integer value (the particular
    value returned, however, has no effect on the behavior of the WM library).
    When WMAddFuncButton is called from C, <VAR>callback</VAR> may be zero to
    signal that no callback should be performed by the WM library when the
    user presses the button.
  <DT><VAR>param</VAR><DD>(in) Is passed as the argument to
     <VAR>callback</VAR>.
  <DT><VAR>update</VAR><DD>(in) If <VAR>update</VAR> is nonzero and the user
    presses the button, the WM library will call
    <A HREF="#WMUpdateGroup">WMUpdateGroup</A> with the value
    of <VAR>group</VAR> as the argument.  If <VAR>update</VAR> is zero, the
    WM library will not call <A HREF="#WMUpdateGroup">WMUpdateGroup</A>
    internally when the button is pressed.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the button will belong.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the button created.

<HR>
<H3><A NAME="WMAddFuncList">WMAddFuncList</A></H3>
<H4>Overview</H4>
<P>Creates a vertical list of function buttons in a scrolled window.  Each
function button has an associated button that can display help when pressed.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddFuncList(const char* const* funcname, const char* const* helpindex, int nfunc, int width, int height, int* ifunc, int (*callback)(), int* param, int update);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddFuncList(funcname, helpindex, nfunc, width, height, ifunc, callback, param, update)</CODE>
<BR><CODE>integer nfunc, width, height, ifunc, callback, param, update</CODE>
<BR><CODE>character*(*) funcname, helpindex</CODE>
<BR><CODE>external callback</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>funcname</VAR><DD>(in) In C, <VAR>funcname</VAR> is an array of
    <VAR>nfunc</VAR> null-terminated strings where the ith element is the label
    for the ith function button.  In Fortran, <VAR>funcname</VAR> is a
    character array containing the labels for each function button separated
    by tildes (for instance, with four buttons you could use
    'one~two~three~four~' to have the first button labeled "one", the second
    button labeled "two", and so on).  If you call WMAddFuncButton from Fortran
    and you want to be compatible with IVE 3.3 or versions of IVE 4 earlier
    than 4.2.0, <VAR>funcname</VAR> must include a null character (i.e.
    char(0)) to mark the end of the button names.
  <DT><VAR>helpindex</VAR><DD>(in) In C, <VAR>helpindex</VAR> may be zero,
    indicating that no help is available for the function buttons.  If
    <VAR>helpindex</VAR> is nonzero, it is assumed to be an array of
    <VAR>nfunc</VAR> null-terminated strings where the ith element is the help
    keyword for the ith button.  In Fortran, <VAR>helpindex</VAR> is a
    character array containing the help keywords for each function button
    separated by tildes (for instance, with four buttons you could use
    'MyApp One~MyApp Two~MyApp Three~MyApp Four~' to specify the keywords
    for the four buttons).  For more information about help keywords, look at
    the <A HREF="#WMAddInfoButton">description of WMAddInfoButton</A>.  If you
    call WMAddFuncButton from Fortran and you want to be compatible with
    IVE 3.3 or versions of IVE 4 earlier than 4.2.0, <VAR>helpindex</VAR> must
    include a null character (i.e. char(0)) to mark the end of the help topic
    names.
  <DT><VAR>nfunc</VAR><DD>(in) Is the number of function buttons in the list.
  <DT><VAR>width</VAR><DD>(in) Is the width, in pixels, for the visible area
    of the scrolled window.  If <VAR>width</VAR> is less than or equal to zero,
    the scrolled window extends to the right edge of the parent dialog.
  <DT><VAR>height</VAR><DD>(in) Is the height, in pixels, for the visible
    area of the scrolled window.  If <VAR>height</VAR> is less than or equal
    to zero, the scrolled window will be one hundred pixels high.
  <DT><VAR>ifunc</VAR><DD>(out) References the integer where the zero-based
    index (i.e. from zero to <VAR>nfunc</VAR> minus one) of the last function
    button pressed will be stored.
  <DT><VAR>callback</VAR><DD>(in) When the user presses one of the function
    buttons in the list, the WM library will set <VAR>ifunc</VAR> to the
    zero-based index of the button pressed and then call <VAR>callback</VAR>.
    The WM library will pass <VAR>callback</VAR> a single argument, the value
    of <VAR>param</VAR> (i.e. a pointer to an integer in C and a reference to
    an integer in Fortran), and expects <VAR>callback</VAR> to return an
    integer value (the particular value returned, however, has no effect on the
    behavior of the WM library).  When WMAddFuncButton is called from C,
    <VAR>callback</VAR> may be zero to signal that no callback should be
    performed by the WM library when the user presses a button in the list.
  <DT><VAR>param</VAR><DD>(in) Is passed as the argument to
     <VAR>callback</VAR>.
  <DT><VAR>update</VAR><DD>(in) Is present for backward compatibility
    and has no effect on the behavior of the list of function buttons.
</DL>
<H4>Return Value</H4>
<P>Returns the identification value for the list of function buttons.

<HR>
<H3><A NAME="WMAddGetFile">WMAddGetFile</A></H3>
<H4>Overview</H4>
<P>Creates a control for selecting a file.  The control has a button
which will display a file selection dialog when pressed and an adjacent
text field which displays the current file name and allows direct entry of the
name.
<H4>C Prototype</H4>
<P><CODE>Widget WMAddGetFile(const char* label, char* dir, char* pattern, int maxlen, int dislen, char* filename, int (*callback)(), int* param, int update, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddGetFile(label, dir, pattern, maxlen, dislen, filename, callback, param, update, group)</CODE>
<BR><CODE>integer maxlen, dislen, callback, param, update, group</CODE>
<BR><CODE>character*(*) label, dir, pattern, filename</CODE>
<BR><CODE>external callback</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>label</VAR><DD>(in) Is the label displayed on the function button.
    If you call WMAddGetFile from Fortran and you want to be compatible with
    IVE 3.3 or versions of IVE 4 earlier than 4.2.0, <VAR>label</VAR> must
    include a null character (i.e. char(0)) to mark the end of the label.
  <DT><VAR>dir</VAR><DD>(in) For compatibility with previous versions, you
    should pass a null-terminated string or zero for <VAR>dir</VAR> if you
    call WMAddGetFile from C or a character array which includes a terminating
    null character if you call WMAddGetFile from Fortran.  In all versions,
    <VAR>dir</VAR> has no effect on the behavior of the control.  It was
    intended to be the initial directory for the file browser, but the starting
    directory and file name filter for the file browser will always be those
    associated with the keys set by the most recent call to
    <A HREF="#WMSetGetFileSrc">WMSetGetFileSrc</A> when user presses the
    file selection button.
  <DT><VAR>pattern</VAR><DD>(in) For compatibility with previous versions, you
    should pass a null-terminated string or zero for <VAR>pattern</VAR> if you
    call WMAddGetFile from C or a character array which includes a terminating
    null character if you call WMAddGetFile from Fortran.  In all versions,
    <VAR>pattern</VAR> has no effect on the behavior of the control.  It was
    intended to be the initial file name filter for the file browser, but the
    starting directory and file name filter for the file browser will always
    be those associated with the keys set by the most recent call to
    <A HREF="#WMSetGetFileSrc">WMSetGetFileSrc</A> when user presses the
    file selection button.
  <DT><VAR>maxlen</VAR><DD>(in) Is the maximum number of characters
    <VAR>filename</VAR> can hold.  If called from C, <VAR>maxlen</VAR> should
    include the space for the terminating null.  If called from Fortran,
    WMAddGetFile, will use the smaller of <VAR>maxlen</VAR> and the maximum
    length of <VAR>filename</VAR> as the maximum number of characters to store
    in <VAR>text</VAR>.
  <DT><VAR>dislen</VAR><DD>(in) Is the number of characters from
    <VAR>filename</VAR> to display at one time.
  <DT><VAR>filename</VAR><DD>(in/out) Is the storage for the file name.  If
    WMAddGetFile is called from C or C++, <VAR>text</VAR> should be a
    null-terminated string capable of holding at least <VAR>maxlen</VAR>
    characters (including the terminating null character).  If WMAddCharField
    is called from Fortran, <VAR>text</VAR> should be a character array (if you
    also want to be compatible with IVE 3.3 or versions of IVE 4 earlier than
    4.2.0, <VAR>filename</VAR> must include a null character (i.e. char(0)) to
    mark the end of the name).
  <DT><VAR>callback</VAR><DD>(in) When the user completes editing the
    file name displayed in the file field (either explicitly by pressing
    Return when the field has input focus or implicitly by causing the field
    to lose input focus) and the contents of the field have changed since the
    later of the last edit or the last program-initiated update (via one
    of the WMUpdate routines) or the user selects a file via the file browser,
    the WM library will call <VAR>callback</VAR>.  The WM library passes
    <VAR>callback</VAR> a single argument, the value of <VAR>param</VAR> (i.e.
    a pointer to an integer in C and a reference to an integer in Fortran),
    and expects <VAR>callback</VAR> to return an integer value (the particular
    value returned, however, has no effect on the behavior of the WM library).
    When WMAddGetFile is called from C, <VAR>callback</VAR> may be zero to
    signal that no callback should be performed by the WM library when the user
    edits file name field is edited or selects a file via the file browser.
  <DT><VAR>param</VAR><DD>(in) Is passed as the argument to
    <VAR>callback</VAR>.
  <DT><VAR>update</VAR><DD>(in) If <VAR>update</VAR> is nonzero and the user
    finishes an edit that modifies the contents of the file name field or
    selects a file via the file browser, the WM library will call
    <A HREF="#WMUpdateGroup">WMUpdateGroup</A> with the value
    of <VAR>group</VAR> as the argument.  If <VAR>update</VAR> is zero, the
    WM library will not call <A HREF="#WMUpdateGroup">WMUpdateGroup</A>
    internally when a change occurs.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the control will belong.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the control.

<HR>
<H3><A NAME="WMAddGLwMDrawWidget">WMAddGLwMDrawWidget</A></H3>
<H4>Overview</H4>
<P>Creates a canvas (a GLwMDrawingAreaWidget) where you can do custom drawing
via direct calls to the OpenGL libraries.  The canvas is double-buffered and
operates in RGB mode.

<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddGLwMDrawWidget(int width, int height, int (*expose_callback), int* ex_param, int (*input_callback)(), int* input_param, GLXContext* context);</CODE>
<H4>Fortran Prototype</H4>
<P>No Fortran interface is available.
<H4>Parameters</H4>
<DL>
  <DT><VAR>width</VAR><DD>(in) Is the width, in pixels, of the drawing area.
  <DT><VAR>height</VAR><DD>(in) Is the height, in pixels, of the drawing area.
  <DT><VAR>expose_callback</VAR><DD>(in) If not zero, the WM library calls
    this function when the drawing area is exposed (i.e. needs to be
    redrawn).  The WM library passes the function three arguments:  the Widget
    for the drawing area, an XtPointer which is equivalent to the pointer value
    <VAR>ex_param</VAR>, and an XtPointer to a GLwDrawingAreaCallbackStruct.
    Though declared as returning an integer, <VAR>expose_callback</VAR> is
    invoked internally as if it did not return a value.
  <DT><VAR>ex_param</VAR><DD>(in) Is passed as the second argument to
    <VAR>expose_callback</VAR>.
  <DT><VAR>input_callback</VAR><DD>(in) If not zero, the WM library calls
    this function when the drawing area receives an input event.  The WM
    library passes the function three arguments:  the Widget for the drawing
    area, an XtPointer which is equivalent to the pointer value
    <VAR>input_param</VAR>, and an XtPointer to a GLwDrawingAreaCallbackStruct.
    Though declared as returning an integer, <VAR>input_callback</VAR> is
    invoked internally as if it did not return a value.
  <DT><VAR>input_param</VAR><DD>(in) Is passed as the second argument to
    <VAR>input_callback</VAR>.
  <DT><VAR>context</VAR><DD>(out) After realizing the drawing area,
    the WM library sets *<VAR>context</VAR> to the GLXContext created for the
    canvas.  You will need the context for GLwDrawingAreaMakeCurrent().  The
    WM library will destroy the context when the canvas is destroyed.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the drawing area created.

<HR>
<H3><A NAME="WMAddHorSlider">WMAddHorSlider</A></H3>
<H4>Overview</H4>
<P>Creates a control for selecting an integer value from a range of
possibilities.  The control consists of narrow rectangular region displayed
horizontally with a marker for the current value.  The user can move the marker
back and forth to change the value.  If you want the control to display the
current value as text as well, call
<A HREF="#WMSliderShowValue">WMSliderShowValue</A> before making the call to
WMAddHorSlider.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddHorSlider(const char* label, int width, int min, int max, int* ivar, int (*scallback)(), int* param, int (*dcallback), int* dparam, int update, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddHorSlider(label, width, min, max, ivar, scallback, param, dcallback, dparam, update, group)</CODE>
<BR><CODE>integer width, min, max, ivar, scallback, param, dcallback, dparam, update, group</CODE>
<BR><CODE>character*(*) label</CODE>
<BR><CODE>external scallback, dcallback</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>label</VAR><DD>(in) Is the label drawn beneath the control.  If
    WMAddHorSlider is called from C, label may be zero and no label will be
    displayed.  If you call WMAddHorSlider from Fortran and want to be
    compatible with IVE 3.3 or versions of IVE 4 earlier than 4.2.0,
    <VAR>label</VAR> must include a null character (i.e. char(0)) to mark the
    end of the label.
  <DT><VAR>width</VAR><DD>(in) Is the length, in pixels, of the narrow
    rectangular part of the control.  If <VAR>width</VAR> is zero, the
    rectangle is attached to the right edge of the parent dialog.
  <DT><VAR>min</VAR><DD>(in) Is the minimum allowed value.  <VAR>min</VAR> must
    be less than <VAR>max</VAR>.
  <DT><VAR>max</VAR><DD>(in) Is the maximum allowed value.  <VAR>max</VAR> must
    be greater than <VAR>min</VAR>.
  <DT><VAR>ivar</VAR><DD>(in/out) Holds the value corresponding to the current
    slider position.
  <DT><VAR>scallback</VAR><DD>(in) The WM library calls this routine when
    the user changes the value by interacting with the control.  The WM library
    passes <VAR>scallback</VAR> a single argument, the value of
    <VAR>param</VAR> (i.e. a pointer to an integer in C and a reference to an
    integer in Fortran), and expects <VAR>scallback</VAR> to return an integer
    value (the particular value returned, however, has no effect on the
    behavior of the WM library).  When WMAddHorSlider is called from C,
    <VAR>callback</VAR> may be zero to signal that no callback should be
    performed by the WM library when the value changes.
  <DT><VAR>param</VAR><DD>(in) Is passed as the argument to
    <VAR>scallback</VAR>.
  <DT><VAR>dcallback</VAR><DD>(in) As the user drags the marker in the
    control, the WM library will call this routine.  The WM library will pass
    <VAR>dcallback</VAR> a single argument, the value of <VAR>dparam</VAR>
    (i.e. a pointer to an integer in C and a reference to an integer in
    Fortran), and expects <VAR>dcallback</VAR> to return an integer value (the
    particular value returned, however, has not effect on the behavior of the
    WM library).  When WMAddHorSlider is called from C, <VAR>dcallback</VAR>
    may be zero to signal that no callback should be performed as the user
    drags the marker.
  <DT><VAR>dparam</VAR><DD>(in) Is passed as the argument to
    <VAR>scallback</VAR>.
  <DT><VAR>update</VAR><DD>(in) If <VAR>update</VAR> is nonzero and the
    user changes the value or is in the process of dragging the marker
    and <VAR>dcallback</VAR> is nonzero, the WM library will call
    <A HREF="#WMUpdateGroup">WMUpdateGroup</A> with the value
    of <VAR>group</VAR> as the argument.  If <VAR>update</VAR> is zero, the
    WM library will not call <A HREF="#WMUpdateGroup">WMUpdateGroup</A>
    internally when a change occurs.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the control will belong.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the created control.

<HR>
<H3><A NAME="WMSliderShowValue">WMSliderShowValue</A></H3>
<H4>Overview</H4>
<P>Affects whether or not calls to <A HREF="#WMAddHorSlider">WMAddHorSlider</A>
made after the call to WMSliderShowValue will create controls where the
current value is also displayed as a text label above the control.  If
WMSliderShowValue has not been called, controls created by
<A HREF="#WMAddHorSlider">WMAddHorSlider</A> do not display the current value
as a label.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMSliderShowValue(int flag);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMSliderShowValue(flag)</CODE>
<BR><CODE>integer flag</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>flag</VAR><DD>(in) If <VAR>flag</VAR> is not equal to zero,
    subsequent calls to <A HREF="#WMAddHorSlider">WMAddHorSlider</A> will
    create controls which display the current value as a label above the
    control.  If <VAR>flag</VAR> is zero, subsequent calls to
    <A HREF="#WMAddHorSlider">WMAddHorSlider</A> create controls which
    do not display the current value as a label.
</DL>
<H4>Return Value</H4>
<P>Returns zero.

<HR>
<H3><A NAME="WMAddInfoButton">WMAddInfoButton</A></H3>
<H4>Overview</H4>
<P>Creates a button that, when pressed, displays a particular piece
of documentation in the help viewer.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddInfoButton(const char* label, const char* keyword);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddInfoButton(label, keyword)</CODE>
<BR><CODE>character*(*) label, keyword</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>label</VAR><DD>(in) Is the label to use for the button.  If you call
    WMAddInfoButton from Fortran and want to be compatible with IVE 3.3 or
    versions of IVE 4 earlier than 4.2.0, <VAR>label</VAR> must include a null
    character (i.e. char(0)) to mark the end of the label.
  <DT><VAR>keyword</VAR><DD>(in) Specifies the piece of documentation to
    display.  <VAR>keyword</VAR> is expected to contain the base name of the
    help file optionally followed by a single space and the name of the
    specific topic.  If the base name of the help file does not start with
    "/", then the library will prepend the path to the installed Priism help
    files.  The library will also append either ".html" or ".hlp" to the
    base name of the help file depending on the current preference for the
    help format.  If a topic name is provided, it must not contain a space.
    For ".html" files, the help viewer attempts to jump to the anchor in the
    file that matches the topic name.  For ".hlp" files, the help viewer will
    display the section whose title matches the topic name.  If a topic name
    is not provided, pressing the button will display the file without jumping
    to a specific anchor when using a ".html" file and will display the
    DESCRIPTION section when using a ".hlp" file.  When WMAddInfoButton is
    called from C, <VAR>keyword</VAR> may be zero, and in that case, pressing
    the button will cause a message to be displayed to the user explaining
    that no help is available.  The space pointed to by <VAR>keyword</VAR>
    must remain valid for the lifetime of the button.  If you call
    WMAddInfoButton from Fortran and want to be compatible with IVE 3.3 or
    versions of IVE 4 earlier than 4.2.0, <VAR>keyword</VAR> must include a
    null character (i.e. char(0)) to mark the end of the keyword.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the created button.

<HR>
<H3><A NAME="WMAddIntField">WMAddIntField</A></H3>
<H4>Overview</H4>
<P>Creates a field which will display one or more integer values that the user
can modify.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddIntField(int* iptr, int num, int dislen, int maxlen, int* min, int* max, int* factor, int (*callback)(), int* param, int update, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddIntField(iptr, num, dislen, maxlen, min, max, factor, callback, param, update, group)</CODE>
<BR><CODE>integer num, iptr(num), dislen, maxlen, min, max, factor, callback, param, update, group</CODE>
<BR><CODE>external callback</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>iptr</VAR><DD>(in/out) Is the storage for the integer values
    displayed in the field.  Must have space for at least <VAR>num</VAR>
    values.
  <DT><VAR>num</VAR><DD>(in) Is the number of integer values to display.
  <DT><VAR>dislen</VAR><DD>(in) Is the width of the field in characters.
  <DT><VAR>maxlen</VAR><DD>(in) Is the maximum number of characters to use
    for the textual representation of the integer values.  In version 4.1.6 and
    later of the IVE 4 and the November 2003 or later versions of IVE 3.3,
    the value of <VAR>maxlen</VAR> has no effect.
  <DT><VAR>min</VAR><DD>(in) If the user modifies the integer values and
    <VAR>min</VAR> is not equal to <VAR>max</VAR>, the changes will be
    reversed if one or more of the newly entered values is less than
    <VAR>min</VAR>.  When <VAR>min</VAR> is equal to <VAR>max</VAR>, no such
    check is done.  The storage location referenced by <VAR>min</VAR> must
    remain as long as the field exists.
  <DT><VAR>max</VAR><DD>(in) If the user modifies the integer values and
    <VAR>min</VAR> is not equal to <VAR>max</VAR>, the changes will be
    reversed if one or more of the newly entered values is greater than
    <VAR>max</VAR>.  When <VAR>min</VAR> is equal to <VAR>max</VAR>, no such
    check is done.  The storage location referenced by <VAR>max</VAR> must
    remain as long as the field exists.
  <DT><VAR>factor</VAR><DD>(in) If the user modifies the integer values, the
    changes will be reversed if one or more of the newly entered values is not
    evenly divisible by <VAR>factor</VAR>.  The storage location referenced by
    <VAR>factor</VAR> must remain as long as the field exists.
  <DT><VAR>callback</VAR><DD>(in) When the user finishes editing the contents
    of the field (either explicitly by pressing Return when the field has
    input focus or implicitly by causing the field to lose input focus), the
    WM library will call <VAR>callback</VAR> if one or more of the values
    has changed since the later of the last edit or the last program-initiated
    update (via one of the WMUpdate routines).  The WM library will pass
    <VAR>callback</VAR> a single argument, the value of <VAR>param</VAR> (i.e.
    a pointer to an integer in C and a reference to an integer in Fortran), and
    expects <VAR>callback</VAR> to return an integer value (the particular
    value returned, however, has no effect on the behavior of the WM library).
    When WMAddIntField is called from C, <VAR>callback</VAR> may zero to
    signal that no callback should be performed by the WM library when the
    user edits the field.
  <DT><VAR>param</VAR><DD>(in) Is passed as the argument to
     <VAR>callback</VAR>.
  <DT><VAR>update</VAR><DD>(in) If <VAR>update</VAR> is nonzero and the user
    finishes an edit that modifies the contents of the field, the WM
    library will call <A HREF="#WMUpdateGroup">WMUpdateGroup</A> with the value
    of <VAR>group</VAR> as the argument.  If <VAR>update</VAR> is zero, the
    WM library will not call <A HREF="#WMUpdateGroup">WMUpdateGroup</A>
    internally when a change occurs.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the field will belong.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the created field.

<HR>
<H3><A NAME="WMAddOnOffStatus">WMAddOnOffStatus</A></H3>
<H4>Overview</H4>
<P>Creates an indicator light to signal whether something is on or off.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddOnOffStatus(const char* label, int* ivar, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddOnOffStatus(label, ivar, group)</CODE>
<BR><CODE>character*(*) label</CODE>
<BR><CODE>integer ivar, group</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>label</VAR><DD>(in) Is the label to display next to the indicator.
    If you call WMAddOnOffStatus from Fortran and want to be compatible with
    IVE 3.3 or versions of IVE 4 earlier than 4.2.0, <VAR>label</VAR> must
    include a null character (i.e. char(0)) to mark the end of the label.
  <DT><VAR>ivar</VAR><DD>(in) Holds the value which sets whether the light
    is on or off.  If the value is not equal to zero, the light is on; if the
    value is equal to zero, the light is off.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the control will belong.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the created indicator.

<HR>
<H3><A NAME="WMAddOptionMenu">WMAddOptionMenu</A></H3>
<H4>Overview</H4>
<P>Creates a control for selecting one option from a limited set of options.
The full list of options is only displayed when the user clicks on the control.
The current selection is always shown.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddOptionMenu(const char* const* label, int nlabel, int* ichoice, int (*callback)(), XtPointer param, int update, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddOptionMenu(label, nlabel, ichoice, callback, param, update, group)</CODE>
<BR><CODE>character*(*) label</CODE>
<BR><CODE>integer nlabel, ichoice, callback, param, update, group</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>label</VAR><DD>(in) In C, <VAR>funcname</VAR> is an array of
    <VAR>nlabel</VAR> null-terminated strings where the ith element is the name
    of the ith option.  In Fortran, <VAR>label</VAR> is a character array
    containing the option names separated by tildes (for instance, with
    four options you could use 'vanilla~strawberry~chocolate~rocky road~' to
    have the first option labeled "vanilla", the second labeled "strawberry",
    and so on).  If you call WMAddOptionMenu from Fortran and want to be
    compatible with IVE 3.3 or versions of IVE 4 earlier than 4.2.0,
    <VAR>label</VAR> must include a null character (i.e. char(0)) to mark the
    end of the names.
  <DT><VAR>nlabel</VAR><DD>(in) Is the number of options available.
  <DT><VAR>ichoice</VAR><DD>(in/out) Holds the zero-based index of the
    currently selected option.
  <DT><VAR>callback</VAR><DD>(in) When the user selects an option from the
    list, the WM library sets <VAR>ichoice</VAR> to the index of the selection
    chosen and calls <VAR>callback</VAR>.  The WM library will pass
    <VAR>callback</VAR> a single argument, the value of <VAR>param</VAR> (i.e.
    an XtPointer in C and a reference to an integer in Fortran), and will
    expect <VAR>callback</VAR> to return an integer value (the particular value
    returned, however, has no effect on the behavior of the WM library).  When
    WMAddOptionMenu is called from C, <VAR>callback</VAR> may be zero, and, in
    that case, the WM library will not invoke a callback when the user changes
    the selection.
  <DT><VAR>param</VAR><DD>(in) Is passed as the argument to
    <VAR>callback</VAR>.
  <DT><VAR>update</VAR><DD>(in) If <VAR>update</VAR> is nonzero and the user
    selects an option from the list, the WM library will call
    <A HREF="#WMUpdateGroup">WMUpdateGroup</A> with the value of
    <VAR>group</VAR> as the argument.  If <VAR>update</VAR> is zero, the
    WM library will not call <A HREF="#WMUpdateGroup">WMUpdateGroup</A>
    internally when the user selects an option from the list.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the menu will belong.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the control.

<HR>
<H3><A NAME="WMAddNestedPulldown">WMAddNestedPulldown</A></H3>
<H4>Overview</H4>
<P>Creates a new menu bar with a single menu or adds a menu to an existing
menu bar.  The menu created can have child menus which appear from one or more
of the menu's entries:  use <A HREF="#WMAddPullRight">WMAddPullRight</A> to
add the child menus.  Each menu created will have tear-off menu capability.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddNestedPulldown(Widget ref, const char* menu_name, const int itemTypes[], const char* const* label, int nlabel, int* ichoice, int (*callback)(), int* param, int update, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function XtParent(w)</CODE>
<BR><CODE>integer w</CODE>
<BR><CODE>integer function WMAddNestedPulldown(ref, menu_name, itemTypes, label, nlabel, ichoice, callback, param, update, group)</CODE>
<BR><CODE>integer ref, nlabel, ichoice, param, update, group, itemTypes(nlabel), callback</CODE>
<BR><CODE>character*(*) menu_name, label</CODE>
<BR><CODE>external callback</CODE>
<H4>Params</H4>
<DL>
  <DT><VAR>ref</VAR><DD>(in) To create the first menu in a menu bar, pass
    zero for <VAR>ref</VAR>.  To add the menu to the end of an already
    existing menu bar, pass XtParent(<VAR>w</VAR>) for <VAR>ref</VAR> where
    <VAR>w</VAR> is the value returned by the call to WMAddNestedPulldown
    that created the menu bar you wish to extend.
  <DT><VAR>menu_name</VAR><DD>(in) Is the title for the pulldown menu that
    will be created.
  <DT><VAR>itemTypes</VAR><DD>(in) Is an integer array with <VAR>nlabel</VAR>
    elements.  The ith element of <VAR>itemTypes</VAR> sets
    the format for the ith entry in the menu.  Allowed options for the ith
    element of <VAR>itemTypes</VAR> are:
    <DL>
      <DT>0<DD>The ith entry in the menu is labeled with the ith part of
        <VAR>label</VAR> and does not lead to another menu.  If you pass a
        non-zero value for <VAR>callback</VAR>, that routine will be called
        when the user selects the entry.
      <DT>1<DD>The ith entry in the menu is labeled with the ith part of
        the <VAR>label</VAR> and leads to another menu.
      <DT>2<DD>The ith entry in the menu will be a horizontal separator.
        The ith part of <VAR>label</VAR> is ignored.  Support for separators
        was added in the June 1999 release.
    </DL>
  <DT><VAR>label</VAR><DD>(in) In C, <VAR>label</VAR> is an array of
    <VAR>nlabel</VAR> null-terminated strings where the ith element is used
    as the label for the ith entry in the menu (unless the ith entry is a
    separator; then the ith element of <VAR>label</VAR> is ignored).  In
    Fortran, <VAR>label</VAR> is a character array containing the menu labels
    separated by tildes (for instance, you could use 'New~Open~Save~~Quit~' for
    a menu with five entries where the fourth entry is a separator).
  <DT><VAR>nlabel</VAR><DD>(in) Is the number of entries in the menu.
  <DT><VAR>ichoice</VAR><DD>(out) Holds the zero-based index of the last
    option the user selected.
  <DT><VAR>callback</VAR><DD>(in) When the user selects an entry in the
    menu that is not a separator and does not lead to another menu, the WM
    library sets <VAR>ichoice</VAR> to the index of the entry selected and
    calls <VAR>callback</VAR>.  The WM library will pass <VAR>callback</VAR>
    a single argument, the value of <VAR>param</VAR> (i.e. a pointer to an
    integer in C and a reference to an integer in Fortran), and will expect
    <VAR>callback</VAR> to return an integer value (the particular value
    returned, however, has no effect on the behavior of the WM library).
    When WMAddNestedPulldown is called from C, <VAR>callback</VAR> may be
    zero, and, in that case, the WM library will not invoke a callback when the
    user selects an entry from the menu.
  <DT><VAR>param</VAR><DD>(in) Is passed as the argument to
    <VAR>callback</VAR>.
  <DT><VAR>update</VAR><DD>(in) If <VAR>update</VAR> is nonzero and the
    user selects an option from the menu that is not a separator and does
    no lead to another menu, the WM library will call
    <A HREF="#WMUpdateGroup">WMUpdateGroup</A> with the value of
    <VAR>group</VAR> as the argument.  If <VAR>update</VAR> is zero, the
    WM library will not call <A HREF="#WMUpdateGroup">WMUpdateGroup</A>
    internally when the user selects an item from the menu.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the menu will belong.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the menu created.
<H4>Example</H4>
<P>The following C code fragment creates a menu bar with two entries ("File"
and "Help").  The "File" menu has five entries where the fourth is a separator.
The "Help" menu has two entries, the second of which leads to another menu with
three entries.
<PRE>
    char* file_menu_labels[] = {
        "ViewFile", "CopyRegion", "Prefs", "", "Quit" 
    }
    int file_menu_types[] = { 0, 0, 0, 2, 0 };
    char* help_menu_labels[] = { "Overview", "File" };
    int help_menu_types[] = { 0, 1 };
    Widget menu, menubar, childmenu;
    static int filechoice, helpchoice, helpfilechoice;

    menu = WMAddNestedPulldown(
        0, "File", file_menu_types, file_menu_labels, 5,
        &amp;filechoice, handle_file_menu, &amp;filechoice, 0, 0
    );
    menubar = XtParent(menu);
    menu = WMAddNestedPulldown(
        menubar, "Help", help_menu_types, help_menu_labels, 2,
        &amp;helpchoice, handle_help_menu, &amp;helpchoice, 0, 0
    );
    childmenu = WMAddPullRight(
        menu, 1, file_menu_types, file_menu_labels, 3,
        &amp;helpfilechoice, handle_help_file_menu, &amp;helpfilechoice, 0, 0
    );
</PRE>

<P>The following Fortran code fragment is a literal translation of the C code
above (the Fortran interfaces to WMAddNestedPulldown and
<A HREF="#WMAddPullRight">WMAddPullRight</A> are only available in IVE 4
versions after 4.1.8).
<PRE>
       integer WMAddNestedPulldown, WMAddPullRight, XtParent
       character file_menu_labels(40), help_menu_labels(20)
       integer file_menu_types(5), help_menu_types(2)
       integer menu, menubar, childmenu
       integer filechoice, helpchoice, helpfilechoice
       integer handle_file_menu, handle_help_menu
       integer  handle_help_file_menu
       external handle_file_menu, handle_help_menu
       external handle_help_file_menu
       save filechoice, helpchoice, helpfilechoice
       data file_menu_labels / 'ViewFile~CopyRegion~Prefs~~Quit~' /
       data file_menu_types / 0, 0, 0, 2, 0 /
       data help_menu_labels / 'Overview~File~' /
       data help_menu_types / 0, 1 /

       menu = WMAddNestedPulldown(
      &    0, "File", file_menu_types, file_menu_labels, 5,
      &    filechoice, handle_file_menu, filechoice, 0, 0)
       menubar = XtParent(menu)
       menu = WMAddNestedPulldown(
      &    menubar, "Help", help_menu_types, help_menu_labels, 2,
      &    helpchoice, handle_help_menu, helpchoice, 0, 0)
       childmenu = WMAddPullRight(
      &    menu, 1, file_menu_types, file_menu_labels, 3,
      &    helpfilechoice, handle_help_file_menu, helpfilechoice, 0, 0)
</PRE>

<HR>
<H3><A NAME="WMAddPullRight">WMAddPullRight</A></H3>
<H4>Overview</H4>
<P>Creates a menu that comes off another menu created by either a call to
<A HREF="#WMAddNestedPulldown">WMAddNestedPulldown</A> or a call to
WMAddPullRight.  For an example code fragment that uses both
<A HREF="#WMAddNestedPulldown">WMAddNestedPulldown</A> and WMAddPullRight,
consult the
<A HREF="#WMAddNestedPulldown">WMAddNestedPulldown documentation</A>.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddPullRight(Widget ref, int element, const int itemTypes[], const char* const* label, int nlabel, int* ichoice, int (*callback)(), XtPointer param, int update, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddPullRight(ref, element, itemTypes, label, nlabel, ichoice, callback, param, update, group)</CODE>
<BR><CODE>integer ref, element, nlabel, itemTypes(nlabel), ichoice, callback, param, update, group</CODE>
<BR><CODE>character*(*) label</CODE>
<BR><CODE>external callback</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>ref</VAR><DD>(in) Is the identification value for the menu that
    leads to the menu to be created.  <VAR>ref</VAR> must be the result of a
    call to <A HREF="#WMAddNestedPulldown">WMAddNestedPulldown</A> or
    WMAddPullRight.
  <DT><VAR>element</VAR><DD>(in) Is the zero-based index for the menu entry
    in <VAR>ref</VAR> that leads to the menu to be created.
  <DT><VAR>itemTypes</VAR><DD>(in) Is an integer array with <VAR>nlabel</VAR>
    elements.  The ith element of <VAR>itemTypes</VAR> sets
    the format for the ith entry in the menu.  Allowed options for the ith
    element of <VAR>itemTypes</VAR> are:
    <DL>
      <DT>0<DD>The ith entry in the menu is labeled with the ith part of
        <VAR>label</VAR> and does not lead to another menu.  If you pass a
        non-zero value for <VAR>callback</VAR>, that routine will be called
        when the user selects the entry.
      <DT>1<DD>The ith entry in the menu is labeled with the ith part of
        the <VAR>label</VAR> and leads to another menu.
      <DT>2<DD>The ith entry in the menu will be a horizontal separator.
        The ith part of <VAR>label</VAR> is ignored.  Support for separators
        was added in the June 1999 release.
    </DL>
  <DT><VAR>label</VAR><DD>(in) In C, <VAR>label</VAR> is an array of
    <VAR>nlabel</VAR> null-terminated strings where the ith element is used
    as the label for the ith entry in the menu (unless the ith entry is a
    separator; then the ith element of <VAR>label</VAR> is ignored).  In
    Fortran, <VAR>label</VAR> is a character array containing the menu labels
    separated by tildes (for instance, you could use 'Red~Green~Blue~' for
    a menu with three entries).
  <DT><VAR>nlabel</VAR><DD>(in) Is the number of entries in the menu.
  <DT><VAR>ichoice</VAR><DD>(out) Holds the zero-based index of the last
    option the user selected.
  <DT><VAR>callback</VAR><DD>(in) When the user selects an entry in the
    menu that is not a separator and does not lead to another menu, the WM
    library sets <VAR>ichoice</VAR> to the index of the entry selected and
    calls <VAR>callback</VAR>.  The WM library will pass <VAR>callback</VAR>
    a single argument, the value of <VAR>param</VAR> (i.e. an XtPointer
    in C and a reference to an integer in Fortran), and will expect
    <VAR>callback</VAR> to return an integer value (the particular value
    returned, however, has no effect on the behavior of the WM library).
    When WMAddNestedPulldown is called from C, <VAR>callback</VAR> may be
    zero, and, in that case, the WM library will not invoke a callback when
    the user selects an entry from the menu.
  <DT><VAR>param</VAR><DD>(in) Is passed as the argument to
    <VAR>callback</VAR>.
  <DT><VAR>update</VAR><DD>(in) If <VAR>update</VAR> is nonzero and the
    user selects an option from the menu that is not a separator and does
    no lead to another menu, the WM library will call
    <A HREF="#WMUpdateGroup">WMUpdateGroup</A> with the value of
    <VAR>group</VAR> as the argument.  If <VAR>update</VAR> is zero, the
    WM library will not call <A HREF="#WMUpdateGroup">WMUpdateGroup</A>
    internally when the user selects an item from the menu.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the menu will belong.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the menu created.

<HR>
<H3><A NAME="WMAddPulldown">WMAddPulldown</A></H3>
<H4>Overview</H4>
<P>Creates a control for selecting one option from a limited set of options.
The full list of options is only displayed when the user clicks on the control.
The label shown on the control depends on the last call to 
<A HREF="#WMSetPulldownShowChoice">WMSetPulldownChoice</A> before the control
was created.   If
<A HREF="#WMSetPulldownShowChoice">WMSetPulldownShowChoice</A>
has not been called or was last called with a nonzero argument, the menu
will always display the current choice.  That behavior is identical to what
<A HREF="#WMAddOptionMenu">WMAddOptionMenu</A> does, but the control created
by WMAddPulldown takes up less space and, as drawn on the screen, lacks the
rectangular knob which is intended as a hint to the user that more choices are
available.  If <A HREF="#WMSetPulldownShowChoice">WMSetPulldownShowChoice</A>
has been called with an argument of zero, the menu will always display the
menu title (the last element of <VAR>label</VAR>), i.e. act like a menu bar
which contains only one menu.  For more flexible ways of creating menu bars,
use <A HREF="#WMAddPulldownMenu">WMAddPulldownMenu</A> or
<A HREF="#WMAddNestedPulldown">WMAddNestedPulldown</A>.

<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddPulldown(const char* const* label, int nlabel, int* ichoice, int (*callback)(), int* params, int update, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddPulldown(label, nlabel, ichoice, callback, params, update, group)</CODE>
<BR><CODE>integer nlabel, ichoice, callback, params, update, group</CODE>
<BR><CODE>character*(*) label</CODE>
<BR><CODE>external callback</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>label</VAR><DD>(in) In C, <VAR>label</VAR> is an array of
    null-terminated strings.  The first <VAR>nlabel</VAR> elements of the
    array are the labels for the choices in the menu.  If
    <A HREF="#WMSetPulldownShowChoice">WMSetPulldownShowChoice</A> has
    been called and when called last was passed zero as the argument,
    <VAR>label</VAR> is expected to have an additional element which will
    be used as the title for the menu.  In Fortran, <VAR>label</VAR> is
    a character array containing the menu labels separated by tildes.  If
    <A HREF="#WMSetPulldownShowChoice">WMSetPulldownShowChoice</A> has
    been called and when called last was passed zero as the argument,
    <VAR>label</VAR> is also expected to contain the title for the menu
    after all the labels (for instance, you could use 'Red~Green~Blue~Color~'
    for a menu with three entries that displays a menu title rather than
    the last selection).  If you call WMAddPulldown from Fortran and want to
    be compatible with IVE 3.3 or versions of IVE 4 earlier than 4.2.0,
    <VAR>label</VAR> must include a null character (i.e. char(0)) to mark the
    end of the names.
  <DT><VAR>nlabel</VAR><DD>(in) Is the number of entries in the menu.
  <DT><VAR>ichoice</VAR><DD>(in/out) Holds the zero-based index of the
    last option the user selected.  If
    <A HREF="#WMSetPulldownShowChoice">WMSetPulldownShowChoice</A> has not been
    called or was last called with a nonzero argument, <VAR>ichoice</VAR> is
    expected to hold the initial value for the current selection when
    WMAddPulldown is called.
  <DT><VAR>callback</VAR><DD>(in) When the user selects an entry in the
    menu, the WM library sets <VAR>ichoice</VAR> to the index of the entry
    selected and calls <VAR>callback</VAR>.  The WM library will pass
    <VAR>callback</VAR> a single argument, the value of <VAR>params</VAR>
    (i.e. a pointer to an integer in C and a reference to an integer in
    Fortran), and will expect <VAR>callback</VAR> to return an integer value
    (the particular value returned, however, has no effect on the behavior of
    the WM library).  When WMAddPulldown is called from C, <VAR>callback</VAR>
    may be zero, and, in that case, the WM library will not invoke a callback
    when the user selects an entry from the menu.
  <DT><VAR>params</VAR><DD>(in) Is passed as the argument to
    <VAR>callback</VAR>.
  <DT><VAR>update</VAR><DD>(in) If <VAR>update</VAR> is nonzero and the
    user selects an option from the menu, the WM library will call
    <A HREF="#WMUpdateGroup">WMUpdateGroup</A> with the value of
    <VAR>group</VAR> as the argument.  If <VAR>update</VAR> is zero, the
    WM library will not call <A HREF="#WMUpdateGroup">WMUpdateGroup</A>
    internally when the user selects an item from the menu.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the field will belong.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the menu created.

<HR>
<H3><A NAME="WMSetPulldownShowChoice">WMSetPulldownShowChoice</A></H3>
<H4>Overview</H4>
<P>The behavior of a control created by
<A HREF="#WMAddPulldown">WMAddPulldown</A> depends on how
WMSetPulldownShowChoice has been called prior to the call to
<A HREF="#WMAddPulldown">WMAddPulldown</A>.  If WMSetPulldownShowChoice has
not been called or was last called with a nonzero argument, the created
menu will display the current selection as the menu's title.  If
WMSetPulldownShowChoice has been called and was last called with zero as the
argument, the created menu will not display the current selection as the
menu's title.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMSetPulldownShowChoice(int flag);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMSetPulldownShowChoice(flag)</CODE>
<BR><CODE>integer flag</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>flag</VAR><DD>(in) If <VAR>flag</VAR> is nonzero, subsequent
    calls to <A HREF="#WMAddPulldown">WMAddPulldown</A> will create controls
    that display the current selection as the menu's title.  If
    <VAR>flag</VAR> is zero, subsequent calls to
    <A HREF="#WMAddPulldown">WMAddPulldown</A> will create controls
    that do not display the current selection as the menu's title.
</DL>
<H4>Return Value</H4>
<P>Returns IW_SUCCESS (i.e. one).

<HR>
<H3><A NAME="WMGetPulldownShowChoice">WMGetPulldownShowChoice</A></H3>
<H4>Overview</H4>
<P>Returns the current setting for whether or not pulldown menus created by
<A HREF="#WMAddPulldown">WMAddPulldown</A> display the current selection as
the title or instead have a fixed title.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMGetPulldownShowChoice(void);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMGetPulldownShowChoice()</CODE>
<H4>Return Value</H4>
<P>Returns zero if a call to <A HREF="#WMAddPulldown">WMAddPulldown</A> would
create a pulldown which displays a fixed title.  Returns a non-zero value
if a call to  <A HREF="#WMAddPulldown">WMAddPulldown</A> would create a
pulldown which displays the last selection as the title.

<HR>
<H3><A NAME="WMAddPulldownMenu">WMAddPulldownMenu</A></H3>
<H4>Overview</H4>
<P>Creates a new menu bar with a single menu or adds a menu to an existing
menu bar.  It is similar to
<A HREF="#WMAddNestedPulldown">WMAddNestedPulldown</A>, but does not allow
the created menu to have child menus and, unlike
<A HREF="#WMAddNestedPulldown">WMAddNestedPulldown</A>, the menu does not have
tear-off capability.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddPulldownMenu(Widget ref, const char* menu_name, const char* const* label, int nlabel, int* ichoice, int (*callback)(), XtPointer param, int update, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function XtParent(w)</CODE>
<BR><CODE>integer w</CODE>
<BR><CODE>integer function WMAddPulldownMenu(ref, menu_name, label, nlabel, ichoice, callback, param, update, group)</CODE>
<BR><CODE>character*(*) menu_name, nlabel</CODE>
<BR><CODE>integer ref, nlabel, ichoice, callback, param, update, group</CODE>
<BR><CODE>external callback</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>ref</VAR><DD>(in) To create the first menu in a menu bar, pass
    zero for <VAR>ref</VAR>.  To add the menu to the end of an already
    existing menu bar, pass XtParent(<VAR>w</VAR>) for <VAR>ref</VAR> where
    <VAR>w</VAR> is the value returned by the call to WMAddPulldownMenu
    that created the menu bar you wish to extend.
  <DT><VAR>menu_name</VAR><DD>(in) Is the title for the pulldown menu that
    will be created.
  <DT><VAR>label</VAR><DD>(in) In C, <VAR>label</VAR> is an array of
    <VAR>nlabel</VAR> null-terminated strings where the ith element is used
    as the label for the ith entry in the menu (unless the ith entry is a
    separator; then the ith element of <VAR>label</VAR> is ignored).  In
    Fortran, <VAR>label</VAR> is a character array containing the menu labels
    separated by tildes (for instance, you could use 'New~Open~Save~Quit~' for
    a menu with four entries).  If an entry's label is equal to "separator", a
    horizontal separator will be drawn for that menu entry.
  <DT><VAR>nlabel</VAR><DD>(in) Is the number of entries in the menu.
  <DT><VAR>ichoice</VAR><DD>(out) Holds the zero-based index of the last
    option the user selected.
  <DT><VAR>callback</VAR><DD>(in) When the user selects an entry in the
    menu that is not a separator, the WM library sets <VAR>ichoice</VAR> to
    the index of the entry selected and calls <VAR>callback</VAR>.  The WM
    library will pass <VAR>callback</VAR> a single argument, the value of
    <VAR>param</VAR> (i.e. an XtPointer in C and a reference to an integer in
    Fortran), and will expect <VAR>callback</VAR> to return an integer value
    (the particular value returned, however, has no effect on the behavior of
    the WM library).  When WMAddPulldownMenu is called from C,
    <VAR>callback</VAR> may be zero, and, in that case, the WM library will
    not invoke a callback when the user selects an entry from the menu.
  <DT><VAR>param</VAR><DD>(in) Is passed as the argument to
    <VAR>callback</VAR>.
  <DT><VAR>update</VAR><DD>(in) If <VAR>update</VAR> is nonzero and the
    user selects an option from the menu that is not a separator, the WM
    library will call <A HREF="#WMUpdateGroup">WMUpdateGroup</A> with the
    value of <VAR>group</VAR> as the argument.  If <VAR>update</VAR> is zero,
    the WM library will not call <A HREF="#WMUpdateGroup">WMUpdateGroup</A>
    internally when the user selects an item from the menu.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the field will belong.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the menu created.
<H4>Example</H4>
<P>The following C code fragment creates a menu bar with two entries ("File"
and "Edit").  The "File" menu has five entries where the fourth is a separator.
The "Edit" menu has four entries.
<PRE>
    char* file_menu_labels[] = {
        "New", "Open", "Save", "separator", "Quit"
    };
    char* edit_menu_labels[] = {
        "Cut", "Copy", "Paste", "Select All"
    };
    Widget menu, menubar;
    static int filechoice, editchoice;

     menu = WMAddPulldownMenu(
         0, "File", file_menu_labels, 5, &amp;filechoice,
         handle_file_menu, &amp;filechoice, 0, 0
     );
     menubar = XtParent(menu);
     menu = WMAddPulldownMenu(
         menubar, "Edit", edit_menu_labels, 4, &amp;editchoice,
         handle_edit_menu, &amp;editchoice, 0, 0
     );
</PRE>

<P>The following Fortran code fragment is a literal translation of the C code
above (the Fortran interface to WMAddPulldownMenu is only available in IVE 4
versions after 4.1.8).
<PRE>
       integer WMAddPulldownMenu, XtParent
       character file_menu_labels(40), edit_menu_labels(40)
       integer menu, menubar
       integer filechoice, editchoice
       integer handle_file_menu, handle_edit_menu
       external handle_file_menu, handle_edit_menu
       save filechoice, editchoice
       data file_menu_labels / 'New~Open~Save~separator~Quit~' /
       data help_menu_labels / 'Cut~Copy~Paste~Select All~' /

       menu = WMAddPulldownMenu(
      &    0, "File", file_menu_labels, 5, filechoice,
      &    handle_file_menu, filechoice, 0, 0)
       menubar = XtParent(menu)
       menu = WMAddPulldownMenu(
      &    menubar, "Edit", edit_menu_labels, 2, editchoice,
      &    handle_edit_menu, editchoice, 0, 0)
</PRE>

<HR>
<H3><A NAME="WMAddSaveButton">WMAddSaveButton</A></H3>
<H4>Overview</H4>
<P>Adds a pair of buttons.  The first button, labeled "Save", will save the
current state of all WM user interface controls when pressed.  The second
button, labeled "Restore", will restore settings previously saved.
<P>If you use WMAddSaveButton, be aware of the following:
<UL>
  <LI>Only the first call to WMAddSaveButton made by an application creates
    buttons; all subsequent calls do nothing and return zero.
  <LI>The information saved and retrieved is sensitive to the order in
    which the WM controls were created and the type of controls.  If you
    rearrange the controls or change the types of controls used, reloading
    an old settings file will not work as intended.
  <LI>When settings are restored, they are processed in the order they
    were created before the settings were saved.  If you have dependencies
    between controls (consistency checks, for instance), verify that they will
    work if the controls are updated in that order.
  <LI>When settings are restored, the callbacks registered by the various
    WMAdd* routines are called and internal calls to WMUpdateGroup are
    made if values change.  You will want to structure your application so
    that is sufficient to maintain consistency between whatever internal state
    your application has and the values and settings handled directly by
    the WM library.
  <LI>Some state is not saved:
    <UL>
      <LI>the current labels for buttons created with
        <A HREF="#WMAddFuncList">WMAddFuncList</A>,
        <A HREF="#WMAddGetFile">WMAddGetFile</A>,
        <A HREF="#WMAddInfoButton">WMAddInfoButton</A>, and
        <A HREF="#WMAddToggleButton">WMAddToggleButton</A>
        (labels on buttons created with
        <A HREF="#WMAddFuncButton">WMAddFuncButton</A> are saved) and for
        controls created with <A HREF="#WMAddHorSlider">WMAddHorSlider</A>,
        <A HREF="#WMAddOnOffStatus">WMAddOnOffStatus</A>, and
        <A HREF="#WMAddStatusBar">WMAddStatusBar</A>
      <LI>the current labels and enabled/disabled state for entries in
        menus created with
        <A HREF="#WMAddNestedPulldown">WMAddNestedPulldown</A>,
        <A HREF="#WMAddOptionMenu">WMAddOptionMenu</A>,
        <A HREF="#WMAddPulldown">WMAddPulldown</A>,
        <A HREF="#WMAddPulldownMenu">WMAddPulldownMenu</A>,
        and <A HREF="#WMAddPullRight">WMAddPullRight</A>
      <LI>the current value shown by a control created with
        <A HREF="#WMAddOnOffStatus">WMAddOnOffStatus</A>
      <LI>the current contents and maximum number of lines in a control
        created by <A HREF="#WMAddScrolledText">WMAddScrolledText</A>
      <LI>the current contents of drawing areas created by
        <A HREF="#WMAddDrawingArea">WMAddDrawingArea</A> and
        <A HREF="#WMAddGLwMDrawWidget">WMAddGLwMDrawWidget</A>
    </UL>
</UL>
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddSaveButton(const char* filename);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddSaveButton(filename)</CODE>
<BR><CODE>character*(*) filename</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>filename</VAR><DD>(in) Is the name of the file to use when saving
    and restoring the state of the controls.  If the first character in the
    file name is different then '/', the WM library will construct the file
    name by prepending the given file name with the user's home directory.
    The memory referenced by <VAR>filename</VAR> must remain valid for as
    long as the save and restore buttons exist.  If you call WMAddSaveButton
    from Fortran and want to be compatible with IVE 3.3 or versions of IVE 4
    earlier than 4.2.0, <VAR>filename</VAR> must include a null character
    (i.e. char(0)) to mark the end of the file name.
</DL>
<H4>Return Value</H4>
<P>The first time WMAddSaveButton is called, returns an identification value
for the buttons created; otherwise, returns zero.

<HR>
<H3><A NAME="WMAddScrolledChoices">WMAddScrolledChoices</A></H3>
<H4>Overview</H4>
<P>Creates a control which displays a list of choices in a window with scroll
bars.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddScrolledChoices(char** strings, int* num_items, int num_visible, int (*callback)(), int* params, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddScrolledChoices(strings, num_items, num_visible, callback, params, group)</CODE>
<BR><CODE>character*(*) strings</CODE>
<BR><CODE>integer num_items, num_visible, callback, params, group</CODE>
<BR><CODE>external callback</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>strings</VAR><DD>(in/out) In C, <VAR>strings</VAR> is an array of
    *<VAR>num_items</VAR> null-terminated strings where the ith element is
    the name of the ith choice.  In Fortran, <VAR>label</VAR> is a character
    array containing the names of the choices separated by tildes (for
    instance, with three choices you could use
    'mean~median~standard deviation~' to have the first choice labeled "mean",
    the second labeled "median", and so on).  If your application updates the
    scrolled choices control with <A HREF="#WMUpdateGroup">WMUpdateGroup</A>
    or <A HREF="#WMUpdateField">WMUpdateField</A>, the WM library will
    regenerate the contents of the scrolled choices from the current contents
    of <VAR>strings</VAR> and <VAR>num_items</VAR>.  If your application uses
    a save/restore button generated with
    <A HREF="#WMAddSaveButton">WMAddSaveButton</A>, the WM library will write
    to <VAR>strings</VAR> and <VAR>num_items</VAR> during a restore operation
    and read from them during a save operation.
  <DT><VAR>num_items</VAR><DD>(in/out) Refers to the number of items in the
    list.  After the control has been created, the situations where the WM
    library will access the integer referred to by <VAR>num_items</VAR> are
    mentioned above in the description of the <VAR>strings</VAR> parameter.
  <DT><VAR>num_visible</VAR><DD>(in) Is the number of items that will be
    visible at one time.
  <DT><VAR>callback</VAR><DD>(in) When the user selects a choice from the list,
    the WM library calls <VAR>callback</VAR>.  The WM library will pass
    <VAR>callback</VAR> two arguments.  The first is the zero-based index of
    the selected item.  If WMAddScrolledChoices was called from C, the first
    argument will be passed as an integer; if WMAddScrolledChoices was called
    from Fortran, the first argument will be passed as a reference to an
    integer.  The second argument is the value of <VAR>params</VAR> (i.e.
    a pointer to an integer in C and a reference to an integer in Fortran).
    The WM library expects <VAR>callback</VAR> to return an integer value
    (the particular value returned, however, has no effect on the behavior
    of the WM library).  When WMAddScrolledChoices is called from C,
    <VAR>callback</VAR> may be zero, and, in that case, the WM library will
    not invoke a callback when the user changes the selection.
  <DT><VAR>params</VAR><DD>(in) Is passed as the second argument to
    <VAR>callback</VAR>.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the control will belong.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the created control.

<HR>
<H3><A NAME="WMAddScrolledText">WMAddScrolledText</A></H3>
<H4>Overview</H4>
<P>Creates a control that displays text in a scrolled window.  The control
does not allow the user to edit the text.  Each time the control is updated
via <A HREF="#WMUpdateGroup">WMUpdateGroup</A> or
<A HREF="#WMUpdateField">WMUpdateField</A>, the current contents of the first
argument passed to WMAddScrolledText are appended to the text and, if
necessary, lines at the start of the text are deleted so that the total number
of lines is not greater than the value of the integer referred to by the
second argument passed to WMAddScrolledText.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddScrolledText(const char* text, const int* nitem, int nvis, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddScrolledText(text, nitem, nvis, group)</CODE>
<BR><CODE>character*(*) text</CODE>
<BR><CODE>integer nitem, nvis, group</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>text</VAR><DD>(in) Refers to a single line of text.  If you call
    WMAddScrolledText from C, <VAR>text</VAR> must be a null-terminated string.
    If you call WMAddScrolledText from Fortran and want to be compatible with
    IVE 3.3 or versions of IVE 4 earlier than 4.2.0, <VAR>text</VAR> must
    include a null character (i.e. char(0)) to mark the end of the line.
    <VAR>text</VAR> must remain valid for as long as the control exists.
  <DT><VAR>nitem</VAR><DD>(in) Refers to the total number of lines of text
    available.  The integer referenced by <VAR>nitem</VAR> must remain valid
    for as long as the control exists.
  <DT><VAR>nvis</VAR><DD>(in) Is the number of lines of text that will be
    displayed at one time.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the control will belong.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the created control.

<HR>
<H3><A NAME="WMAddSeparator">WMAddSeparator</A></H3>
<H4>Overview</H4>
<P>Creates a horizontal line that extends all the way across the current
dialog.  Useful (especially when combined with
<A HREF="#WMSetOffset">WMSetOffset</A> to insert blank space before and after
the line), for visually separating distinct groups of controls.  To create
a thicker line, call WMAddSeparator multiple times.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddSeparator(void);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddSeparator()</CODE>
<H4>Return Value</H4>
<P>Returns an identification value for the separator.

<HR>
<H3><A NAME="WMAddStatusBar">WMAddStatusBar</A></H3>
<H4>Overview</H4>
<P>Adds an output-only control that represents an integer value by a horizontal
thermometer-like display.  The control does not allow the user to modify the
value.  WMAddStatusBar is useful for creating a control that will display the
progress of an operation which takes a substantial amount of time.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddStatusBar(const char* label, int width, int maxval, int* ivar, int update, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddStatusBar(label, width, maxval, ivar, update, group)</CODE>
<BR><CODE>character*(*) label</CODE>
<BR><CODE>integer width, maxval, ivar, update, group</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>label</VAR><DD>(in) Is the label drawn beneath the control.  If
    WMAddStatusBar is called from C, label may be zero and no label will be
    displayed.  If you call WMAddStatusBar from Fortran and want to be
    compatible with IVE 3.3 or versions of IVE 4 earlier than 4.2.0,
    <VAR>label</VAR> must include a null character (i.e. char(0)) to mark the
    end of the label.
  <DT><VAR>width</VAR><DD>(in) Is the length, in pixels, of the thermometer.
    If <VAR>width</VAR> is zero, the thermometer is attached to the right side
    of the dialog.
  <DT><VAR>maxval</VAR><DD>(in) Is the maximum allowed value for the integer
    referenced by <VAR>ivar</VAR>.  <VAR>maxval</VAR> must be greater than
    zero.
  <DT><VAR>ivar</VAR><DD>(in/out) Holds the value representing the current
    value for the thermometer.  Must be greater than or equal to zero and
    less than or equal to <VAR>maxval</VAR>.
  <DT><VAR>update</VAR><DD>(in) If <VAR>update</VAR> is nonzero and the
    value referenced by <VAR>ivar</VAR> changes as the result of the user
    pressing a Restore button created by
    <A HREF="#WMAddSaveButton">WMAddSaveButton</A>, the WM library will
    call <A HREF="#WMUpdateGroup">WMUpdateGroup</A> with the value
    of <VAR>group</VAR> as the argument.  If <VAR>update</VAR> is zero, the
    WM library will not call <A HREF="#WMUpdateGroup">WMUpdateGroup</A>
    internally the user presses a Restore button.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the control will belong.
</DL>
<H4>Return Value</H4>
<P>Returns the identification value for the created control.

<HR>
<H3><A NAME="WMAddText">WMAddText</A></H3>
<H4>Overview</H4>
<P>Adds an output-only control that displays a single line of text.  The
control does not allow the user to change the text.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddText(char* text, int maxlen, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddText(text, maxlen, group)</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>text</VAR><DD>(in/out) Is the storage for the text displayed in the
    field.  If WMAddText is called from C or C++, <VAR>text</VAR> should
    be a null-terminated string.  If WMAddCharField is called from Fortran,
    <VAR>text</VAR> should be a character array, and if you want to be
    compatible with IVE 3.3 or versions of IVE 4 earlier than 4.2.0,
    <VAR>text</VAR> must include a null character (i.e. char(0)) to
    mark the end of the text.
  <DT><VAR>maxlen</VAR><DD>(in) Is the maximum number of characters to
    display.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the control will belong.
</DL>
<H4>Return Value</H4>
<P>Returns the identification value for the created control.

<HR>
<H3><A NAME="WMAddToggleButton">WMAddToggleButton</A></H3>
<H4>Overview</H4>
<P>Adds a control which allows the user to set a variable that has two possible
values, on or off.  The control's appearance depends on the system used.
On Linux and OS X the control looks like a button.  The button sticks out when
the value is off and is pressed in when the value is on.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMAddToggleButton(const char* label, int* ivar, int (*callback)(), int* params, int update, int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddToggleButton(label, ivar, callback, params, update, group)</CODE>
<BR><CODE>character*(*) label</CODE>
<BR><CODE>integer ivar, callback, params, update, group</CODE>
<BR><CODE>external callback</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>label</VAR><DD>(in) Is the label to display next to the button.
    If you call WMAddToggleButton from Fortran and want to be compatible with
    IVE 3.3 or versions of IVE 4 earlier than 4.2.0, <VAR>label</VAR> must
    contain a null character (i.e. char(0)) to mark the end of the label.
  <DT><VAR>ivar</VAR><DD>(in/out) Holds the value that affects the state of
    the button.  If the value referred to by <VAR>ivar</VAR> is nonzero,
    the button will be on; if the value referred to by <VAR>ivar</VAR>
    is zero, the button will be off.
  <DT><VAR>callback</VAR><DD>(in) When the user presses the button, the WM
    library will update the value referenced by <VAR>ivar</VAR> and call
    <VAR>callback</VAR>.  The WM library will pass <VAR>callback</VAR> a
    single argument, the value of <VAR>params</VAR> (i.e. a pointer to an
    integer in C and a reference to an integer in Fortran), and
    expects <VAR>callback</VAR> to return an integer value (the particular
    value returned, however, has no effect on the behavior of the WM library).
    When WMAddToggleButton is called from C, <VAR>callback</VAR> may zero to
    signal that no callback should be performed by the WM library when the
    user presses the button.
  <DT><VAR>params</VAR><DD>(in) Is passed as the argument to
    <VAR>callback</VAR>.
  <DT><VAR>update</VAR><DD>(in) If <VAR>update</VAR> is nonzero and the user
    presses the button, the WM library will call
    <A HREF="#WMUpdateGroup">WMUpdateGroup</A> with the value of
    <VAR>group</VAR> as the argument.  If <VAR>update</VAR> is zero, the
    WM library will not call <A HREF="#WMUpdateGroup">WMUpdateGroup</A>
    internally when the button is pressed.
  <DT><VAR>group</VAR><DD>(in) Is a bit mask for the group or groups to which
    the field will belong.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the created button.

<HR>
<H2>Widget Modification Functions</H2>

<H3><A NAME="WMDisableField">WMDisableField</A></H3>
<H4>Overview</H4>
<P>Disables a control so that it does not respond to user input until a
subsequent call to <A HREF="#WMEnableField">WMEnableField</A> or
<A HREF="#WMEnableGroup">WMEnableGroup</A> reenables the control.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMDisableField(Widget w);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMDisableField(w)</CODE>
<BR><CODE>integer w</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>w</VAR><DD>(in) Is the identification value for the control to
    disable.  The WM library function used to create the control returns the
    identification value for the control.
</DL>
<H4>Return Value</H4>
<P>Returns zero.

<HR>
<H3><A NAME="WMEnableField">WMEnableField</A></H3>
<H4>Overview</H4>
<P>Enables a control to receive user input if the control had previously been
disabled.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMEnableField(Widget w);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMEnableField(w)</CODE>
<BR><CODE>integer w</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>w</VAR><DD>(in) Is the identification value for the control to
    enable.  The WM library function used to create the control returns the
    identification value for the control.
</DL>
<H4>Return Value</H4>
<P>Returns zero.

<HR>
<H3><A NAME="WMDisableGroup">WMDisableGroup</A></H3>
<H4>Overview</H4>
<P>Disables from receiving user input all controls whose group number has a
bit on that is also on in the mask, <VAR>group</VAR>, passed as the argument
to WMDisableGroup.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>void WMDisableGroup(int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMDisableGroup(group)</CODE>
<BR><CODE>integer group</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>group</VAR><DD>(in) Is the bit mask for the groups of controls to
    disable.
</DL>
<H4>Return Value</H4>
<P>The C interface does not return a value; the Fortran interface returns zero.

<HR>
<H3><A NAME="WMEnableGroup">WMEnableGroup</A></H3>
<H4>Overview</H4>
<P>Enables previously disable controls whose group number has a bit on that
is also on in the mask, <VAR>group</VAR>, passed as the argument to
WMEnableGroup.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>void WMEnableGroup(int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMEnableGroup(group)</CODE>
<BR><CODE>integer group</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>group</VAR><DD>(in) Is the bit mask for the groups of controls to
    enable.
</DL>
<H4>Return Value</H4>
<P>The C interface does not return a value; the Fortran interface returns zero.

<HR>
<H3><A NAME="WMUnpasteWidget">WMUnpasteWidget</A></H3>
<H4>Overview</H4>
<P>Hides a control from view.  The control may continue to take up space
in the dialog even though the control is not visible.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMUnpasteWidget(Widget w);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMUnpasteWidget(w)</CODE>
<BR><CODE>integer w</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>w</VAR><DD>(in) Is the identification value for the control to
    hide.  The WM library function used to create the control returns the
    identification value for the control.
</DL>
<H4>Return Value</H4>
<P>Returns negative one if <VAR>w</VAR> is zero or is known to be invalid;
otherwise, returns zero.

<HR>
<H3><A NAME="WMPasteWidget">WMPasteWidget</A></H3>
<H4>Overview</H4>
<P>Makes a control visible if it was previously hidden from view.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMPasteWidget(Widget w);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMPasteWidget(w)</CODE>
<BR><CODE>integer w</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>w</VAR><DD>(in) Is the identification value for the control to
    display.  The WM library function used to create the control returns the
    identification value for the control.
</DL>
<H4>Return Value</H4>
<P>Returns negative one if <VAR>w</VAR> is zero or is known to be invalid;
otherwise, returns zero.

<HR>
<H3><A NAME="WMInsensitiveGroup">WMInsensitiveGroup</A></H3>
<H4>Overview</H4>
<P>Except for the return value, WMInsensitiveGroup functions identically to
<A HREF="#WMDisableGroup">WMDisableGroup</A>.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMInsensitiveGroup(int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMInsensitiveGroup(group)</CODE>
<BR><CODE>integer group</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>group</VAR><DD>(in) Is the bit mask for the groups of controls to
    disable.
</DL>
<H4>Return Value</H4>
<P>Returns zero.

<HR>
<H3><A NAME="WMSensitiveGroup">WMSensitiveGroup</A></H3>
<H4>Overview</H4>
<P>Except for the return value, WMSensitiveGroup functions identically to
<A HREF="#WMEnableGroup">WMEnableGroup</A>.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMSensitiveGroup(int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMSensitiveGroup(group)</CODE>
<BR><CODE>integer group</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>group</VAR><DD>(in) Is the bit mask for the groups of controls to
    enable.
</DL>
<H4>Return Value</H4>
<P>Returns zero.

<HR>
<H3><A NAME="WMUpdateGroup">WMUpdateGroup</A></H3>
<H4>Overview</H4>
<P>For all controls whose group number has a bit on that is also on in the mask
<VAR>group</VAR> passed as the argument to WMUpdateGroup, updates the user
interface of the control to match the value or values the control represents.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMUpdateGroup(int group);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMUpdateGroup(group)</CODE>
<BR><CODE>integer group</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>group</VAR><DD>(in) Is the bit mask for the groups of controls to
    update.
</DL>
<H4>Return Value</H4>
<P>Returns zero.

<HR>
<H3><A NAME="WMUpdateField">WMUpdateField</A></H3>
<H4>Overview</H4>
<P>Updates the user interface of a control to match the value or values the
control represents.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMUpdateField(Widget w);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMUpdateField(w)</CODE>
<BR><CODE>integer w</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>w</VAR><DD>(in) Is the identification value for the control to
    update.  The WM library function used to create the control returns the
    identification value for the control.
</DL>
<H4>Return Value</H4>
<P>Returns negative one if <VAR>w</VAR> is zero or is known to be invalid;
otherwise, returns zero.

<HR>
<H3><A NAME="WMChangePulldown">WMChangePulldown</A></H3>
<H4>Overview</H4>
<P>Changes the entries in a menu created by
<A HREF="#WMAddNestedPulldown">WMAddNestedPulldown</A>,
<A HREF="#WMAddOptionMenu">WMAddOptionMenu</A>,
<A HREF="#WMAddPulldown">WMAddPulldown</A>,
<A HREF="#WMAddPulldownMenu">WMAddPulldownMenu</A>, or
<A HREF="#WMAddPullRight">WMAddPullRight</A>.  Can change the label for an
entry and whether or not an entry is sensitive to user input.  For menus
created by <A HREF="#WMAddPulldown">WMAddPulldown</A>, can change a normal
menu entry to a horizontal separator or vice versa.  For menus created by
<A HREF="#WMAddNestedPulldown">WMAddNestedPulldown</A>,
<A HREF="#WMAddPulldownMenu">WMAddPulldownMenu</A>, or
<A HREF="#WMAddPullRight">WMAddPullRight</A>, can change the type of the entry
to any of the three supported types (simple entry, entry that leads to another
menu, or horizontal separator).  Versions of the WM library prior to IVE 4.2.0
will ignore requests to change the type of a menu entry.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMChangePulldown(Widget w, const char* const* new_labels, const int sens_list[], int nlabel);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMChangePulldown(w, new_labels, sens_list, nlabel)</CODE>
<BR><CODE>character*(*) new_labels</CODE>
<BR><CODE>integer w, nlabel, sens_list(nlabel)</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>w</VAR><DD>(in) Is the identification value for the menu to change.
  <DT><VAR>new_labels</VAR><DD>(in) In C, <VAR>new_labels</VAR> is an array of
    <VAR>nlabel</VAR> null-terminated strings where the ith element is used
    as the label for the ith entry in the menu (unless the ith entry is a
    separator; then the ith element of <VAR>new_labels</VAR> is ignored).  In
    Fortran, <VAR>new_labels</VAR> is a character array containing the menu
    labels separated by tildes (for instance, you could use 
    'New~Open~Save~~Quit~' for a menu with five entries where the fourth entry
    is a separator).
  <DT><VAR>sens_list</VAR><DD>(in) Is an integer array with <VAR>nlabel</VAR>
    elements.  The ith element of <VAR>itemTypes</VAR> sets the format for
    the ith entry in the menu.  Allowed options for the ith element of
    <VAR>sens_list</VAR> are:
    <DL>
      <DT>0<DD>The ith entry is a normal menu entry (it does not lead to
        another menu and is not a separator) which is insensitive to user
        input.  The label for the entry is the ith part of
        <VAR>new_labels</VAR>
      <DT>1<DD>The ith entry is a normal menu entry which is sensitive to
        user input.  The label for the entry is the ith part of
        <VAR>new_labels</VAR>.
      <DT>2<DD>The ith entry is a menu entry that leads to another menu
        and is insensitive to user input.  The label for the entry is the ith
        part of <VAR>new_labels</VAR>.
      <DT>3<DD>The ith entry is a menu entry that leads to another menu
        and is sensitive to user input.  The label for the entry is the ith
        part of <VAR>new_labels</VAR>
      <DT>4 or 5<DD>The ith entry is a horizontal separator.  The ith part
        of <VAR>new_labels</VAR> is ignored.
    </DL>
  <DT><VAR>nlabel</VAR><DD>(in) Is the number of entries to appear in the
    updated menu.
</DL>
<H4>Return Value</H4>
<P>Return negative one if <VAR>w</VAR> is zero, <VAR>w</VAR> is not
a menu, or if <VAR>new_labels</VAR> is zero.  Otherwise, returns one.
<H4>Side Effects</H4>
<UL>
  <LI>If the menu was created by <A HREF="#WMAddPulldown">WMAddPulldown</A>
    when the option to show the current choice was enabled or was created by
    <A HREF="#WMAddOptionMenu">WMAddOptionMenu</A>, calling WMChangePulldown
    will have the effect of also calling
    <A HREF="#WMUpdateField">WMUpdateField</A> on the menu.
  <LI>If the menu contains entries leading to other menus which are deleted
    by the change or replaced by entries of a different type, any child menus
    and their descendants of the deleted entries are deleted and further
    references to them by the application will lead to undefined behavior.
</UL>

<HR>
<H3><A NAME="WMChangeScrolledChoicesSelection">WMChangeScrolledChoicesSelection (WMChangeScrolledChoicesSelect in Fortran)</A></H3>
<H4>Overview</H4>
<P>Changes the currently selected item in a control created by
<A HREF="#WMAddScrolledChoices">WMAddScrolledChoices</A>; does not cause the
update callback to be invoked.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMChangeScrolledChoicesSelection(Widget w, int new_selection);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMChangeScrolledChoicesSelect(w, new_selection)</CODE>
<BR><CODE>integer w, new_selection</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>w</VAR><DD>(in) Is the identification value for the control to
    modify (i.e. the value returned by
    <A HREF="#WMAddScrolledChoices">WMAddScrolledChoices</A>).
  <DT><VAR>new_selection</VAR><DD>(in) Is the zero-based index of the item
    which will be displayed as the current selection.  If
    <VAR>new_selection</VAR> is less than zero or greater than or equal to
    the number of items in the list, no item will be shown as the current
    selection.
</DL>
<H4>Return Value</H4>
<P>Returns one.

<HR>
<H3><A NAME="WMChangeText">WMChangeText</A></H3>
<H4>Overview</H4>
<P>Changes the label on a previously created control.  Works on the
controls created by <A HREF="#WMAddGetFile">WMAddGetFile</A>,
<A HREF="#WMAddInfoButton">WMAddInfoButton</A>,
<A HREF="#WMAddOnOffStatus">WMAddOnOffStatus</A>,
and <A HREF="#WMAddToggleButton">WMAddToggleButton</A> and will change the
menu name for menus created with <A HREF="#WMAddPulldown">WMAddPulldown</A>,
<A HREF="#WMAddPulldownMenu">WMAddPulldownMenu</A>, or
<A HREF="#WMAddNestedPulldown">WMAddNestedPulldown</A>.  It will also
work on buttons created by <A HREF="#WMAddFuncButton">WMAddFuncButton</A>,
but in that case you have an alternative mechanism:  modify the label
originally passed to <A HREF="#WMAddFuncButton">WMAddFuncButton</A> and then
call <A HREF="#WMUpdateField">WMUpdateField</A> or
<A HREF="#WMUpdateGroup">WMUpdateGroup</A> to redraw the button's label
(if your application uses <A HREF="#WMAddSaveButton">WMAddSaveButton</A>
these two methods are not strictly equivalent:  calling WMChangeText will
not affect the program state that is saved when the save button is pressed;
changing the original label and then updating the button will change the
state saved when the save button is pressed).  To change the labels on
controls created with <A HREF="#WMAddHorSlider">WMAddHorSlider</A> or
<A HREF="#WMAddStatusBar">WMAddStatusBar</A>, use
<A HREF="#WMChangeTitle">WMChangeTitle</A>.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMChangeText(Widget w, const char* new_string);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMChangeText(w, new_string)</CODE>
<BR><CODE>integer w</CODE>
<BR><CODE>character*(*) new_string</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>w</VAR><DD>(in) Is the identification value for the control to
    modify.  The WM library function used to create the control returns the
    identification value for the control.
  <DT><VAR>new_string</VAR><DD>(in) Is the new label for the control.  If
    you call WMChangeText from Fortran and you want to be compatible with
    IVE 3.3 or versions of IVE 4 earlier than 4.2.0, <VAR>label</VAR> must
    include a null character (i.e. char(0)) to mark the end of the label.
</DL>
<H4>Return Value</H4>
<P>Return negative one if <VAR>new_string</VAR> is zero, <VAR>w</VAR> is zero,
or if called from Fortran and <VAR>w</VAR> does not match a known control
Otherwise, returns one.

<HR>
<H3><A NAME="WMChangeTitle">WMChangeTitle</A></H3>
<H4>Overview</H4>
<P>Changes the label on a control created previously with
<A HREF="#WMAddHorSlider">WMAddHorSlider</A> or
<A HREF="#WMAddStatusBar">WMAddStatusBar</A>.  To change the labels on other
controls, use <A HREF="#WMChangeText">WMChangeText</A>.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMChangeTitle(Widget w, const char* new_string);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMChangeTitle(w, new_string)</CODE>
<BR><CODE>integer w</CODE>
<BR><CODE>character*(*) new_string</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>w</VAR><DD>(in) Is the identification value for the control to
    modify.  The WM library function used to create the control returns the
    identification value for the control.
  <DT><VAR>new_string</VAR><DD>(in) Is the new label for the control.  If
    you call WMChangeText from Fortran and you want to be compatible with
    IVE 3.3 or versions of IVE 4 earlier than 4.2.0, <VAR>label</VAR> must
    include a null character (i.e. char(0)) to mark the end of the label.
</DL>
<H4>Return Value</H4>
<P>Return negative one if <VAR>new_string</VAR> is zero, <VAR>w</VAR> is zero,
or if called from Fortran and <VAR>w</VAR> does not match a known control;
otherwise, return one.

<HR>
<H3><A NAME="WMForceUpdate">WMForceUpdate</A></H3>
<H4>Overview</H4>
<P>In the case where you wish to pop up a dialog and immediately draw to
it, you can call WMForceUpdate after popping up the dialog.  WMForceUpdate
will return immediately if the dialog containing WMForceUpdate's argument
has not been realized (i.e. it is ready for mapping to the screen); otherwise,
WMForceUpdate will wait until the dialog is mapped to the screen and ready
for drawing.  Since <A HREF="#WMDisplay">WMDisplay</A> and
<A HREF="#WMDisplaySubMenu">WMDisplaySubMenu</A> implicitly call WMForceUpdate,
the only situation where you might use WMForceUpdate is if you create your
own dialogs directly with the Xt toolkit.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>void WMForceUpdate(Widget w);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>subroutine WMForceUpdate(w)</CODE>
<BR><CODE>integer w</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>w</VAR><DD>(in) WMForceUpdate returns immediately if the first
    Shell widget ancestor and first TopLevelShell widget ancestor of
    <VAR>w</VAR> have not been realized; otherwise, it will wait, processing
    events, until those shells are visible.
</DL>

<HR>
<H3><A NAME="WMInsertWidget">WMInsertWidget</A></H3>
<H4>Overview</H4>
<P>By default, the WMAdd* routines add controls to the bottom of the
dialog created by the latest of the calls to
<A HREF="#WMInit">WMInit</A> or <A HREF="#WMInitSubMenu">WMInitSubMenu</A>.
Use WMInsertWidget to change where WMAdd* routines insert controls.  That
change lasts until you call <A HREF="#WMEndInsert">WMEndInsert</A> directly
or until you call WMInsertWidget, <A HREF="#WMInitSubMenu">WMInitSubMenu</A>,
or <A HREF="#WMDeleteWidget">WMDeleteWidget</A> which will implicitly call
<A HREF="#WMEndInsert">WMEndInsert</A> with an argument of one.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMInsertWidget(Widget w, int method);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMInsertWidget(w, method)</CODE>
<BR><CODE>integer w, method</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>w</VAR><DD>(in) Is the identification value for the existing
    control that will serve as the reference point for the inserted controls.
    <VAR>method</VAR> controls the relationship between the inserted controls
    and the reference point.  The WM library function used to create the
    control returns the identification value for the control.
  <DT><VAR>method</VAR><DD>(in) Specifies the relationship between the
    inserted controls and the existing control <VAR>w</VAR>.  Allowed
    values for <VAR>method</VAR> are:
    <DL>
      <DT>0<DD>The insertion point for new controls starts out immediately
        to the right of <VAR>w</VAR>; it will then shift to the right and
        then downwards as controls are inserted or
        <A HREF="#WMNewRow">WMNewRow</A> is called.
      <DT>1<DD>The insertion point for new controls starts out at the left
        edge of the line below <VAR>w</VAR>;  it will then shift to the right
        and then downwards as controls are inserted or
        <A HREF="#WMNewRow">WMNewRow</A> is called.  If <VAR>w</VAR> is not at
        the end of its line, the remaining controls on the line will
        appear immediately to the right of the last control added
        in the sequence of insertions initiated by this call to WMInsertWidget.
      <DT>2<DD>The insertion point for new controls starts out at the left
        edge of the line below <VAR>w</VAR>; it will then shift to the right
        and then downwards as controls are inserted or
        <A HREF="#WMNewRow">WMNewRow</A> is called.  If <VAR>w</VAR> is not at
        the end of its line, the remaining controls on the line will
        appear on the line immediately below the last control added
        in the sequence of insertions initiated by this call to WMInsertWidget.
    </DL>
</DL>
<H4>Return Value</H4>
<P>Returns negative one in case of failure (an invalid value for <VAR>w</VAR>
or insufficient memory to proceed).  Returns one if successful.

<HR>
<H3><A NAME="WMEndInsert">WMEndInsert</A></H3>
<H4>Overview</H4>
<P>Terminates the additions to a dialog started by
<A HREF="#WMInsertWidget">WMInsertWidget</A> and sets the insertion point
for new controls to its default location, the end of the dialog created by
the latest of the calls to <A HREF="#WMInit">WMInit</A> or
<A HREF="#WMInitSubMenu">WMInitSubMenu</A>.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMEndInsert(int resize_flag);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMEndInsert(resize_flag)</CODE>
<BR><CODE>integer resize_flag</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>resize_flag</VAR><DD>(in) If <VAR>resize_flag</VAR> is not zero,
    then WMEndInsert will resize the dialog to fit the controls the dialog now
    contains; otherwise, WMEndInsert will not resize the dialog.
</DL>
<H4>Return Value</H4>
<P>Returns one.

<HR>
<H3><A NAME="WMDeleteWidget">WMDeleteWidget</A></H3>
<H4>Overview</H4>
<P>Removes a control previously added by a call to one of the WMAdd* routines.
To fill the empty space formerly occupied by the control, moves the remaining
controls but does not disturb how they are organized into lines.  If an
insertion initiated with <A HREF="#WMInsertWidget">WMInsertWidget</A> is still
active, the call to WMDeleteWidget implicitly terminates the insertion as if
you had explicitly called <A HREF="#WMEndInsert">WMEndInsert</A> with an
argument of one.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMDeleteWidget(Widget w, int resize_flag);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMDeleteWidget(w, resize_flag)</CODE>
<BR><CODE>integer w, resize_flag</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>w</VAR><DD>(in) Is the identification value for the control
    to remove.  The WM library function used to create the control returns
    the identification value for the control.
  <DT><VAR>resize_flag</VAR><DD>(in) If <VAR>resize_flag</VAR> is not zero,
    WMDeleteWidget will resize the dialog that contained the control to fit
    the controls it still has.  Otherwise, WMDeleteWidget will not resize
    the dialog.
</DL>
<H4>Return Value</H4>
<P>Returns negative one if <VAR>w</VAR> is zero or is known to be invalid;
otherwise, returns zero.

<HR>
<H2>Widget Positioning Functions</H2>

<H3><A NAME="WMAttachRightSide">WMAttachRightSide</A></H3>
<H4>Overview</H4>
<P>Attaches the last control created via a WMAdd* routine to the right
side of the dialog.  When the dialog is first shown that control will be
the wider of its natural width or the width needed to extend the control
to the right side of the dialog.  If the users changes the width of the
dialog, the control will grow or shrink to fit.
<P>After calling WMAttachRightSide, you'll have to call
<A HREF="#WMNewRow">WMNewRow</A> before adding subsequent controls to the same
dialog.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>void WMAttachRightSide();</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>subroutine WMAttachRightSide()</CODE>

<HR>
<H3><A NAME="WMNewRow">WMNewRow</A></H3>
<H4>Overview</H4>
<P>After calling WMNewRow, the next call to a WMAdd* routine (unless
<A HREF="#WMInsertWidget">WMInsertWidget</A> is called first and is not
matched with a subsequent <A HREF="#WMEndInsert">WMEndInsert</A>), will place
the new control at the left side of the dialog.  The offsets between the new
control and the left side of the dialog and the first control in the previous
row of controls can be set by a call to <A HREF="#WMSetOffset">WMSetOffset</A>
before adding the control.
<A HREF="#WMAddFuncList">WMAddFuncList</A> (if the specified width
is less than or equal to zero),
<A HREF="#WMAddScrolledChoices">WMAddScrolledChoices</A>,
<A HREF="#WMAddScrolledText">WMAddScrolledText</A>, and
<A HREF="#WMAddSeparator">WMAddSeparator</A> put the controls they
create on their own line in the dialog and are not affected by the presence
or absence of calls to WMNewRow.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMNewRow(void);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMNewRow()</CODE>
<H4>Return Value</H4>
<P>Returns the identification value for the first widget in the row just
completed.

<HR>
<H3><A NAME="WMSetOffset">WMSetOffset</A></H3>
<H4>Overview</H4>
<P>Sets the spacing for controls created by subsequent calls to WMAdd*
routines.  If WMSetOffset has not been called, WMAdd* calls will function
as if WMSetOffset had been called with all four arguments set to zero.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMSetOffset(int left, int right, int top, int bottom);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMSetOffset(left, right, top, bottom)</CODE>
<BR><CODE>integer left, right, top, bottom</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>left</VAR><DD>(in) After the call to WMSetOffset, the left edge
    of a newly added control will be <VAR>left</VAR> pixels from either the
    right edge of the neighbor to the left or, if the new control is first in
    the row, the inside left edge of the dialog.  If <VAR>left</VAR> is less
    than zero, the call to WMSetOffset has no effect.
  <DT><VAR>right</VAR><DD>(in) After the call to WMSetOffset, a newly added
    control whose right side is anchored (by calling
    <A HREF="#WMAttachRightSide">WMAttachRightSide</A>) will have its right
    side placed at <VAR>right</VAR> pixels to the left of the right edge
    of the anchor.  If <VAR>right</VAR> is less than zero, the call to
    WMSetOffset has no effect.
  <DT><VAR>top</VAR><DD>(in) After the call to WMSetOffset, the top edge
    of a newly added control will be <VAR>top</VAR> pixels from either the
    bottom edge of the first control in the previous row or, if the new control
    is in the first row, the inside top edge of the dialog.  If
    <VAR>top</VAR> is less than zero, the call to WMSetOffset has no effect.
  <DT><VAR>bottom</VAR><DD>(in) After the call to WMSetOffset, a newly added
    control whose bottom side is anchored (the WM library does not
    provide a function to do this; it could be done with XtSetValues) will
    will have its bottom side placed at <VAR>bottom</VAR> pixels above the
    top edge of the anchor.  If <VAR>bottom</VAR> is less than zero, the call
    to WMSetOffset has no effect.
</DL>
<H4>Return Value</H4>
<P>Returns zero.

<HR>
<H2>Menu Display Functions</H2>

<H3><A NAME="WMDisplay">WMDisplay</A></H3>
<H4>Overview</H4>
<P>WMDisplay displays a dialog created by <A HREF="#WMInit">WMInit</A>
and pushes it to the top of the visible windows.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMDisplay(void);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMDisplay()</CODE>
<H4>Return Value</H4>
<P>Returns zero.

<HR>
<H3><A NAME="WMDisplaySubMenu">WMDisplaySubMenu</A></H3>
<H4>Overview</H4>
<P>WMDisplaySubMenu displays a dialog created by
<A HREF="#WMInitSubMenu">WMInitSubMenu</A> or <A HREF="#WMInit">WMInit</A>
and pushes the dialog to the top of the visible windows.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMDisplaySubMenu(int w);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMDisplaySubMenu(w)</CODE>
<BR><CODE>integer w</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>w</VAR><DD>(in) Is the index for the dialog to display.  The
    dialog created by <A HREF="#WMInit">WMInit</A> has an index of zero.
    The index for a dialog created with
    <A HREF="#WMInitSubMenu">WMInitSubMenu</A> is returned by
    <A HREF="#WMInitSubMenu">WMInitSubMenu</A>.
</DL>
<H4>Return Value</H4>
<P>Returns zero.

<HR>
<H3><A NAME="WMUndisplaySubMenu">WMUndisplaySubMenu</A></H3>
<H4>Overview</H4>
<P>Hides a dialog created by <A HREF="#WMInitSubMenu">WMInitSubMenu</A> or
<A HREF="#WMInit">WMInit</A>.  To make the dialog visible again,
call <A HREF="#WMDisplaySubMenu">WMDisplaySubMenu</A> or,
for the dialog created by <A HREF="#WMInit">WMInit</A>,
<A HREF="#WMDisplay">WMDisplay</A>.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMUndisplaySubMenu(int w);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMUndisplaySubMenu(w)</CODE>
<BR><CODE>integer w</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>w</VAR><DD>(in) Is the index for the dialog to hide.  The dialog
    created by <A HREF="#WMInit">WMInit</A> has an index of zero.  The
    index for a dialog created with <A HREF="#WMInitSubMenu">WMInitSubMenu</A>
    is returned by <A HREF="#WMInitSubMenu">WMInitSubMenu</A>.
</DL>
<H4>Return Value</H4>
<P>Returns zero.

<HR>
<H2>Event Processing Functions</H2>

<H3><A NAME="WMAppMainLoop">WMAppMainLoop</A></H3>
<H4>Overview</H4>
<P>Enters an endless loop which waits for events from the user interface
and processes them.  You normally call this function after you have initialized
your application, created the main dialog, and displayed the main dialog
with <A HREF="#WMDisplay">WMDisplay</A>.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMAppMainLoop(void);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAppMainLoop()</CODE>

<HR>
<H3><A NAME="WMProcEvent">WMProcEvent</A></H3>
<H4>Overview</H4>
<P>WMProcEvent will process all pending user interface events with the option
to wait until at least one event is processed.  WMProcEvent allows for
more flexible event processing then <A HREF="#WMAppMainLoop">WMAppMainLoop</A>.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMProcEvent(int wait);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMProcEvent(wait)</CODE>
<BR><CODE>integer wait</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>wait</VAR><DD>(in) If <VAR>wait</VAR> is not zero, WMProcEvent
    will process at least one user interface event, and if no events are
    currently pending, WMProcEvent could wait for an indefinite period
    of time before returning.  If <VAR>wait</VAR> is zero, WMProcEvent
    will process all pending user interface events and then return.
</DL>
<H4>Return Value</H4>
<P>Returns the number of events processed directly by the call to WMProcEvent
(nested event processing in callback functions could cause other events
to be processed which are not reflected in the return value).

<HR>
<H2>Error and Info Popup Functions</H2>

<H3><A NAME="WMConfirm">WMConfirm</A></H3>
<H4>Overview</H4>
<P>Displays a dialog with a message and two buttons labeled "Ok" and "Cancel"
and then does not return until the user selects one of the options or
dismisses the dialog.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMConfirm(const char* message);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMConfirm(message)</CODE>
<BR><CODE>character*(*) message</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>message</VAR><DD>(in) Holds the text of the message to display.
    To have the message displayed on multiple lines, embed a newline character
    in message where you would like a line break (support for multiple line
    messages was added in the October 1999 release).  If WMConfirm is called
    from Fortran and you want to be compatible with IVE 3.3 or versions of
    IVE 4 earlier than 4.2.0, <VAR>message</VAR> must include a null character
    (i.e. char(0)) to mark the end of the message.
</DL>
<H4>Return Value</H4>
<P>Returns one if the user selects ok; otherwise returns zero if the user
chooses to cancel or closes the dialog via the window manager.

<HR>
<H3><A NAME="WMRetLastButEvent">WMRetLastButEvent</A></H3>
<H4>Overview</H4>
<P>Returns a pointer to the X event structure for the last button press
on a button created by <A HREF="#WMAddArrowButton">WMAddArrowButton</A> or
<A HREF="#WMAddFuncButton">WMAddFuncButton</A>.  If all you need from the
event structure is the number of the mouse button involved, you can use
<A HREF="#WMGetLastButNum">WMGetLastButNum</A> instead.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>XEvent* WMRetLastButEvent(void);</CODE>
<H4>Fortran Prototype</H4>
<P><VAR>pointer_equivalent_integer</VAR> <CODE>function WMRetLastButEvent()</CODE>
<H4>Return Value</H4>
<P>Returns the address of an X event structure.

<HR>
<H3><A NAME="WMGetLastButNum">WMGetLastButNum</A></H3>
<H4>Overview</H4>
<P>Returns the number of the mouse button pressed from the last time the
user pressed a button created by
<A HREF="#WMAddArrowButton">WMAddArrowButton</A> or
<A HREF="#WMAddFuncButton">WMAddFuncButton</A>.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMGetLastButNum(void);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMGetLastButNum()</CODE>
<H4>Return Value</H4>
<P>Returns the mouse button number, an integer between one and five.

<HR>
<H3><A NAME="WMConfirmError">WMConfirmError</A></H3>
<H4>Overview</H4>
<P>Display an error message dialog and does not return until the user dismisses
the dialog.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMConfirmError(const char* message);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMConfirmError(message)</CODE>
<BR><CODE>character*(*) message</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>message</VAR><DD>(in) Holds the text of the message to display.
    To have the message displayed on multiple lines, embed a newline character
    in message where you would like a line break (support for multiple line
    messages was added in the October 1999 release).  If WMConfirmMessage is
    called from Fortran and you want to be compatible with IVE 3.3 or versions
    of IVE 4 earlier than 4.2.0, <VAR>message</VAR> must include a null
    character (i.e. char(0)) to mark the end of the message.
</DL>
<H4>Return Value</H4>
<P>Returns zero.

<HR>
<H3><A NAME="WMPostInfo">WMPostInfo</A></H3>
<H4>Overview</H4>
<P>Displays a message that, if not dismissed first, will disappear
automatically after a given amount of time has elapsed.  As currently
implemented, a call to WMPostInfo will have no effect while the message
from a previous call to WMPostInfo is visible.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMPostInfo(const char* message, int second);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMPostInfo(message, second)</CODE>
<BR><CODE>character*(*) message</CODE>
<BR><CODE>integer second</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>message</VAR><DD>(in) Holds the text of the message to display.
    To have the message displayed on multiple lines, embed a newline character
    in message where you would like a line break (support for multiple line
    messages was added in the October 1999 release).  If WMPostInfo is
    called from Fortran and you want to be compatible with IVE 3.3 or versions
    of IVE 4 earlier than 4.2.0, <VAR>message</VAR> must include a null
    character (i.e. char(0)) to mark the end of the message.
  <DT><VAR>second</VAR><DD>(in) Is the maximum number of seconds that the
    message will be visible.
</DL>
<H4>Return Value</H4>
<P>Returns zero.

<HR>
<H3><A NAME="WMShowInfo">WMShowInfo</A></H3>
<H4>Overview</H4>
<P>Displays a message that will remain visible until dismissed by the user
or until <A HREF="#WMRemoveInfo">WMRemoveInfo</A> is called.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>Widget WMShowInfo(const char* message);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMShowInfo(message)</CODE>
<BR><CODE>character*(*) message</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>message</VAR><DD>(in) Holds the text of the message to display.
    To have the message displayed on multiple lines, embed a newline character
    in message where you would like a line break (support for multiple line
    messages was added in the October 1999 release).  If WMShowInfo is
    called from Fortran and you want to be compatible with IVE 3.3 or versions
    of IVE 4 earlier than 4.2.0, <VAR>message</VAR> must include a null
    character (i.e. char(0)) to mark the end of the message.
</DL>
<H4>Return Value</H4>
<P>Returns an identification value for the message.  Use the returned value
as the argument to <A HREF="#WMRemoveInfo">WMRemoveInfo</A> when you want to
hide the message.

<HR>
<H3><A NAME="WMRemoveInfo">WMRemoveInfo</A></H3>
<H4>Overview</H4>
<P>Hides a message displayed by <A HREF="#WMShowInfo">WMShowInfo</A> and
releases the resources used to display the message.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMRemoveInfo(Widget w)</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMRemoveInfo(w)</CODE>
<BR><CODE>integer w</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>w</VAR><DD>(in) Is the identifier value, returned by
    <A HREF="#WMShowInfo">WMShowInfo</A>, for the message to hide.
</DL>
<H4>Return Value</H4>
<P>Returns one.

<HR>
<H3><A NAME="WMDisplayHelp">WMDisplayHelp</A></H3>
<H4>Overview</H4>
<P>Causes the help viewer to display a particular topic.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>void WMDisplayHelp(const char* keyword);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>subroutine WMDisplayHelp(keyword)</CODE>
<BR><CODE>character*(*) keyword)</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>keyword</VAR><DD>  Specifies the piece of documentation to
    display.  See the description of the <VAR>keyword</VAR> argument
    in the <A HREF="#WMAddInfoButton">WMAddInfoButton documentation</A> for
    more information on how <VAR>keyword</VAR> is interpreted.
</DL>

<HR>
<H3><A NAME="WMRingBell">WMRingBell</A></H3>
<H4>Overview</H4>
<P>Makes the computer beep.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>WMRingBell(int ivol, float len);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMRingBell(ivol, len)</CODE>
<BR><CODE>integer ivol</CODE>
<BR><CODE>real len</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>ivol</VAR><DD>(in) Sets the volume of the sound.  Allowed values
    range from -100 (no sound) to 100 (twice the base volume).  If
    <VAR>ivol</VAR> is zero, the volume is the base volume.  Values of
    <VAR>ivol</VAR> less than -100 are treated as -100, and values of
    <VAR>ival</VAR> greater than 100 are treated as 100.
  <DT><VAR>len</VAR><DD>(in) Sets the duration of the tone in seconds.
</DL>
<H4>Return Value</H4>
<P>Returns zero.

<HR>
<H2>File Selection Functions</H2>

<H3><A NAME="WMGetFile">WMGetFile</A></H3>
<H4>Overview</H4>
<P>Displays a file selection dialog and waits for the user to select a file
or dismiss the dialog.  The initial directory and pattern shown in the file
selection dialog are extracted from a database using the keys passed in the
last call <A HREF="#WMSetGetFileSrc">WMSetGetFileSrc</A>, and when the user
selects a file, WMGetFile copies the directory and filter at the time to the
database.

<P>To create a control that launches a file selection dialog, you could use
<A HREF="#WMAddGetFile">WMAddGetFile</A>, or call
<A HREF="#WMAddFuncButton">WMAddFuncButton</A> and then call WMGetFile from
the button's callback routine.  While selecting the file, the user can
interact with other user interface elements.  In the common case where
WMGetFile is called from the callback routine for a button added with
<A HREF="#WMAddFuncButton">WMAddFuncButton</A>, the user could press that
button again (or simply an errant double click in the initial interaction)
which would generate another file selection dialog.

<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMGetFile(char* filename, char* dir, char* pattern, char* filter);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMGetFile(filename, dir, pattern, filter)</CODE>
<BR><CODE>character*(*) filename, dir, pattern</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>filename</VAR><DD>(out) Is storage for the name of the file that
    the user selects.  If the user does not select a file, the contents of
    <VAR>filename</VAR> are not altered by WMGetFile.
  <DT><VAR>dir</VAR><DD>Present for backward compatibility with earlier
    versions of Priism.  <VAR>dir</VAR> is not accessed in any way in IVE 4.
  <DT><VAR>pattern</VAR><DD>Present for backward compatibility with earlier
    versions of Priism.  <VAR>pattern</VAR> is not accessed in any way in
    IVE 4.
  <DT><VAR>filter</VAR><DD>Present for backward compatibility with earlier
    versions of Priism.  <VAR>filter</VAR> is not accessed in any way in IVE 4.
</DL>
<H4>Return Value</H4>
<P>Returns a value greater than zero if the user selected file.  Other
return values indicate that the user dismissed the dialog without
selecting a file.

<HR>
<H3><A NAME="WMSetGetFileSrc">WMSetGetFileSrc</A></H3>
<H4>Overview</H4>
<P>Sets the database keys that are used to look up the initial directory and
file name filter when file selection dialogs are displayed (either directly
by <A HREF="#WMGetFile">WMGetFile</A> or indirectly by the user pressing the
button in a control added by <A HREF="#WMAddGetFile">WMAddGetFile</A>).
When the user completes a file selection, the directory and file name filter
associated with the keys are updated to match the settings in the file
selection dialog.  If WMSetGetFileSrc has not been
called by an application, the key used for the directory is "IVE_DEF_DIR:"
and the key used for the file name filter is "IVE_DEF_FILE_EXT:".  The
database is maintained as a text file called .ivestartup in the user's home
directory.  
<P>Common values used for the directory key and file name filter key are shown
below.  By convention, different directory keys are used for configuration
data, and the same directory key, "IVE_DEF_DIR:", is used for file types that
are the results of processing.
<TABLE BORDER>
<TR>
<TD>Data Type</TD>
<TD>Directory Key</TD>
<TD>File Name Filter Key</TD>
</TR>

<TR>
<TD>MRC image</TD>
<TD>"IVE_DEF_DIR:"</TD>
<TD>"IVE_DEF_FILE_EXT:"</TD>
</TR>

<TR>
<TD>TIFF image</TD>
<TD>"IVE_DEF_DIR:"</TD>
<TD>"TIFF_FILE_EXT:"</TD>
</TR>

<TR>
<TD>2D Plot file</TD>
<TD>"IVE_DEF_DIR:"</TD>
<TD>"PLOT_FILE_EXT:"</TD>
</TR>

<TR>
<TD>Polygons</TD>
<TD>"IVE_DEF_DIR:"</TD>
<TD>"POLY_FILE_EXT:"</TD>
</TR>

<TR>
<TD>Volume builder association list (old format)</TD>
<TD>"IVE_DEF_DIR:"</TD>
<TD>"BLD_FILE_EXT:"</TD>
</TR>

<TR>
<TD>Pick Points point list (old format)</TD>
<TD>"IVE_DEF_DIR"</TD>
<TD>"PICK_FILE_EXT:"</TD>
</TR>

<TR>
<TD>Model for 3D Model</TD>
<TD>"IVE_DEF_DIR:"</TD>
<TD>"MOD_FILE_EXT:"</TD>
</TR>

<TR>
<TD>Graphic colors description</TD>
<TD>"COLOR_DIR:"</TD>
<TD>"COLOR_FILE_EXT:"</TD>
</TR>

<TR>
<TD>BlendColors color description</TD>
<TD>"BLEND_DIR:"</TD>
<TD>"BLEND_FILE_EXT:"</TD>
</TR>

<TR>
<TD>PostScript output</TD>
<TD>"IVE_DEF_DIR:"</TD>
<TD>"PSFILE_EXT:"</TD>
</TR>
</TABLE>

<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>void WMSetGetFileSrc(const char* dirkey, const char* patkey);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>subroutine WMSetGetFileSrc(dirkey, patkey)</CODE>
<BR><CODE>character*(*) dirkey, patkey</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>dirkey</VAR><DD>(in) After the call to WMSetGetFileSrc, directory
    names will be looked up in the database using <VAR>dirkey</VAR> as the
    key.  If the database does not have an entry for <VAR>dirkey</VAR>, the
    user's home directory will be used initially until the user selects
    a file and the database is updated.
  <DT><VAR>patkey</VAR><DD>(in) After the call to WMSetGetFileSrc, file name
    filters will be looked up in the database using <VAR>patkey</VAR> as the
    key.  If the database does not have an entry for <VAR>patkey</VAR>, "*.dat"
    will be used initially until the user selects a file and the database is
    updated.
</DL>

<HR>
<H2>Monitor Event Handling Functions</H2>

<H3><A NAME="WMEnableIWLEvent">WMEnableIWLEvent</A></H3>
<H4>Overview</H4>
<P>Until WMEnableIWLEvent is called, the application ignores events from
image windows.  Once image window events are enabled, you can call
<A HREF="#WMDisableIWLEvent">WMDisableIWLEvent</A> to ignore those events
until WMEnableIWLEvent is called again.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>void WMEnableIWLEvent(void);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>subroutine WMEnableIWLEvent()</CODE>

<HR>
<H3><A NAME="WMDisableIWLEvent">WMDisableIWLEvent</A></H3>
<H4>Overview</H4>
<P>Causes the application to ignore events from image windows.  To restore
handling of events from image windows, call
<A HREF="#WMEnableIWLEvent">WMEnableIWLEvent</A>.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>void WMDisableIWLEvent(void);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>subroutine WMDisableIWLEvent()</CODE>

<HR>
<H3><A NAME="WMAddEventHandler">WMAddEventHandler</A></H3>
<H4>Overview</H4>
<P>Registers a routine to be called when the application receives an
event of a particular type from an image window and the application is
processing image window events (see
<A HREF="#WMEnableIWLEvent">WMEnableIWLEvent</A> for details).  If you no
longer want the WM library to call a routine in response to an image window
event, call <A HREF="#WMCancelEventHandler">WMCancelEventHandler</A>.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMAddEventHandler(int istream, long mask, int (*func)(), int argu);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>include 'WM.inc'</CODE>
<BR><CODE>integer function WMAddEventHandler(istream, mask, func, argu)</CODE>
<BR><CODE>integer istream, mask, func, argu</CODE>
<BR><CODE>external func</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>istream</VAR><DD>(in) If <VAR>istream</VAR> is an
    <A HREF="IM_ref2.html">IM library</A> stream number associated with an
    open image window (via either <A HREF="IM_ref2.html#IMOpen">IMOpen</A> or
    <A HREF="IW.html#IWAttachWin">IWAttachWin</A>), the routine
    registered will be called for events whose type matches one of the
    types in <VAR>mask</VAR> and which come from that image window.  If
    <VAR>istream</VAR> is less than zero, the routine registered will be
    called for events whose type matches one of the types in <VAR>mask</VAR>
    and which come from any image window.
  <DT><VAR>mask</VAR><DD>(in) Specifies the type or types of events that will
    cause the routine to be called.  <VAR>mask</VAR> may be a one or more of
    the constants listed below (for multiple constants, combine them with
    bitwise-or operators in C or with addition in Fortran).   WMInclude.h
    defines the constants for C, and WM.inc defines the constants for Fortran.
    <DL>
      <DT>ButtonPressMask<DD>Specifies the type of events generated when a
        mouse button is pressed while the mouse pointer is over the image
        portion of an image window.  By default, image windows do not pass
        along button press events from buttons other than button one of the
        mouse.  To receive button press events from the other buttons, the
        application must also call
        <A HREF="#WMRegMouseButton">WMRegMouseButton</A>.
      <DT>ButtonReleaseMask<DD>Specifies the type of events generated when a
        mouse button is released and the corresponding button press occurred
        in the image portion of an image window.  By default, image windows do
        not pass along button release events from buttons other than button
        one of the mouse.  To receive button release events from the other
        buttons, the application must also call
        <A HREF="#WMRegMouseButton">WMRegMouseButton</A>.
      <DT>EnterWindowMask<DD>Specifies the type of events generated when the
        mouse pointer enters the image portion of an image window.
      <DT>LeaveWindowMask<DD>Specifies the type of events generated when the
        mouse pointer leaves the image portion of an image window.
      <DT>PointerMotionMask<DD>Specifies the type of events generated when
        the mouse pointer moves within the image portion of an image window.
      <DT>KeyPressMask<DD>Specifies the type of events generated when a
        key on the keyboard is pressed and the image portion of an image
        window has input focus.
      <DT>KeyReleaseMask<DD>Specifies the type of events generated when a
        key on the keyboard is released and the image portion of an image
        window has input focus.  Some hardware generates key press events
        but does not generate the corresponding release events.
    </DL>
  <DT><VAR>func</VAR><DD>(in) Is the routine that the WM library will call
    when an event arrives that matches one of the types in <VAR>mask</VAR> and
    which comes from the window specified by <VAR>istream</VAR>.  When the
    WM library calls <VAR>func</VAR>, it will pass it two arguments.  The
    first is the value of <VAR>argu</VAR> (an integer if WMAddEventHandler
    is called from C or a reference to an integer if WMAddEventHandler is
    called from Fortran).  The second is the address of the XEvent structure
    for the event.  The WM library expects <VAR>func</VAR> to return an
    integer, but the particular value returned has no effect on the behavior
    of the library.  If <VAR>func</VAR> has already been registered for the
    same image window and one of the event types in <VAR>mask</VAR> and that
    registration was not subsequently canceled, the library will not
    reregister the function (i.e. call it twice when an event is received) for
    the same image window and the same event type.
  <DT><VAR>argu</VAR><DD>(in) The WM library will pass <VAR>argu</VAR> as the
    first argument when it calls the registered routine, <VAR>func</VAR>.
</DL>
<H4>Return Value</H4>
<P>Returns negative one if communication with the image window system could
not be established, if <VAR>istream</VAR> is zero or is positive but not
attached to an image window the application has open, or if a memory
allocation error occurred while attempting to register the routine as an
event handler.  Otherwise, returns one.

<HR>
<H3><A NAME="WMCancelEventHandler">WMCancelEventHandler</A></H3>
<H4>Overview</H4>
<P>Cancels the routines registered with
<A HREF="#WMAddEventHandler">WMAddEventHandler</A> for a set of event
types and either a particular image window or all image windows.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMCancelEventHandler(int istream, long mask);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>include 'WM.inc'</CODE>
<BR><CODE>integer function WMCancelEventHandler(istream, mask)</CODE>
<BR><CODE>integer istream, mask</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>istream</VAR><DD>(in) If <VAR>istream</VAR> is an
    <A HREF="IM_ref2.html">IM library</A> stream number associated with an
    open image window (via either <A HREF="IM_ref2.html#IMOpen">IMOpen</A> or
    <A HREF="IW.html#IWAttachWin">IWAttachWin</A>), WMCancelEventHandler
    will cancel all routines registered for that image window and one of the
    event types in <VAR>mask</VAR>.  If <VAR>istream</VAR> is less than zero,
    WMCancelEventHandler will cancel all routines, regardless of the source
    image window,  registered for an event type which matches one of the
    event types in <VAR>mask</VAR>.
  <DT><VAR>mask</VAR><DD>(in) Specifies the type or types of events that the
    application no longer wishes to handle for the image windows specified
    by <VAR>istream</VAR>.  <VAR>mask</VAR> may be a one or more of
    the constants listed below (for multiple constants, combine them with
    bitwise-or operators in C or with addition in Fortran).   WMInclude.h
    defines the constants for C, and WM.inc defines the constants for Fortran.
    <UL>
      <LI>ButtonPressMask
      <LI>ButtonReleaseMask
      <LI>EnterWindowMask
      <LI>LeaveWindowMask
      <LI>PointerMotionMask
      <LI>KeyPressMask
      <LI>KeyReleaseMask
    </UL>
</DL>
<H4>Return Value</H4>
<P>Returns negative one if communication with the image window system could
not be established, if no event handlers have ever been registered,
or if <VAR>istream</VAR> is zero or is positive but not attached to an image
window the application has open.  Otherwise, returns one.

<HR>
<H3><A NAME="WMProcDisplayChange">WMProcDisplayChange</A></H3>
<H4>Overview</H4>
<P>Registers a routine to be called when an image window's state changes
and the application is processing image window events (see
<A HREF="#WMEnableIWLEvent">WMEnableIWLEvent</A> for details).  Window state
that is monitored includes
<UL>
  <LI>whether or not images are displayed
  <LI>the currently displayed section
  <LI>the assignment of particular wavelengths to particular colors for
    image display
  <LI>the size and arrangement of the rectangular grid of images displayed
  <LI>the zoom factor for displayed images
  <LI>changes to whether or not images are displayed
  <LI>the position of the displayed image relative to the image window
    boundaries
  <LI>the image scaling for the currently displayed section
  <LI>how complex data values are displayed
  <LI>something overwrites the image window with a new data set or deletes
    the image window
</UL>
<P>If you no longer want the WM library to call a routine in response to an
image window change, call
<A HREF="#WMCancelEventHandler">WMCancelEventHandler</A>.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMProcDisplayChange(int istream, int (*func)(), int argu);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMProcDisplayChange(istream, func, argu)</CODE>
<BR><CODE>integer istream, func, argu</CODE>
<BR><CODE>external func</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>istream</VAR><DD>(in) If <VAR>istream</VAR> is an
    <A HREF="IM_ref2.html">IM library</A> stream number associated with an
    open image window (via either <A HREF="IM_ref2.html#IMOpen">IMOpen</A> or
    <A HREF="IW.html#IWAttachWin">IWAttachWin</A>), the routine
    registered will be called for changes to that image window.  If
    <VAR>istream</VAR> is less than zero, the routine registered will be
    called for changes to any image window.
  <DT><VAR>func</VAR><DD>(in) Is the routine that the WM library will call
    when the window specified by <VAR>istream</VAR> changes.  When the
    WM library calls <VAR>func</VAR>, it will pass it two arguments.  The
    first is the value of <VAR>argu</VAR> (an integer if WMAddEventHandler
    is called from C or a reference to an integer if WMAddEventHandler is
    called from Fortran).  If WMAddEventHandler was called from C, the second
    argument is the address of an XEvent structure describing the change.
    The IW_CM_WIN_ID (defined in IWInclude.h) element of the xclient.data.s
    field in the structure holds the window number of the window that changed
    and the IW_CM_CHANGE_OR_SYN (defined in IWInclude.h) element of the
    xclient.data.s field holds a constant that describes the type of change.
    Those constants currently are:
    <DL>
      <DT>IW_WIN_KILLED<DD>The image window was overwritten with a new data
        set or deleted.
      <DT>IW_BANK_DISPLAY_CHANGED<DD>A change not covered by IW_WIN_KILLED
        occurred.
    </DL>
    If WMAddEventHandler was called from Fortran, the second argument is
    an integer equal to either IW_WIN_KILLED or IW_BANK_DISPLAY_CHANGED
    which have the same meaning as in C.  Currently, no Fortran include file
    defines IW_WIN_KILLED or IW_BANK_DISPLAY_CHANGED:  Fortran applications
    will have to use their numeric equivalents, 681 for IW_WIN_KILLED and 690
    for IW_BANK_DISPLAY_CHANGED.  The WM library expects <VAR>func</VAR> to
    return an integer, but the particular value returned has no effect on the
    behavior of the library.  If <VAR>func</VAR> has already been registered
    for the same image window and that registration was not subsequently
    canceled, the library will not reregister the function (i.e. call it
    twice when a change notification is received) for the same image window.
  <DT><VAR>argu</VAR><DD>(in) The WM library will pass <VAR>argu</VAR> as the
    first argument when it calls the registered routine, <VAR>func</VAR>.
</DL>
<H4>Return Value</H4>
<P>Returns negative one if communication with the image window system could
not be established, if <VAR>istream</VAR> is zero or is positive but not
attached to an image window the application has open, or if a memory
allocation error occurred while attempting to register the routine as an
event handler.  Otherwise, returns one.

<HR>
<H3><A NAME="WMCancelDisplayChange">WMCancelDisplayChange</A></H3>
<H4>Overview</H4>
<P>Undoes the effect of a prior call or calls to
<A HREF="#WMProcDisplayChange">WMProcDisplayChange</A>.  WMCancelDisplayChange
either cancels all registered handlers for image window changes
or cancels the registered handler of image window changes for a particular
image window.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMCancelDisplayChange(int istream);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMCancelDisplayChange(istream)</CODE>
<BR><CODE>integer istream</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>istream</VAR><DD>(in) If <VAR>istream</VAR> is an
    <A HREF="IM_ref2.html">IM library</A> stream number associated with an
    open image window (via either <A HREF="IM_ref2.html#IMOpen">IMOpen</A> or
    <A HREF="IW.html#IWAttachWin">IWAttachWin</A>), WMCancelDisplayChange
    will remove the routine, if any, registered for that window with
    <A HREF="#WMProcDisplayChange">WMProcDisplayChange</A>.  If
    <VAR>istream</VAR> is less than zero, WMCancelDisplayChange will remove
    all the routines registered by
    <A HREF="#WMProcDisplayChange">WMProcDisplayChange</A>.
</DL>
<H4>Return Value</H4>
<P>Returns negative one if communication with the image window system could
not be established, if no event handlers have ever been registered,
or if <VAR>istream</VAR> is zero or is positive but not attached to an image
window the application has open.  Otherwise, returns one.

<HR>
<H3><A NAME="WMRegMouseButton">WMRegMouseButton</A></H3>
<H4>Overview</H4>
<P>By default, an application will only receive image window events for
the first mouse button if the application has
<A HREF="#WMEnableIWLEvent">enabled image window events</A> and
<A HREF="#WMAddEventHandler">registered a routine</A> to handle mouse button
events.  Of the additional buttons, the image window traps the events from
buttons two through five and uses them as signals to change the currently
displayed section.  By calling WMRegMouseButton for a button, you will
enable your application to receive image window events for that button
and, for buttons two through five, disable the normal image window behavior
in response to that button.  When you are finished with the image window, you
must match the call to WMRegMouseButton with a call, for the same image window
and button, to <A HREF="#WMUnRegMouseButton">WMUnRegMouseButton</A>.
<P>The mapping of button numbers to physical devices is usually configured
by the user for the computer system as a whole; below is a typical mapping:
<DL>
  <DT>button one<DD>left mouse button
  <DT>button two<DD>middle mouse button
  <DT>button three<DD>right mouse button
  <DT>button four<DD>upwards motion of the mouse's scroll wheel
  <DT>button five<DD>downwards motion of the mouse's scroll wheel
</DL>
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMRegMouseButton(int istream, int button_num);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMRegMouseButton(istream, button_num)</CODE>
<BR><CODE>integer istream, button_num</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>istream</VAR><DD>(in) Is the <A HREF="IM_ref2.html">IM library</A>
    stream number associated (via either
    <A HREF="IM_ref2.html#IMOpen">IMOpen</A> or
    <A HREF="IW.html#IWAttachWin">IWAttachWin</A>) with the target image
    window.
  <DT><VAR>button_num</VAR><DD>(in) Is the index of the mouse button to affect.
    Valid values of <VAR>button_num</VAR> range from one to five, inclusive.
</DL>
<H4>Return Value</H4>
<P>Returns negative one if <VAR>istream</VAR> is not currently attached to
an image window.  Also returns negative one if <VAR>button_num</VAR> is less
than one or greater than five.  Otherwise, returns one.

<HR>
<H3><A NAME="WMUnRegMouseButton">WMUnRegMouseButton</A></H3>
<H4>Overview</H4>
<P>Prevents an application from receiving image window events for a particular
mouse button and image window, and if the application was the last one that
was receiving those events from that window, restores the default image window
behavior in response to that mouse button.  Typically, you will call
WMUnRegMouseButton to undo the effects of a previous call to
<A HREF="#WMRegMouseButton">WMRegMouseButton</A>.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMUnRegMouseButton(int istream, int button_num);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMUnRegMouseButton(istream, button_num)</CODE>
<BR><CODE>integer istream, button_num</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>istream</VAR><DD>(in) Is the <A HREF="IM_ref2.html">IM library</A>
    stream number associated (via either
    <A HREF="IM_ref2.html#IMOpen">IMOpen</A> or
    <A HREF="IW.html#IWAttachWin">IWAttachWin</A>) with the target image
    window.
  <DT><VAR>button_num</VAR><DD>(in) Is the index of the button to affect.
    Valid values of <VAR>button_num</VAR> range from one to five, inclusive.
</DL>
<H4>Return Value</H4>
<P>Returns negative one if <VAR>istream</VAR> is not currently attached to
an image window.  Also returns negative one if <VAR>button_num</VAR> is less
than one or greater than five.  Otherwise, returns one.

<HR>
<H2>Remote Process Event Handling Functions</H2>

<H3><A NAME="WMAddInputEventHandler">WMAddInputEventHandler</A></H3>
<H4>Overview</H4>
<P>Registers a function that the WM library will call whenever the application
receives a remote input event of a particular type.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMAddInputEventHandler(int (*func)(), int ref, int argu);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMAddInputEventHandler(func, ref, argu)</CODE>
<BR><CODE>integer func, ref, argu</CODE>
<BR><CODE>external func</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>func</VAR><DD>(in) Is the function that the WM library will call
    when the application receives a remote input event of type <VAR>ref</VAR>.
    The WM library will pass <VAR>func</VAR> two arguments.  The first is the
    size of the event, passed as an int if WMAddInputEventHandler was called
    from C or as a reference to an integer if WMAddInputEventHandler was called
    from Fortran.  The second argument is the value of <VAR>argu</VAR> (i.e.
    an integer if WMAddInputEventHandler was called from C or a reference to
    an integer if WMAddInputEventHandler was called from Fortran).  The WM
    library expects <VAR>func</VAR> to return an integer, but the particular
    value returned has no effect on the behavior of the WM library.
  <DT><VAR>ref</VAR><DD>(in) Specifies the type of remote input event that
    will cause the WM library to call <VAR>func</VAR>.
  <DT><VAR>argu</VAR><DD>(in) When the WM library calls <VAR>func</VAR>,
    it will pass <VAR>argu</VAR> as the second argument.
</DL>
<H4>Return Value</H4>
<P>If <VAR>func</VAR> is zero, returns zero; otherwise, returns the value of
<VAR>ref</VAR>.

<HR>
<H3><A NAME="WMCancelInputEventHandler">WMCancelInputEventHandler</A></H3>
<H4>Overview</H4>
<P>Removes a handler, installed by
<A HREF="#WMAddInputEventHandler">WMAddInputEventHandler</A>, for remote
input events.
<H4>C Prototype</H4>
<P><CODE>#include "WMRemFunc.h"</CODE>
<BR><CODE>int WMCancelInputEventHandler(int handler_ref);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMCancelInputEventHandler(handler_ref)</CODE>
<BR><CODE>integer handler_ref</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>handler_ref</VAR><DD>(in) Specifies the type of remote events that
    the application no longer wishes to handle.
</DL>
<H4>Return Value</H4>
<P>Returns one.

<HR>
<H3><A NAME="WMStartRemoteProgram">WMStartRemoteProgram</A></H3>
<H4>Overview</H4>
<P>Initializes the mechanism for remote communication and starts the remote
process.  Currently, WMStartRemoteProgram will not work unless the local
machine has a current Priism session to which the application calling
WMStartRemoteProgram can connect (i.e. the application and the Priism session
are running under the same user ID).
<H4>C Prototype</H4>
<P><CODE>#include "WMRemFunc.h"</CODE>
<BR><CODE>int WMStartRemoteProgram(const char* machine_name, const char* full_command);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMStartRemoteProgram(machine_name, full_command)</CODE>
<BR><CODE>character*(*) machine_name, full_command</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>machine_name</VAR><DD>(in) Is the host name for the remote machine.
  <DT><VAR>full_command</VAR><DD>(in) Is the shell command or commands to
    execute on the remote machine.
</DL>
<H4>Return Value</H4>
<P>Returns one.

<HR>
<H3><A NAME="WMRemoteSendData">WMRemoteSendData</A></H3>
<H4>Overview</H4>
<P>Sends data to a remote program.
<H4>C Prototype</H4>
<P><CODE>#include "WMRemFunc.h"</CODE>
<BR><CODE>int WMRemoteSendData(const void* data, int ref_id, int size);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer WMRemoteSendData(data, ref_id, size);</CODE>
<BR><CODE>integer ref_id, size</CODE>
<BR><VAR>application-specific type</VAR> <CODE>data(*)</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>data</VAR><DD>(in) Refers to the memory holding the data to be sent.
  <DT><VAR>ref_id</VAR><DD>(in) Is the type of the message sent and is used to
    by the recipient to select a handler for the message.
  <DT><VAR>size</VAR><DD>(in) Specifies the number of bytes to send.
</DL>
<H4>Return Value</H4>
<P>Returns one.

<HR>
<H3><A NAME="WMRemoteGetBytes">WMRemoteGetBytes</A></H3>
<H4>Overview</H4>
<P>Reads up to a given number of bytes from an incoming remote message.  Does
not swap bytes in the incoming data.
<H4>C Prototype</H4>
<P><CODE>#include "WMRemFunc.h"</CODE>
<BR><CODE>int WMRemoteGetBytes(void* data, int size);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMRemoteGetBytes(data, size)</CODE>
<BR><CODE>integer size</CODE>
<BR><VAR>application-specific type</VAR> <CODE>data(*)</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>data</VAR><DD>(out) Refers to the space to use for the incoming
    data.
  <DT><VAR>size</VAR><DD>(in) Specifies the number of bytes to read.
</DL>
<H4>Return Value</H4>
<P>Returns the number of bytes read.

<HR>
<H3><A NAME="WMRemoteGetInt2">WMRemoteGetInt2</A></H3>
<H4>Overview</H4>
<P>Reads up to a given number of two-byte chunks from an incoming remote
message and swaps bytes if the sending machine has a different byte ordering
than the recipient.
<H4>C Prototype</H4>
<P><CODE>#include "WMRemFunc.h"</CODE>
<BR><CODE>int WMRemoteGetInt2(void* data, int size);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMRemoteGetInt2(data, size)</CODE>
<BR><CODE>integer size</CODE>
<BR><VAR>application-specific type</VAR> <CODE>data(*)</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>data</VAR><DD>(out) Refers to the space to use for the incoming
    data.
  <DT><VAR>size</VAR><DD>(in) Specifies the number of two-byte chunks to read.
</DL>
<H4>Return Value</H4>
<P>Returns the number of two-byte chunks read.

<HR>
<H3><A NAME="WMRemoteGetInt4">WMRemoteGetInt4</A></H3>
<H4>Overview</H4>
<P>Reads up to a given number of four-byte chunks from an incoming message and
swaps bytes if the sending machine has a different byte ordering than the
recipient.
<H4>C Prototype</H4>
<P><CODE>#include "WMRemFunc.h"</CODE>
<BR><CODE>int WMRemoteGetInt4(void* data, int size);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMRemoteGetInt4(data, size)</CODE>
<BR><CODE>integer size</CODE>
<BR><VAR>application-specific type</VAR> <CODE>data(*)</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>data</VAR><DD>(out) Refers to the space to use for the incoming
    data.
  <DT><VAR>size</VAR><DD>(in) Specifies the number of four-byte chunks to read.
</DL>
<H4>Return Value</H4>
<P>Returns the number of four-byte chunks read.

<HR>
<H2>Window Manager Control Functions</H2>

<H3><A NAME="WMSetExitFunction">WMSetExitFunction</A></H3>
<H4>Overview</H4>
<P>Instructs the WM library to call a particular routine when the user
uses the window manager controls to close the dialog created with
<A HREF="#WMInit">WMInit</A>.  If you make multiple calls to
WMSetExitFunction, only the last has an effect.
<P>If your application requires special actions to be taken when the program
exits, you should install a callback with WMSetExitFunction to perform those
actions in addition to any other method you provide the user for closing
the application.  Otherwise, the user can force the application to exit
with the window manager controls and circumvent the actions that take place
when the application exits normally.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>void WMSetExitFunction(int (*callback)());</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>subroutine WMSetExitFunction(callback)</CODE>
<BR><CODE>integer callback</CODE>
<BR><CODE>external callback</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>callback</VAR><DD>(in) Is the routine the WM library will call in
    response to the user using the window manager controls to close the
    dialog created with <A HREF="#WMInit">WMInit</A>.  The WM library will
    pass <VAR>callback</VAR> no arguments and expects <VAR>callback</VAR> to
    return an integer value though the particular value returned has no
    effect on the behavior of the library.  When called from C,
    <VAR>callback</VAR> may be zero to restore the default response (exiting
    the application) to the user closing the main dialog with the window
    manager controls.
</DL>

<HR>
<H3><A NAME="WMSetSubExitFunc">WMSetSubExitFunc</A></H3>
<H4>Overview</H4>
<P>Instructs the WM library to call a particular routine when the user
uses the window manager controls to close a dialog created with
<A HREF="#WMInit">WMInit</A> or <A HREF="#WMInitSubMenu">WMInitSubMenu</A>.
If you make multiple calls to WMSetSubExitFunc for a particular dialog,
only the last has an effect.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<CODE><BR>void WMSetSubExitFunc(int menu_number, int (*callback)());</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>subroutine WMSetSubExitFunc(menu_number, callback)</CODE>
<BR><CODE>integer menu_number, callback</CODE>
<BR><CODE>external callback</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>menu_number</VAR><DD>(in) Is the index for the dialog for which
    close operations from the window manager will cause <VAR>callback</VAR> to
    be called.  <VAR>menu_number</VAR> can be zero, in which case
    WMSetSubExitFunc will have the same effect as
    <A HREF="#WMSetExitFunction">WMSetSubExitFunction</A>, or a value returned
    by <A HREF="#WMInitSubMenu">WMInitSubMenu</A>.
  <DT><VAR>callback</VAR><DD>(in) Is the routine the WM library will call in
    response to the user using the window manager controls to close the
    dialog specified by <VAR>menu_number</VAR>.  For dialogs other than
    the main dialog (<VAR>menu_number</VAR> equal to zero), the library will
    call <VAR>callback</VAR> after the dialog has been removed from the
    display.  The WM library will pass <VAR>callback</VAR> no arguments and
    expects <VAR>callback</VAR> to return an integer value though the
    particular value returned has no effect on the behavior of the library.
    When called from C, <VAR>callback</VAR> may be zero to restore the
    default response:  exiting the application if <VAR>menu_number</VAR> is
    zero or closing the dialog if <VAR>menu_number</VAR> is not zero.
</DL>

<HR>
<H2>Display/Dialog/Widget Information Functions</H2>

<H3><A NAME="WMGetLoc">WMGetLoc</A></H3>
<H4>Overview</H4>
<P>Determines the screen position of a dialog created with
<A HREF="#WMInit">WMInit</A> or <A HREF="#WMInitSubMenu">WMInitSubMenu</A>.
As described here, WMGetLoc first appeared in the October 1999 release of
IVE 3.3.  A different version, which lacked a return value and the
<VAR>menunum</VAR> argument, was included in the October 1998 release of
IVE 3.3.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMGetLoc(int* ix, int* iy, int menunum);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMGetLoc(ix, iy, menunum)</CODE>
<P><CODE>integer ix, iy, menunum</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>ix</VAR><DD>(out) When WMGetLoc returns zero, WMGetLoc will set
    the integer referred to by <VAR>ix</VAR> to the displacement, in pixels,
    of the left edge of the dialog from the left edge of the screen.  A
    positive displacement means the left edge of the dialog is to the right of
    the left edge of the screen.
  <DT><VAR>iy</VAR><DD>(out) When WMGetLoc returns zero, WMGetLoc will set
    the integer referred to by <VAR>iy</VAR> to the displacement, in pixels,
    of the top edge of the dialog from the top edge of the screen.  A
    positive displacement means the top edge of the dialog appears below the
    top edge of the screen.
  <DT><VAR>menunum</VAR><DD>(in) Specifies the dialog of interest.
    For a dialog created by <A HREF="#WMInit">WMInit</A>, use a value of zero.
    For a dialog created by <A HREF="#WMInitSubMenu">WMInitSubMenu</A>,
    use the value returned by <A HREF="#WMInitSubMenu">WMInitSubMenu</A>.
</DL>
<H4>Return Value</H4>
<P>If the dialog specified by <VAR>menunum</VAR> has been initialized,
WMGetLoc returns zero and sets the integers referred to by <VAR>ix</VAR> and
<VAR>iy</VAR>.  Otherwise, WMGetLoc returns negative one and does not
modify the integers referred to by <VAR>ix</VAR> and <VAR>iy</VAR>.

<HR>
<H3><A NAME="WMGetMenuSize">WMGetMenuSize</A></H3>
<H4>Overview</H4>
<P>Determines the width and height, in pixels, for a dialog created with
<A HREF="#WMInit">WMInit</A> or <A HREF="#WMInitSubMenu">WMInitSubMenu</A>.
The size of the dialog will be sensitive to the controls that have been
added to the dialog so you would normally call WMGetMenuSize after adding
all the controls to that dialog.  WMGetMenuSize first appeared in IVE 4.0.7.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMGetMenuSize(int* width, int* height, int menunum);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMGetMenuSize(width, height, menunum)</CODE>
<BR><CODE>integer width, height, menunum</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>width</VAR><DD>(in) When WMGetMenuSize returns zero, WMGetMenuSize
    will set the integer referred to by <VAR>width</VAR> to the width,
    in pixels, of the dialog specified by <VAR>menunum</VAR>.
  <DT><VAR>height</VAR><DD>(in) When WMGetMenuSize returns zero, WMGetMenuSize
    will set the integer referred to by <VAR>height</VAR> to the height,
    in pixels, of the dialog specified by <VAR>menunum</VAR>.
  <DT><VAR>menunum</VAR><DD>(in) Specifies the dialog of interest.
    For a dialog created by <A HREF="#WMInit">WMInit</A>, use a value of zero.
    For a dialog created by <A HREF="#WMInitSubMenu">WMInitSubMenu</A>,
    use the value returned by <A HREF="#WMInitSubMenu">WMInitSubMenu</A>.
</DL>
<H4>Return Value</H4>
<P>If the dialog specified by <VAR>menunum</VAR> has been initialized,
WMGetMenuSize returns zero and modifies the values referred to by
<VAR>width</VAR> and <VAR>height</VAR>.  Otherwise, WMGetMenuSize returns
negative one and does not modify the integer referred to by <VAR>width</VAR>
and <VAR>height</VAR>.

<HR>
<H3><A NAME="WMGetScreenSize">WMGetScreenSize</A></H3>
<H4>Overview</H4>
<P>Determines the size of the default screen.  A good use for
WMGetScreenSize is to use the result to determine where to place a dialog with
<A HREF="#WMSetLoc">WMSetLoc</A>.
<P>WMGetScreenSize was added in IVE 4.0.7.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMGetScreenSize(int* width, int* height);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMGetScreenSize(width, height)</CODE>
<BR><CODE>integer width, height</CODE>
<H4>Parameters</H4>
<DL>
  <DT><VAR>width</VAR><DD>(out) If WMGetScreenSize returns zero,
    WMGetScreenSize sets the integer referred to by <VAR>width</VAR> to
    the width, in pixels, of the default screen.
  <DT><VAR>height</VAR><DD>(out) If WMGetScreenSize returns zero,
    WMGetScreenSize sets the integer referred to by <VAR>height</VAR> to
    the height, in pixels, of the default screen.
</DL>
<H4>Return Value</H4>
<P>Returns negative one if the WM library has not been initialized yet
(using <A HREF="#WMInit">WMInit</A>, for example).  Otherwise, returns zero.

<HR>
<H3><A NAME="WMOverlayDepth">WMOverlayDepth</A></H3>
<H4>Overview</H4>
<P>Returns the number of bit planes in the overlay plane, if any, that the WM
library can use (see the documentation of
<A HREF="#WMSetOverlayUse">WMSetOverlayUse</A> for how to place dialogs in
the overlay plane).  If the WM library will not use an overlay plane because
of hardware or software limitations, WMOverlayDepth will return zero.  The
number of colors available in the overlay plane is two raised to the number of
bit planes minus one.  One of those colors typically can not be modified and
is used for the parts of the overlay plane that do not obscure the normal
display planes.
<P>WMSetOverlayUse was added to Priism 3.3 in January 1999.
<H4>C Prototype</H4>
<P><CODE>#include "WMInclude.h"</CODE>
<BR><CODE>int WMOverlayDepth(void);</CODE>
<H4>Fortran Prototype</H4>
<P><CODE>integer function WMOverlayDepth()</CODE>
<H4>Return Value</H4>
<P>Returns the number of bit planes in the overlay plane used by the WM
library.

<HR>

</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <TITLE>Priism's iomenu Utility</TITLE>
  <META NAME="Description" CONTENT="Describes the iomenu utility to facilitate creating graphical user interfaces for command-line applications.">
  <META NAME="Keywords" CONTENT="Priism,iomenu">
  <LINK REV=MADE HREF="mailto:ive@msg.ucsf.edu">
</HEAD>
<BODY>

<H1><A NAME="Overview">Priism's IOMENU Utility</A></H1>
<H2>Overview</H2>

<P>The iomenu utility facilitates creation of graphical user interfaces for
command-line applications.  A computer program that uses the iomenu utility
has the following structure:

<OL>
  <LI>Fill in a structure describing the command-line parameters.
  <LI>Optionally call iomenu_set_region_controls() to limit the controls
    displayed for selecting a region to process.
  <LI>Optionally configure the interaction with the queues.
  <LI>Call iomenu().  iomenu() creates the user interface and waits for user
    interaction.  Parts of the user interface are created automatically
    by iomenu().  Others are created by callback routines you provide.
    The controls created by iomenu() are handled internally by iomenu()
    though there are two hooks for calling your own code:  one for handling
    when the application exits and the other for handling changes to the
    file parameters or the region selected.
</OL>

<P><A HREF="BatchRegion.html">BatchRegion.html</A> describes for the end user
what the controls automatically generated by iomenu() are.  To summarize,
the basic pattern of user interaction is:

<OL>
  <LI>The user selects the primary input file.  This has the side effect of
    changing the region selected to cover the full size of the input and
    to change the names of the output files and script.
  <LI>The user edits the other parameters.  Except for the file and queuing
    parameters, these interactions will be directly handled by your code.
  <LI>The user requests that the current parameters be written out as a
    script which the option of running that script immediately either on
    the local machine or through some sort of queueing system.
</OL>

<P>The iomenu utility has both C/C++ and Fortran interfaces.  For details on
how to use the C/C++ interface, consult the
<A HREF="#CDetails">C Details section</A>; for details on how to use the
Fortran interface, consult the <A HREF="#FortranDetails">Fortran Details</A>
section.

<P>In Priism 4.1.0 and later, there is an alternate way for providing both
a command-line and graphical user interface via the
<A HREF="IP.html">IP Framework</A>.  The primary differences between that
framework and iomenu are:

<UL>
  <LI>With the IP Framework, the graphical interface and command-line interface
    are handled by the same executable and it is the presence or absence of
    command-line parameters which causes the application to display the
    graphical user interface.  With the iomenu utility, the graphical interface
    and the command-line program are typically separate.
  <LI>The submission of jobs works differently in the two.  With the IP
    framework, pressing "Do It" causes processing to be done by the same
    process that has displayed the graphical user interface; there is an
    alternate pathway, via the Options-&gt;Create batch job... menu entry,
    to write out a script and optionally run that script.  With the iomenu
    utility, pressing "Do It" generates a script that, when run, will do
    the processing.
  <LI>The IP framework is more complicated to use, primarily because it
    includes processing, display of the graphical interface, generating the
    script, and command-line parsing.  The iomenu utility only handles the
    graphical interface and generating the script.  The process of generating
    the script is easier with the iomenu utility since no additional code
    is needed other than that to define the command-line parameters:  the
    IP framework requires an additional callback to write the
    application-specific parameters.
  <LI>The IP framework automatically provides some capabilities that iomenu
    does not:  the user can set the output data type and z step size and
    the result of processing can be appended to an existing data set.  The
    Fortran interface to the iomenu utility imposes upper limits on the number
    of command-line parameters and related values that the IP framework does
    not.
</UL>

<H3>Topics</H3>
<P>
   Overview |
   <A HREF="#CDetails">C details</A> |
   <A HREF="#FortranDetails">Fortran details</A> |
   <A HREF="#ReleaseNotes">Release notes</A>

<H3>Related Priism Topics</H3>
<P>
  <A HREF="BatchRegion.html">User documentation for iomenu() interfaces</A> |
  <A HREF="IP.html">IP framework</A> |
  <A HREF="Priism.html">Priism</A>
<HR>

<H2><A NAME="CDetails">C Details</A></H2>
<H3>Example</H3>
<P>The file, <A HREF="../EXAMPLE/sample_iomenu_c.c">sample_iomenu_c.c</A>,
in the EXAMPLE directory of the Priism distribution demonstrates how to
use the iomenu utility from C.  The <A HREF="../EXAMPLE/makefile">makefile</A>
in the same directory includes a rule to build an executable from
sample_iomenu_c.c.

<H3>Initializing the command-line parameter structure</H3>
<P>The command line generated by the iomenu utility has the form

<PRE>
    <VAR>application_name</VAR> <VAR>file1</VAR> ... <VAR>filen</VAR> \
        <VAR>switch1_label</VAR><VAR>switch1_values</VAR> ... \
        <VAR>switchn_label</VAR><VAR>switchn_values</VAR>
</PRE>

<P><VAR>file1</VAR> through <VAR>filen</VAR> are the required input
and output files for the application.  Each switch consists of a label
(customarily <CODE>-</CODE><VAR>name</VAR> if the switch has no values or
<CODE>-</CODE><VAR>name</VAR><CODE>=</CODE> if it has values) which may
(depending on the type of switch) be followed by a colon separated list
of values.

<P>The contents of the command line are controlled by the entries in the
Iomenu structure passed, via a pointer, to iomenu().  The Iomenu structure is
defined in iomenu.h as

<PRE>
    typedef struct Iomenu {
        IomenuFile* files;
        IomenuParameter* parameters;
        void* closure;
        int file_count;
        int parameter_count;
        char xyztw_size[4 + IW_MAX_WAVE][16];
        int iparm, nxyztw[5], ixyztw[4 + IW_MAX_WAVE][3], mode;
        float dmin, dmax, dmean, delxyz[3];
    } Iomenu;
</PRE>

<P>The elements of the structure that you need to initialize before calling
iomenu() are:

<DL>
  <DT><STRONG>files</STRONG>
  <DD>Points to the first element of an array of IomenuFile structures.  You
    set the length of the array by the file_count field.  The array defines
    the required file arguments for the command-line application (i.e.
    <VAR>file1</VAR> through <VAR>filen</VAR>).  An IomenuFile structure
    contains four fields:  filename, filter, label, and type.  You must
    initialize the type field to one of the following values:
    <DL>
      <DT><STRONG>IOMENU_PRIMARY_IMAGE</STRONG>
      <DD>The file will be treated as a primary input file.  Before generating
        a script via the "Do It" button, the iomenu utility requires that the
        user specify the names of all primary input files and that those files
        must exist.  When the user changes the name of a primary input file
        from the user interface, the iomenu utility resets the processing
        region to cover the entire range of the input and updates the
        corresponding controls in the graphical user interface.  It resets
        the names of all the files of type IOMENU_OUTPUT_DEFAULT so that they
        have the same name as the primary input followed by an extension
        specified by the filter field for the IOMENU_OUTPUT_DEFAULT file.  The
        iomenu utility also resets the directory where the log and script files
        are written to be the same as the name of the directory containing the
        primary input file.  Because of those side effects, the typical case is
        to have exactly one primary input file (customarily the first one in
        the list).  More than one is possible, but may lead to confusion on
        the part of user.  Having zero primary input files is also possible,
        but the user interface is biased toward selecting a region from an
        existing file rather than specifying from scratch the bounds for a new
        file.  In addition, there is no direct way to specify the default
        values for the size if you do not have a primary input file:  as a
        crude hack, you could initialize the nxyztw, ixyztw, and xyztw_size
        fields of the Iomenu structure (see the description of the
        handle_file_proc callback for details about those fields) from within
        the menu_proc or special_menu_proc callbacks and then use
        WMUpdateGroup(1) to update the corresponding interface controls.
      <DT><STRONG>IOMENU_OTHER_INPUT</STRONG>
      <DD>The file will be treated as a required input file (but not a
        primary input file which the iomenu utility uses to set the default
        region for processing and the default names for output and script
        files).  Before generating a script via the "Do It" button, the
        iomenu utility requires that the user specify the names of all required
        input files and that those files must exist.
      <DT><STRONG>IOMENU_OUTPUT_DEFAULT</STRONG>
      <DD>The file will be treated as a required output file whose default name
        is the name of the primary input file with the contents of the
        filter field for the output file appended.  Before generating a script
        via the "Do It" button, the iomenu requires that all required output
        files have some sort of name specified.
      <DT><STRONG>IOMENU_OTHER_OUTPUT</STRONG>
      <DD>The file will be treated as a required output file; the iomenu
        utility does not automatically generate a default name for the file
        when a new primary input file is selected.  Before generating a script
        via the "Do It" button, the iomenu requires that all required output
        files have some sort of name specified.
    </DL>
    The iomenu utility uses the label field in the user interface controls for
    the file.  Each file has a button and a text field, and the contents of
    the label field are displayed as the label for the button.  Initialize the
    label field with a null-terminated string that contains short name which
    indicates the the nature of the file to be selected.  If the type field is
    IOMENU_PRIMARY_IMAGE or IOMENU_OTHER_INPUT, the iomenu utility uses the
    contents of the filter field as the selection pattern argument to
    <A HREF="WM.html#WMAddGetFile">WMAddGetFile</A>, and you should initialize
    the filter field accordingly.  If the type field is IOMENU_OUTPUT_DEFAULT,
    the iomenu utility appends the contents of the filter field to the
    name of the primary input file to form the default name of the file.  If
    the type field is IOMENU_OTHER_OUTPUT, the iomenu utility ignores the
    filter field.  The filename field holds the name of the file.  You would
    normally initialize the filename field to an empty string except for
    IOMENU_OTHER_INPUT or IOMENU_OTHER_OUTPUT files for which you have
    a reasonable default.
  <DT><STRONG>parameters</STRONG>
  <DD>Points to the first element of an array IomenuParameter structures.  You
    set the length of the array by the parameter_count field.  The array
    defines the command-line switches.  An IomenuParameter structure contains
    three fields:  label, v, and type.  You must initialize the type field to
    one of the following values:
    <DL>
      <DT><STRONG>IOMENU_INTEGER</STRONG>
      <DD>When the iomenu utility writes out the switch on the command line,
        it prints the switch as the contents of the label field followed by a
        colon-separated list of integers.  The v.i.count field holds the number
        of integers, and the v.i.values field points to the first element of
        the array holding the values for the integers.
      <DT><STRONG>IOMENU_REAL</STRONG>
      <DD>When the iomenu utility writes out the switch on the command line,
        it prints the switch as the contents of the label field followed by a
        colon-separated list of floating-point values.  The v.r.count field
        holds the number of floating-point values, and the v.r.values field
        points to the first element of the array holding the values for the
        floating-point numbers.
      <DT><STRONG>IOMENU_ACTIVE_WHEN_NONZERO</STRONG>
      <DD>When the iomenu utility writes out the switch on the command line, it
        prints out the contents of the label field if *(v.pb) is not zero;
        otherwise, it does not print out anything for the switch.
      <DT><STRONG>IOMENU_ACTIVE_WHEN_ZERO</STRONG>
      <DD>When the iomenu utility writes out the switch on the command line, it
        prints out the contents of the label field if *(v.pb) is zero;
        otherwise, it does not print out anything for the switch.
      <DT><STRONG>IOMENU_STRING</STRONG>
      <DD>When the iomenu utility write out the switch on the command line, it
        prints out the contents of the label field followed by a colon-
        separated list of character strings.  Each element in the list is
        surrounded by double quotes.  The v.c.count field holds the number of
        elements in the list.  The v.c.values field is the array of
        null-terminated character strings holding the values.
    </DL>
    The v field is a union.  The elements and their meanings are described
    above for the different type codes; initialize v accordingly.  The iomenu
    utility prints out the contents of the label field when printing the
    command-line switch.  By convention, labels for IOMENU_INTEGER,
    IOMENU_REAL, and IOMENU_STRING switches have the form
    <CODE>-</CODE><VAR>name</VAR><CODE>=</CODE>.  By convention, labels for the
    IOMENU_ACTIVE_WHEN_NONZERO and IOMENU_ACTIVE_WHEN_ZERO switches have the
    form <CODE>-</CODE><VAR>name</VAR>.
  <DT><STRONG>closure</STRONG>
  <DD>The closure field is not used internally by the iomenu utility but you
    can use it to pass along additional information to the callback routines.
  <DT><STRONG>file_count</STRONG>
  <DD>Is the number of elements in the array whose first element is pointed to
    by the files field.
  <DT><STRONG>parameter_count</STRONG>
  <DD>Is the number of elements in the array whose first element is pointed to
    by the parameters field.
</DL>

<H3>Calling iomenu_set_region_controls()</H3>
<P>To limit the region selection controls displayed, call
iomenu_set_region_controls() before calling iomenu().  Calling
iomenu_set_region_controls() after calling iomenu() has no effect.

<P>The iomenu_set_region_controls() function is declared in iomenu.h as

<PRE>
    void iomenu_set_region_controls(int style)
</PRE>

<P><VAR>style</VAR> is expected to be one of the following constants
which are declared in iomenu.h:

<DL>
  <DT><STRONG>IOMENU_REG_CTRL_ALL</STRONG><DD>Display all region selection
    controls.  This is the default behavior.
  <DT><STRONG>IOMENU_REG_CTRL_5D_SIZE</STRONG><DD>Only display an indicator
    with the size of the five dimensions of the primary image input file.
  <DT><STRONG>IOMENU_REG_CTRL_3D_SIZE</STRONG><DD>Only display an indicator
    with the size of the x dimension, size of the y dimension, and the number
    of sections for the primary image input file.
  <DT><STRONG>IOMENU_REG_CTRL_XY_ONLY</STRONG>Only display controls for
    selecting the region of interest in x and y.  This option was added
    in Priism 4.3.0.
  <DT><STRONG>IOMENU_REG_CTRL_4D_NO_Z</STRONG>Display controls for
    selecting the region of interest in x, y, wavelength, and time.  This
    option was added in Priism 4.3.0.
  <DT><STRONG>IOMENU_REG_CTRL_4D_NO_W</STRONG>Display controls for
    selecting the region of interest in x, y, z, and time.  This
    option was added in Priism 4.3.0.
  <DT><STRONG>IOMENU_REG_CTRL_4D_NO_T</STRONG>Display controls for
    selecting the region of interest in x, y, z, and wavelength.  This
    option was added in Priism 4.3.0.
</DL>

<H3>Configuring the interaction with the queues</H3>
<P>It is possible to customize the selection of the default queue, which
queues are listed as available, and whether or not to receive a callback when
the user changes the destination queue.  The related function calls are
iomenu_set_int_property() and iomenu_set_queue_callback().
iomenu_set_int_property() is declared in iomenu.h as

<PRE>
    int iomenu_set_int_property(const char* <VAR>prop</VAR>, int i);
</PRE>

<P>iomenu_set_int_property() associates the given integer value, <VAR>i</VAR>,
with the name, <VAR>prop</VAR>.  It returns zero when successful and a
non-zero value when not successful.  The property names that are relevant
for customizing the queue behavior are:

<DL>
  <DT><STRONG>DEFAULT_QUEUE_TYPE</STRONG><DD>If the related integer value is
    zero, the default destination is the local machine.  If the related integer
    value is one, the default destination is the queue that has been
    designated as the default destination for serial (single processor) jobs.
    If the related integer value is two, the default destination is the queue
    that has been designated as the default destination for parallel
    (multiprocessor) jobs that may run on multiple hosts.  If the related
    integer value is three, the default destination is the queue that has been
    designated as the default destination for GPU jobs.  If the related integer
    value is four, the default destination is the queue that has been
    designated as the default destination for parallel (multiprocessor) jobs
    that can only use a single host.  The default value of this property is
    one.  Modifying this property after calling iomenu() will have no effect on
    the internal behavior of the iomenu library.
  <DT><STRONG>QUEUE_SUBSET</STRONG><DD>The related integer value, <VAR>v</VAR>,
    defines which queues to include in the list in the user interface.  A
    queue will be included if the bitwise-and of the queue's value (a
    bitwise-or of one (if the queue accepts parallel jobs which may run on
    multiple hosts), two (if the queue accepts serial jobs), and four (if the
    queue accepts GPU jobs), and eight (if the queue accepts parallel jobs
    which can only use a single host)) with the ones-complement of
    <VAR>v</VAR> is non-zero.  The default value of this property is 13.
    Modifying this property after calling iomenu() will have no effect on the
    internal behavior of the iomenu library.
</DL>

<P>iomenu_set_queue_callback() is declared in iomenu.h as

<PRE>
    void iomenu_set_queue_callback(void (*func)(Iomenu*));
</PRE>

<P>iomenu_set_queue_callback() instructs the IOMENU library to call func
when the user changes the destination queue.  func may be zero and then
the IOMENU library does not perform a callback when the user changes the
destination queue.  The IOMENU library passes a single argument, a pointer
to the Iomenu structure that was passed to iomenu(), to the callback.  To get
a handle to the properties of the current queue (from within the callback for
a queue change or any other time after iomenu() has been called), use
iomenu_get_current_queue().  iomenu_get_current_queue() is declared in
iomenu.h as

<PRE>
    IVEQDMember iomenu_get_current_queue(void);
</PRE>

<P>To get the properties from the handle, use the functions described in
the iveqd.h header file.  When a queue changes, you may want to change
the number of processors to use when submitting a job.  To do so use
iomenu_set_int_property() with "QUEUE_NPROC" as the name and the number of
processors as the integer value; a value of zero or less for the number of
processors will select the default number of processors for that queue.

<H3>Calling iomenu()</H3>
<P>The iomenu() function is declared in iomenu.h as

<PRE>
    void iomenu(
        const char* <VAR>title</VAR>,
        const char* <VAR>submenu_title</VAR>,
        const char* <VAR>app_name</VAR>,
        Iomenu* <VAR>iom</VAR>,
        void (*<VAR>menu_proc</VAR>)(Iomenu*),
        void (*<VAR>special_menu_proc</VAR>)(Iomenu*),
        void (*<VAR>handle_file_proc</VAR>)(Iomenu*),
        void (*<VAR>handle_exit_proc</VAR>)(Iomenu*)
    );
</PRE>

<P>The arguments are:

<DL>
  <DT><VAR>title</VAR>
  <DD><VAR>title</VAR> is the name that will appear on the title bar of the
    main dialog.
  <DT><VAR>submenu</VAR>
  <DD>The iomenu utility can display a button in the main dialog that will
    open a child dialog.  The most common use for this is to group rarely
    changed parameters in this child dialog.  <VAR>submenu</VAR> is the
    name that will appear on the button in the main dialog to open the
    child dialog.  If <VAR>submenu</VAR> is zero or points to an empty string,
    the button to open the child dialog will not be created.
  <DT><VAR>app_name</VAR>
  <DD><VAR>app_name</VAR> is the name of the command-line application to run.
    If <VAR>app_name</VAR> does not begin with / and the environment variable
    IVE_ENV_SETUP is not set, the iomenu utility will prepend
    <VAR>app_name</VAR> with the name of the Priism executable directory when
    writing the script file.  <VAR>app_name</VAR> is also used as the base
    for the default names of the script and log files as well as the base for
    the name used when saving or restoring the current contents of the dialog
    via the Save and Restore buttons.
  <DT><VAR>iom</VAR>
  <DD>Points to the Iomenu structure (defined in iomenu.h) describing the
    command line parameters.
  <DT><VAR>menu_proc</VAR>
  <DD>Is the routine the iomenu utility will call to add application-specific
    controls to the main dialog.  See the
    <A HREF="#CCallbacks">Callbacks section</A> below for more details.
    <VAR>menu_proc</VAR> may be zero and is ignored in that case.
  <DT><VAR>special_menu_proc</VAR>
  <DD>If <VAR>submenu</VAR> is not zero and does not point to an empty string,
    <VAR>special_menu_proc</VAR> is the routine the iomenu utility will call
    to add application-specific controls to the child dialog.  See the
    <A HREF="#CCallbacks">Callbacks section</A> below for more details.  If
    <VAR>submenu</VAR> is zero or points to an empty string,
    <VAR>special_menu_proc</VAR> is ignored.  <VAR>special_menu_proc</VAR> may
    be zero and is ignored in that case.
  <DT><VAR>handle_file_proc</VAR>
  <DD>Is the routine the iomenu utility will call when the user changes the
    name of one of the required files or changes the bounds of the region to
    process.    See the <A HREF="#CCallbacks">Callbacks section</A> below
    for more details.  <VAR>handle_file_proc</VAR> may be zero and is ignored
    in that case.
  <DT><VAR>handle_exit_proc</VAR>
  <DD>Is the routine the iomenu utility will call when the user exits the
    application via the button labeled "Exit" in the main dialog or via the
    window manager.  See the <A HREF="#CCallbacks">Callbacks section</A>
    below for more details.  <VAR>handle_exit_proc</VAR> may be zero and is
    ignored in that case.
</DL>

<H3><A NAME="CCallbacks">Callbacks</A></H3>
<P>For the C/C++ interface to the iomenu utility, you set the callbacks via
the last four arguments to iomenu().

<P>If the <VAR>menu_proc</VAR> argument to iomenu() is not zero, the iomenu
utility calls the function pointed to by <VAR>menu_proc</VAR> after it has
initialized the WM library (with <A HREF="WM.html#WMInit">WMInit</A>), and
added the controls for the required files and the region bounds to the main
dialog.  After calling the function pointed to by <VAR>menu_proc</VAR>, the
iomenu utility will complete the main dialog by adding an optional button to
open a child dialog (see the description of the <VAR>submenu_title</VAR>
argument to iomenu() for more information) and a series of buttons, labeled
"Exit", "Save", "Restore", "Options", and "Do It", at the bottom of the dialog.
The iomenu utility passes personal() a single argument, the pointer to an
Iomenu structure that you passed to iomenu().  Normally, you would use
the <VAR>menu_proc</VAR> callback to add the graphical user interface
components to the main dialog that are necessary to control the command-line
switches you defined in the Iomenu structure.

<P>If the <VAR>special_menu_proc</VAR> argument to iomenu() is not zero and
the <VAR>submenu_title</VAR> argument to iomenu() is not zero and does not
point to an empty string, the iomenu utility calls the function pointed to by
<VAR>special_menu_proc</VAR> after it has created the main dialog and
initialized an empty child dialog.  After calling the function pointed to by
<VAR>special_menu_proc</VAR>, the iomenu utility will add a button, labeled,
"OK", for closing the child dialog; the iomenu utility will then enter
the loop to process user interactions.  The iomenu utility passes the function
pointed to by <VAR>special_menu_proc</VAR> a single argument, the pointer to
an Iomenu structure that you passed to iomenu().  Normally, you would use the
<VAR>special_menu_proc</VAR> callback to add the graphical user interface
components that you did not put in the main dialog.

<P>If the <VAR>handle_file_proc</VAR> argument to iomenu() is not zero, the
iomenu_utility calls the function pointed to by <VAR>handle_file_proc</VAR>
when the user changes the name of one of the required files or changes the
bounds of the region to process.  The iomenu utility passes the function
pointed to by <VAR>handle_file_proc</VAR> a single argument, the pointer to
an Iomenu structure that you passed to iomenu().  Before calling the function
pointed to by <VAR>handle_file_proc</VAR>, the iomenu utility changes the
value of the iparm field in the Iomenu structure.  If the function pointed to
by <VAR>handle_file_proc</VAR> is to be called because the user changed one
of the names of the required files, the iomenu_utility sets iparm to one plus
the index of that file in the files array of the Iomenu structure.  If the file
changed was a primary input file, the iomenu utility will also read the header
of that field and reset the following fields of the Iomenu structure:

<DL>
  <DT><STRONG>ixyztw</STRONG>
  <DD>ixyztw holds the bounds of the region to process.  ixyztw[0][0] is the
    first x pixel, and ixyztw[0][1] is the last x pixel.  After changing a
    primary input file, ixyztw[0][0] will be zero and ixyztw[0][1] will be the
    size of the x dimension in pixels minus one.  ixyztw[1][0] is the
    first y pixel, and ixyztw[1][1] is the last y pixel.  After changing a
    primary input file, ixyztw[1][0] will be zero and ixyztw[1,1] will be the
    size of the y dimension in pixels minus one.  ixyztw[2][0] is the
    first z section, and ixyztw[2][1] is the last z section.  After changing a
    primary input file, ixyztw[2][0] will be zero and ixyztw[2][1] will be the
    number of z sections minus one.  ixyztw[3][0] is the first time point,
    ixyztw[3][1] is the last time point, and ixyztw[3][2] is the time point
    increment.  After changing a primary input file, ixyztw[3][0] will be
    zero, ixyztw[3][1] will be the number of time points minus one, and
    ixyztw[3][2] will be one.  ixyztw[<VAR>j</VAR>][0] where <VAR>j</VAR> is
    greater than three is the wavelength for the (<VAR>j</VAR>-3)rd channel.
    ixyztw[<VAR>j</VAR>][1] where <VAR>j</VAR> is greater than three is zero if
    the (<VAR>j</VAR>-3)rd channel has been selected for processing and
    is otherwise non-zero.  After changing a primary input file, the
    wavelengths will match the values in the header (to the nearest integer)
    and all wavelengths will be selected for processing (in the current
    implementation an exception is made for cases where the wavelength is
    less than or equal to 100 or greater than or equal to 999; in that case
    ixyztw[<VAR>j</VAR>][0] and ixyztw[<VAR>j</VAR>][1] are set to zero).
  <DT><STRONG>nxyztw</STRONG>
  <DD>Holds the dimensions of the file.  nxyztw[0] is the number of x pixels
    minus one.  nxyztw[1] is the number of y pixels minus one.  nxyztw[2] is
    the number of z sections minus one.  nxyztw[3] is the number of time points
    minus one.  nxyztw[4] is the number of wavelengths.
  <DT><STRONG>xyztw_size</STRONG>
  <DD>Holds printable versions of the full range of the file and the
    wavelengths.  xyztw_size[0] is the x range printed as 0:<VAR>n</VAR> where
    <VAR>n</VAR> is the number of x pixels minus one.  xyztw_size[1] is the y
    range printed as 0:<VAR>n</VAR> where <VAR>n</VAR> is the number of y
    pixels minus one.  xyztw_size[2] is the z range printed as 0:<VAR>n</VAR>
    where <VAR>n</VAR> is the number of z sections minus one.  xyztw_size[3]
    is the time range printed as 0:<VAR>n</VAR> where n is the number of time
    points minus one.  xyztw_size[<VAR>j</VAR>] where <VAR>j</VAR> is greater
    than three is the printed version of the wavelength for the
    (<VAR>j</VAR>-3)rd wavelength (if the wavelength is less than or equal to
    100 and greater than or equal to 999, the current implementation sets
    xyztw_size[<VAR>j</VAR>] to "   ").
  <DT><STRONG>mode</STRONG>
  <DD>Holds the <A HREF="IM_ref2.html#PixelDataTypes">pixel type</A> of the
    file.
  <DT><STRONG>dmin, dmax, and dmean</STRONG>
  <DD>Holds the minimum, maximum, and mean value, respectively, recorded for
    the first wavelength in the file's header.
  <DT><STRONG>delxyz</STRONG>
  <DD>Holds the pixel spacing recorded in the file's header.
</DL>

<P>If the function pointed to by <VAR>handle_file_proc</VAR> is to be called
because the user changed the bounds of the region, iparm will be negative one
if the x range changed, negative two if the y range changed, negative three if
the z range changed, negative four if the time range changed, or negative five
if the wavelengths selected changed.  The ixyztw field of the Iomenu structure
(see above for details) will hold the current region bounds.

<P>If the <VAR>handle_exit_proc</VAR> argument to iomenu() is not zero,
The iomenu utility calls the function pointed to by <VAR>handle_exit_proc</VAR>
when the user presses the button labeled "Exit" in the main dialog or when the
user force the application to exit via the window manager.  The iomenu utility
passes the function pointed to by <VAR>handle_exit_proc</VAR> a single
argument, the pointer to an Iomenu structure that you passed to iomenu().

<H3>Compiling and linking</H3>
<P>For compilation, iomenu.h is located in the INCLUDE directory of the
Priism distribution (i.e. Linux/x86/INCLUDE for x86 Linux systems,
Linux/x86_64/INCLUDE for x86_64 Linux systems, Darwin/INCLUDE for 32-bit
applications on Mac OS X systems, and Darwin64/INCLUDE for 64-bit applications
on Mac OS X systems).  For linking, you will need to link against the
libraries, libiomenu.a and either libive.a or libive.so, in addition to the
WM library (for details about linking with the WM library, see the
<A HREF="WM.html#CompilingLinking">Compiling and Linking section</A> of the
<A HREF="WM.html">WM library documentation</A>) and IM or IWL libraries
(for details about linking with the IM and IWL libraries, see the
<A HREF="IM_ref2.html#CompilingLinking">Compiling and Linking section</A> of
the <A HREF="IM_ref2.html">IM library documentation</A>.  For x86 Linux,
the libraries are in the Linux/x86/LIB directory of the Priism distribution.
For x86_64 Linux, the libraries are in the Linux/x86_64/LIB directory of the
Priism distribution.  For Mac OS X systems, the 32-bit libraries are in the
Darwin/LIB directory and the 64-bit libraries are in the Darwin64/LIB
directory of the Priism distribution.

<H3>Topics</H3>
<P>
   <A HREF="#Overview">Overview</A> |
   C details |
   <A HREF="#FortranDetails">Fortran details</A> |
   <A HREF="#ReleaseNotes">Release notes</A>
<HR>

<H2><A NAME="FortranDetails">Fortran Details</A></H2>
<H3>Example</H3>
<P>The file, <A HREF="../EXAMPLE/sample_iomenu_f.f">sample_iomenu_f.f</A>,
in the EXAMPLE directory of the Priism distribution demonstrates how to
use the iomenu utility from Fortran.  The
<A HREF="../EXAMPLE/makefile">makefile</A> in the same directory includes a
rule to build an executable from sample_iomenu_f.f.

<H3>Initializing the command-line parameter structure</H3>
<P>The command line generated by the iomenu utility has the form

<PRE>
    <VAR>application_name</VAR> <VAR>file1</VAR> ... <VAR>filen</VAR> \
        <VAR>switch1_label</VAR><VAR>switch1_values</VAR> ... \
        <VAR>switchn_label</VAR><VAR>switchn_values</VAR>
</PRE>

<P><VAR>file1</VAR> through <VAR>filen</VAR> are the required input
and output files for the application.  Each switch consists of a label
(customarily <CODE>-</CODE><VAR>name</VAR> if the switch has no values or
<CODE>-</CODE><VAR>name</VAR><CODE>=</CODE> if it has values) which may
(depending on the type of switch) be followed by a colon separated list
of values.  The Fortran iomenu interface can handle a maximum of 10 required
files and 19 switches.

<P>The contents of the command line are controlled by the entries in the
iomenu_struct structure passed to iomenu().  The iomenu_struct structure is
defined in iomenu.inc as

<PRE>
       structure /iomenu_struct/
           integer*4     itypes(2,20), ivals(40), ifiletype(11), iuser(20)
           real*4        rvals(20), ruser(20)
           character*256 cvals(10)
           character*80  labels(20), filelabels(10)
           character*256 filenames(10)
           character*80  filefilter(10)
           character*10  xyztw_size(9)
           integer*4     iparm, nxyztw(5), ixyztw(3, 9), mode
           real*4        dmin, dmax, dmean, delxyz(3)
       end structure
</PRE>

<P>The elements of the structure that you need to initialize before calling
iomenu() are:

<DL>
  <DT><STRONG>ifiletype</STRONG>
  <DD>Sets the number and type (input or output) of the required
    files.  ifiletype(<VAR>i</VAR>) sets the type of the <VAR>i</VAR>th file
    and must be one of the following values:
    <DL>
      <DT><STRONG>0</STRONG>
      <DD>Marks the end of the list, i.e. if ifiletype(<VAR>i</VAR>) is
        zero and no earlier element of ifiletype is zero, then there will
        be <VAR>i</VAR> minus one files printed at the start of the command
        line.
      <DT><STRONG>1</STRONG>
      <DD>Specifies that the file is a primary input file.  Before
        generating a script via the "Do It" button, the iomenu utility requires
        that the user specify the names of all primary input files and that
        those files must exist.  When the user changes the name of a primary
        input file from the user interface, the iomenu utility resets the
        processing region to cover the entire range of the input and updates
        the corresponding controls in the graphical user interface.  It resets
        the names of all the output files of type 3 so that they have the
        same name as the primary input followed by an extension specified by
        the element of the filefilter field for that output file.  The iomenu
        utility also resets the directory where the log and script files are
        written to be the same as the name of the directory containing the
        primary input file.  Because of those side effects, the typical case
        is to have exactly one primary input file (customarily the first one
        in the list).  More than one is possible, but may lead to confusion on
        the part of user.  Having zero primary input files is also possible,
        but the user interface is biased toward selecting a region from an
        existing file rather than specifying from scratch the bounds for a new
        file.  In addition, there is no direct way to specify the default
        values for the size if you do not have a primary input file:  as a
        crude hack, you could initialize the nxyztw, ixyztw, and xyztw_size
        fields (see the description of the custom_ifile() callback for details
        about those fields) from within the personal() or special_parameters()
        callbacks and then use WMUpdateGroup(1) to update the corresponding
        interface controls.
      <DT><STRONG>2</STRONG>
      <DD>Specifies that the file is a required input file (but not
        a primary input file which the iomenu utility uses to set the default
        region for processing and the default names for output and script
        files).  Before generating a script via the "Do It" button, the iomenu
        utility requires that the user specify the names of all required input
        files and that those files must exist.
      <DT><STRONG>3</STRONG>
      <DD>Specifies that the file is an output file.  When
        ifiletype(<VAR>i</VAR>) is three, the default name for that output
        file will be the name of the primary input file with the contents of
        filefilter(<VAR>i</VAR>) appended.  Before generating a script via the
        "Do It" button, the iomenu utility requires that all the files of type
        three have some sort of name specified.
      <DT><STRONG>4</STRONG>
      <DD>Specifies that the file is an output file but, unlike files of
        type three, the iomenu utility does not automatically generate a
        default name when the user selects a primary input file.  Before
        generating a script via the "Do It" button, the iomenu utility requires
        the all the files of type four have some sort of name specified.
    </DL>
  <DT><STRONG>filenames</STRONG>
  <DD>filenames(<VAR>i</VAR>) holds the name of the <VAR>i</VAR>th
    required file.  You would normally initialize the names for the files you
    use to be all spaces (or use an appropriate compiler switch to do so for
    you) except for input files of type two and output files of type three
    for which you have a reasonable default.
  <DT><STRONG>filelabels</STRONG>
  <DD>In the user interface, each required file has a
    corresponding button and text field; these controls appear at the top of
    the main dialog.  filelabels(<VAR>i</VAR>) sets the label on the button for
    the <VAR>i</VAR> button.  You should initialize the labels for the files
    you use to some short names indicating the nature of the file to be
    selected.
  <DT><STRONG>filefilter</STRONG>
  <DD>If ifiletype(<VAR>i</VAR>) is one or two,
    filefilter(<VAR>i</VAR>) is used as the selection pattern argument
    to <A HREF="WM.html#WMAddGetFile">WMAddGetFile</A> and should be
    initialized accordingly.  If ifiletype(<VAR>i</VAR>) is three,
    filefilter(<VAR>i</VAR>) is appended to the name of the primary input file
    to form the default name for the <VAR>i</VAR>th file.  If
    ifiletype(<VAR>i</VAR>) is four, the value of filefilter(<VAR>i</VAR>) is
    ignored.
  <DT><STRONG>itypes</STRONG>
  <DD>Defines the type and number of values associated with each
    command-line switch.  itypes(1,<VAR>i</VAR>) sets the number of parameters
    associated with the switch; the first value <VAR>j</VAR> where
    itypes(1,<VAR>j</VAR>) is less than zero terminates the list of switches
    (i.e. there will be <VAR>j</VAR> minus one switches printed on the
    command line).  itypes(2,<VAR>i</VAR>) is the type of the switch
    and must be one of the following:
    <DL>
      <DT><STRONG>1</STRONG><DD>The switch has itypes(1,<VAR>i</VAR>) integer
        values (the next itypes(1,<VAR>i</VAR>) values from the ivals field)
        associated with it.  When the switch is printed out for the command
        line, the integers are printed out in a colon-separated list
        immediately after the switch label.
      <DT><STRONG>2</STRONG><DD>The switch has itypes(1,<VAR>i</VAR>)
        floating-point values (the next itypes(1,<VAR>i</VAR>) values from
        the rvals field) associated with it.  When the switch is printed out
        for the command line, the floating-point values are printed out in a
        colon-separated list immediately after the switch label.
      <DT><STRONG>3</STRONG><DD>The switch has one integer (the next element
        from the ivals field) associated with it.  If that value is not zero
        when the command line is printed, then labels(<VAR>i</VAR>) will be
        printed on the command line (without any values following it); if that
        value is zero when the command line is printed, then
        labels(<VAR>i</VAR>) will not be printed.
      <DT><STRONG>-3</STRONG><DD>The switch has one integer (the next element
        from the ivals field) associated with it.  If that value is zero
        when the command line is printed, then labels(<VAR>i</VAR>) will
        be printed on the command line (without any values following it);
        if that value is not zero when the command line is printed, then
        labels(<VAR>i</VAR>) will not be printed.
      <DT><STRONG>4</STRONG><DD>The switch has itypes(1,<VAR>i</VAR>)
        character arrays (the next itypes(1,<VAR>i</VAR>) elements from the
        cvals field) associated with it.  When the switch is printed out for
        the command line, the contents of those character arrays (for each
        array the trailing spaces and null characters are trimmed and the
        result is then enclosed in double quotes) will be printed out as
        a colon-separated list immediately after the switch label.
    </DL>
  <DT><STRONG>labels</STRONG>
  <DD>labels(<VAR>i</VAR>) specifies the switch name printed on the command
    line for the <VAR>i</VAR>th switch.  If itypes(2,<VAR>i</VAR>) is one,
    two, or four, the switch name, by convention, would have the form
    <CODE>-</CODE><VAR>name</VAR><CODE>=</CODE>.  If itypes(2,<VAR>i</VAR>)
    is three or negative three, a conventional switch name would have the
    form <CODE>-</CODE><VAR>name</VAR>.
  <DT><STRONG>ivals</STRONG>
  <DD>Holds the values associated with switches of types one, three, and
    negative three.  Because ivals has forty elements, you are limited to
    at most forty integer values for the command line.
  <DT><STRONG>rvals</STRONG>
  <DD>Holds the values associated with switches of type two.  Because rvals has
    twenty elements, you are limited to at most twenty floating-point values
    for the command line.
  <DT><STRONG>cvals</STRONG>
  <DD>Holds the values associated with switches of type three.  Because cvals
    has ten elements, you are limited to at most ten character array values
    for the command line.
  <DT><STRONG>ixyztw</STRONG>
  <DD>Unless you compile your application so that the structure values are
    initialized to zero, set ixyztw(1,<VAR>i</VAR>) and ixyztw(2,<VAR>i</VAR>)
    to zero for values of <VAR>i</VAR> from one to nine.  For more details
    about the ixyztw field, see the description of the custom_ifile callback.
  <DT><STRONG>nxyztw</STRONG>
  <DD>Unless you compile your application so that the structure values are
    initialized to zero, set nxyztw(<VAR>i</VAR>) to zero for values of
    <VAR>i</VAR> from one to five.  For more details about the nxyztw field,
    see the description of the custom_ifile callback.
</DL>

<H3>Calling iomenu_set_region_controls()</H3>
<P>To limit the region selection controls displayed, call
iomenu_set_region_controls() before calling iomenu().  Calling
iomenu_set_region_controls() after calling iomenu() has no effect.

<P>The iomenu_set_region_controls() function is declared as

<PRE>
    subroutine iomenu_set_region_controls(istyle)
    integer istyle
</PRE>

<P><VAR>istyle</VAR> is expected to be one of the following constants
which are declared in iomenu.inc:

<DL>
  <DT><STRONG>IOMENU_REG_CTRL_ALL</STRONG><DD>Display all region selection
    controls.  This is the default behavior.
  <DT><STRONG>IOMENU_REG_CTRL_5D_SIZE</STRONG><DD>Only display an indicator
    with the size of the five dimensions of the primary image input file.
  <DT><STRONG>IOMENU_REG_CTRL_3D_SIZE</STRONG><DD>Only display an indicator
    with the size of the x dimension, size of the y dimension, and the number
    of sections for the primary image input file.
</DL>

<H3>Configuring the interaction with the queues</H3>
<P>It is possible to customize the selection of the default queue, which
queues are listed as available, and whether or not to receive a callback when
the user changes the destination queue.  The related function calls are
iomenu_set_int_property() and iomenu_set_queue_callback().
iomenu_set_int_property() is declared as

<PRE>
    integer function iomenu_set_int_property(prop, i)
    character*(*) prop
    integer i
</PRE>

<P>iomenu_set_int_property() associates the given integer value, <VAR>i</VAR>,
with the name, <VAR>prop</VAR>.  It returns zero when successful and a
non-zero value when not successful.  The property names that are relevant
for customizing the queue behavior are:

<DL>
  <DT><STRONG>DEFAULT_QUEUE_TYPE</STRONG><DD>If the related integer value is
    zero, the default destination is the local machine.  If the related integer
    value is one, the default destination is the queue that has been
    designated as the default destination for serial (single processor) jobs.
    If the related integer value is two, the default destination is the queue
    that has been designated as the default destination for parallel
    (multiprocessor) jobs that may run on multiple hosts.  If the related
    integer value is three, the default destination is the queue that has been
    designated as the default destination for GPU jobs.  If the related integer
    value is four, the default destination is the queue that has been
    designated as the default destination for parallel (multiprocessor) jobs
    that can only use a single host.  The default value of this property is
    one.  Modifying this property after calling iomenu() will have no effect on
    the internal behavior of the iomenu library.
  <DT><STRONG>QUEUE_SUBSET</STRONG><DD>The related integer value, <VAR>v</VAR>,
    defines which queues to include in the list in the user interface.  A
    queue will be included if the bitwise-and of the queue's value (a
    bitwise-or of one (if the queue accepts parallel jobs which may run on
    multiple hosts), two (if the queue accepts serial jobs), and four (if the
    queue accepts GPU jobs), and eight (if the queue accepts parallel jobs
    which can only use a single host)) with the ones-complement of
    <VAR>v</VAR> is non-zero.  The default value of this property is 13.
    Modifying this property after calling iomenu() will have no effect on the
    internal behavior of the iomenu library.
</DL>

<P>iomenu_set_queue_callback() is declared as

<PRE>
    subroutine iomenu_set_queue_callback(func);
    external func
</PRE>

<P>iomenu_set_queue_callback() instructs the IOMENU library to call the
subroutine func when the user changes the destination queue.  The IOMENU
library passes a single argument, a reference to the same iomenu_struct that
was passed to iomenu(), to the callback.    To get a handle to the properties
of the current queue (from within the callback for a queue change or any other
time after iomenu() has been called), use iomenu_get_current_queue().
iomenu_get_current_queue() is declared as

<PRE>
    integer function iomenu_get_current_queue()
</PRE>

<P>To get the properties from the handle, use the functions described in
the iveqd.h header file.  When a queue changes, you may want to change
the number of processors to use when submitting a job.  To do so use
iomenu_set_int_property() with "QUEUE_NPROC" as the name and the number of
processors as the integer value; a value of zero or less for the number of
processors will select the default number of processors for that queue.

<H3>Calling iomenu()</H3>
<P>The iomenu() subroutine is declared as

<PRE>
       subroutine iomenu(<VAR>title</VAR>, <VAR>submenu</VAR>, <VAR>iroot</VAR>, <VAR>iom</VAR>)
       character <VAR>title</VAR>*(*), <VAR>submenu</VAR>*(*), <VAR>iroot</VAR>*(*)
       record /iomenu_struct/ <VAR>iom</VAR>
</PRE>

<P>The arguments are:

<DL>
  <DT><VAR>title</VAR>
  <DD><VAR>title</VAR> is the name that will appear on the title bar of the
    main dialog.
  <DT><VAR>submenu</VAR>
  <DD>The iomenu utility can display a button in the main dialog that will
    open a child dialog.  The most common use for this is to group rarely
    changed parameters in this child dialog.  <VAR>submenu</VAR> is the
    name that will appear on the button in the main dialog to open the
    child dialog.  If <VAR>submenu</VAR> is a character array which only
    contains spaces or null characters or %LOC(<VAR>submenu</VAR>) is equal to
    zero, the button to open the child dialog will not be created.
  <DT><VAR>iroot</VAR>
  <DD><VAR>iroot</VAR> is the name of the command-line application to run.
    If <VAR>iroot</VAR> does not begin with / and the environment variable
    IVE_ENV_SETUP is not set, the iomenu utility will prepend <VAR>iroot</VAR>
    with the name of the Priism executable directory when running the
    script file.  <VAR>iroot</VAR> is also used as the base for the default
    names of the script and log files as well as the base for the name used
    when saving or restoring the current contents of the dialog via the Save
    and Restore buttons.
  <DT><VAR>iom</VAR>
  <DD>Is a instance of the iomenu_struct structure (defined in iomenu.inc) 
    which defines the command-line parameters.
</DL>

<H3>Callbacks</H3>
<P>The Fortran interface to the iomenu utility expects you to define four
other subroutines:  personal(), special_parameters(), custom_ifile(), and
call_exit().

<P>The iomenu utility calls personal() after it has initialized the WM library
(with <A HREF="WM.html#WMInit">WMInit</A>), and added the controls for the
required files and the region bounds to the main dialog.  After calling
personal(), the iomenu utility will complete the main dialog by adding an
optional button to open a child dialog (see the description of the
<VAR>submenu</VAR> argument to iomenu() for more information) and a series of
buttons, labeled "Exit", "Save", "Restore", "Options", and "Do It", at the
bottom of the dialog.  The iomenu utility passes personal() a single argument,
the instance of the iomenu_struct structure that you passed to iomenu().  If
you need to pass additional information to the personal() subroutine you can
use the iuser and and ruser elements of the iomenu_struct structure or use
common blocks.  Normally, you would use personal() to add the graphical user
interface components to the main dialog that are necessary to control the
command-line switches you defined in the iomenu_struct structure.

<P>special_parameters() is only called if the <VAR>submenu</VAR> argument
to iomenu() was a character array that did not contain only spaces or null
characters.  The iomenu utility calls special_parameters() after if has created
the main dialog and initialized an empty child dialog.  After calling
special_parameters(), the iomenu utility will add a button, labeled
"OK", for closing the child dialog; the iomenu utility will then enter
the loop to process user interactions.  The iomenu utility passes
special_parameters() a single argument, the instance of the iomenu_struct
structure that you passed to iomenu().  If you need to pass additional
information to the special_parameters() subroutine you can use the iuser and
and ruser elements of the iomenu_struct structure or use common blocks.
Normally, you would use special_parameters() to add the graphical user
interface components that you did not put in the main dialog.

<P>The iomenu utility calls custom_ifile() when the user changes the name of
one of the required files or changes the bounds of the region to process.
The iomenu utility passes custom_ifile() a single argument, the instance
of the iomenu_struct structure that you passed to iomenu().  If you need to
pass additional information to the custom_ifile() subroutine you can use the
iuser and and ruser elements of the iomenu_struct structure or use common
blocks.  Before calling custom_ifile(), the iomenu utility changes the value
of the iparm field in the iomenu_struct structure.  If custom_ifile() is to be
called because the user changed one of the names of the required files, the
iomenu utility sets iparm to the index of that file in the ifiletype and
filenames array.  If the file changed was a primary input file, the iomenu
utility will also read the header of that file and reset the following fields
of the iomenu_struct structure:

<DL>
  <DT><STRONG>ixyztw</STRONG>
  <DD>ixyztw holds the bounds of the region to process.  ixyztw(1,1) is the
    first x pixel, and ixyztw(2,1) is the last x pixel.  After changing a
    primary input file, ixyztw(1,1) will be zero and ixyztw(2,1) will be the
    size of the x dimension in pixels minus one.  ixyztw(1,2) is the
    first y pixel, and ixyztw(2,2) is the last y pixel.  After changing a
    primary input file, ixyztw(1,2) will be zero and ixyztw(2,2) will be the
    size of the y dimension in pixels minus one.  ixyztw(1,3) is the
    first z section, and ixyztw(2,3) is the last z section.  After changing a
    primary input file, ixyztw(1,3) will be zero and ixyztw(2,3) will be the
    number of z sections minus one.  ixyztw(1,4) is the first time point,
    ixyztw(2,4) is the last time point, and ixyztw(3,4) is the time point
    increment.  After changing a primary input file, ixyztw(1,4) will be
    zero, ixyztw(2,4) will be the number of time points minus one, and
    ixyztw(3,4) will be one.  ixyztw(1,<VAR>j</VAR>) where <VAR>j</VAR> is
    greater than four is the wavelength for the (<VAR>j</VAR>-4)th channel.
    ixyztw(2,<VAR>j</VAR>) where <VAR>j</VAR> is greater than four is zero if
    the (<VAR>j</VAR>-4)th channel has been selected for processing and
    is otherwise non-zero.  After changing a primary input file, the
    wavelengths will match the values in the header (to the nearest integer)
    and all wavelengths will be selected for processing (in the current
    implementation an exception is made for cases where the wavelength is
    less than or equal to 100 or greater than or equal to 999; in that case
    ixyztw(1,<VAR>j</VAR>) and ixyztw(2,<VAR>j</VAR>) are set to zero).
  <DT><STRONG>nxyztw</STRONG>
  <DD>Holds the dimensions of the file.  nxyztw(1) is the number of x pixels
    minus one.  nxyztw(2) is the number of y pixels minus one.  nxyztw(3) is
    the number of z sections minus one.  nxyztw(4) is the number of time points
    minus one.  nxyztw(5) is the number of wavelengths.
  <DT><STRONG>xyztw_size</STRONG>
  <DD>Holds printable versions of the full range of the file and the
    wavelengths.  xyztw_size(1) is the x range printed as 0:<VAR>n</VAR> where
    <VAR>n</VAR> is the number of x pixels minus one.  xyztw_size(2) is the y
    range printed as 0:<VAR>n</VAR> where <VAR>n</VAR> is the number of y
    pixels minus one.  xyztw_size(3) is the z range printed as 0:<VAR>n</VAR>
    where <VAR>n</VAR> is the number of z sections minus one.  xyztw_size(4)
    is the time range printed as 0:<VAR>n</VAR> where n is the number of time
    points minus one.  xyztw_size(<VAR>j</VAR>) where <VAR>j</VAR> is greater
    than four is the printed version of the wavelength for the
    (<VAR>j</VAR>-4)th wavelength (if the wavelength is less than or equal to
    100 and greater than or equal to 999, the current implementation sets
    xyztw_size(<VAR>j</VAR>) to "___").
  <DT><STRONG>mode</STRONG>
  <DD>Holds the <A HREF="IM_ref2.html#PixelDataTypes">pixel type</A> of the
    file.
  <DT><STRONG>dmin, dmax, and dmean</STRONG>
  <DD>Holds the minimum, maximum, and mean value, respectively, recorded for
    the first wavelength in the file's header.
  <DT><STRONG>delxyz</STRONG>
  <DD>Holds the pixel spacing recorded in the file's header.
</DL>

<P>If custom_ifile() is to be called because the user changed the bounds of the
region, iparm will be negative one if the x range changed, negative two if the
y range changed, negative three if the z range changed, negative four if the
time range changed, or negative five if the wavelengths selected changed.
The ixyztw field of the iomenu_struct structure (see above for details) will
hold the current region bounds.

<P>The iomenu utility calls call_exit() when the user presses the button
labeled "Exit" in the main dialog.  The iomenu utility passes call_exit() a
single argument, the instance of the iomenu_struct structure that you passed
to iomenu().  If you need to pass additional information to the call_exit()
subroutine you can use the iuser and and ruser elements of the iomenu_struct
structure or use common blocks.  In the current implementation, call_exit() is
not called when the user exits the application via the window manager (you
would have to call <A HREF="WM.html#WMSetExitFunction">WMSetExitFunction</A>
from within the personal() or special_parameters() routines if you wanted to
trap that case).

<H3>Compiling and linking your application</H3>
<P>For compilation, iomenu.inc is located in the INCLUDE directory of the
Priism distribution (i.e. Linux/x86/INCLUDE for x86 Linux systems and
Darwin/INCLUDE for Mac OS X systems).  For linking, you will need to link
against the libraries, libiomenu.a, libimcompat.a and either libive.a or
libive.so in addition to the WM library (for details about linking with the WM
library, see the
<A HREF="WM.html#CompilingLinking">Compiling and Linking section</A> of the
<A HREF="WM.html">WM library documentation</A>) and IM or IWL libraries
(for details about linking with the IM and IWL libraries, see the
<A HREF="IM_ref2.html#CompilingLinking">Compiling and Linking section</A> of
the <A HREF="IM_ref2.html">IM library documentation</A>.  For x86 and
x86_64 Linux systems, two versions of libiomenu.a and libimcompat.a are
available.  The libraries in the Linux/x86/LIB directory (for x86 systems) and
the libraries in the Linux/x86_64/LIB directory (for x86_64 systems) were
compiled with version 9 of the Intel Fortran compiler.  The libraries in the
Linux/x86/LIB/pg directory (for x86 systems) and the libraries in the
Linux/x86_64/LIB/pg directory (for x86_64 systems) were compiled with version
10.2 of the Portland Group Fortran compiler.  When linking with the versions
for the Intel Fortran compiler, you you will also need to link against Intel's
libifport (i.e. include <CODE>-lifport</CODE> in the linker options after the
reference to libimcompat.a).  For Mac OS X systems, two versions of libiomenu.a
and libimcompat.a are available.  The versions in the Darwin/LIB directory of
the Priism distribution are for the Absoft compiler (if you are using a PowerPC
system) or Intel compiler (if you are using an Intel system).  When using
the Absoft compiler, you will need to specify the -N15 and -f compiler options
which force external names to be all lower case with an underscore appended.
You will also need to link with Absoft's U77 library when linking with
libimcompat.a (i.e. with a <CODE>-lU77</CODE> in the linker options after the
reference to libimcompat.a).  Version 8 of the Absoft compiler was used to
generate the library.  When using the Intel compiler, you will need to
link against Intel's libifport when linking with libimcompat.a (i.e. include
<CODE>-lifport -lifcore -limf -lirc</CODE> in the linker options after the
reference to libimcompat.a).  Version 10.1 of the Intel compiler was used to
generate the library.  The versions in the Darwin/LIB/xlf directory of
the Priism distribution are for the IBM XL Fortran compiler.  To use them, you
will need to compile with the IBM XL Fortran compiler with the -qextname
option.

<H3>Topics</H3>
<P>
   <A HREF="#Overview">Overview</A> |
   <A HREF="#CDetails">C details</A> |
   Fortran details |
   <A HREF="#ReleaseNotes">Release notes</A>
<HR>

<H2><A NAME="ReleaseNotes">Release Notes</A></H2>
<P>In 4.3.0, added IOMENU_REG_CTRL_XY_ONY, IOMENU_REG_CTRL_4D_NO_Z,
IOMENU_REG_CTRL_4D_NO_W, and IOMENU_REG_CTRL_4D_NO_T as styles supported
by iomenu_set_region_controls().

<P>In 4.2.9, changed to use version 10.2 of the Portland Group compiler for
the binaries in the LIB/pg subdirectory.

<P>In 4.2.7, changed to use version 10.1 of the Intel Fortran compiler for the
i386 part of Darwin/LIB/iomenu.a rather than version 9 of the Intel Fortran
compiler.

<P>In 4.2.6, changed to use version 9 of the Intel Fortran compiler for
Linux/x86/LIB/iomenu.a in the x86 versions rather than version 3.2-3 of the
Portland Group compiler.  Added versions of libiomenu.a in the LIB/pg
subdirectory which were compiled with version 7.2-5 of the Portland Group
compiler for x86 and x86_64 Linux systems.

<P>In 4.2.3, dropped the version of libiomenu.a for version 7 of the Intel
Fortran compiler on x86 Linux.
<P>Added iomenu_get_current_queue(), iomenu_set_int_property(), and
iomenu_set_queue_callback() in 4.2.2.

<P>Versions from IVE 4.2.2 and later no longer provide an iomenu.o for
backwards compatibility with IVE 3.3; link against libiomenu.a instead.

<P>Fortran applications linking to the library in IVE 4.2.2 or later will
also have to link against libive.a or libive.so.

<P>Added iomenu_set_region_controls() in 4.2.0.

<P>The C interface was added in IVE 4.1.8.  Prior versions had a different
version of iomenu.h but only a Fortran subroutine interface.

<P>In IVE 4.1.2, expanded the cvals and filenames arrays in the iomenu_struct
structure to have elements that are 256 characters long.  Previous IVE 4
versions and all IVE 3.3 versions have elements that are eighty characters
long.

<P>The location of the libraries and include files is different than in IVE 3.3
(in IVE 3.3 the libraries are in the LIB directory of the Priism distribution
and the include files are in the INCLUDE directory of the Priism distribution).
Older versions of IVE 3.3 (prior to March 2004) do not have libiomenu.a:  the
Fortran interface is in iomenu.o.

<P>Use of the QDEFAULT environment variable, described in the
<A HREF="BatchRegion.html#queue">Queue section of BatchRegion.html</A>, was
added in 4.1.2.  Use of QUECOM environment variable, also described in the
<A HREF="BatchRegion.html#queue">Queue section of BatchRegion.html</A>, was
added in the August 2000 version of IVE 3.3 and has always been in the IVE 4
version.  Use of the IVE_ENV_SETUP environment variable was added in the
June 1999 versions of IVE 3.3 and has always been in the IVE 4 version.

<H3>Topics</H3>
<P>
   <A HREF="#Overview">Overview</A> |
   <A HREF="#CDetails">C details</A> |
   <A HREF="#FortranDetails">Fortran details</A> |
   Release notes
<HR>

</BODY>
</HTML>

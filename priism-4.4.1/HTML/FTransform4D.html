<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <TITLE>Priism Help: 4D Fourier Transform</TITLE>
  <META NAME="Description" CONTENT="On-line help for Priism's application to perform a 4D Fourier transform.">
  <META NAME="Keywords" CONTENT="Priism,Fourier transform">
  <LINK REV=MADE HREF="mailto:ive@msg.ucsf.edu">
</HEAD>
<BODY>

<H1><A NAME="FTransform4D">4D Fourier Transform</A></H1>
<H2>Overview</H2>

<P>This program will perform a 4D Fourier transform to each wavelength (x, y,
z, and time block) in the input with the option to process the data beforehand
to remove trends and smooth discontinuities at the edges.

<P>The controls in the user interface include a
<A HREF="Region.html">standard set of controls</A> for selecting the input
file, output file, and region of interest and for starting and interrupting
processing.  The other controls are organized as follows:

<UL>
  <LI>The direction of the transform and form of the output is controlled by
    the three toggles just below the standard output mode and region selection
    controls.  When the input data is real, the direction of the transform is
    always forward, but the output can be fully complex and have both positive
    and negative x frequencies present in the output or just have non-negative
    frequencies present.  In the latter case there is no loss of information
    since the dropped data at (kx,ky,kz,kt) is just the complex conjugate of
    the data at (-kx,-ky,-kz,-kt).  When the input data is complex there are
    more options:
    <UL>
      <LI>When the <EM>Fully complex</EM> toggle is off, a reverse transform is
        performed to get a purely real result.  There is however an ambiguity
        about whether the result should have an even or odd number of pixels
        in x.  If the input data after padding which was supplied to the
        forward transform had an even number of pixels in x, turn on the
        <EM>Even X</EM> toggle; otherwise, turn it off.
      <LI>When the <EM>Fully complex</EM> is on, the transform direction can
        be either forward or reverse depending on how the <EM>Forward</EM>
        toggle is set.
    </UL>
  <LI>Use the <EM>Zero frequency centered</EM> toggle button to control
    the convention for the location of the zero frequency.  If the toggle
    button is off, the zero frequency is at (0,0,0) (if a reverse transform,
    this is relative to the selected input region); otherwise the zero
    frequency is at (0, (ny - 1) / 2, (nz - 1) / 2, (nt - 1) / 2) for real to
    complex or complex to real transforms and at
    ((nx - 1) / 2, (ny - 1) / 2, (nz - 1) / 2, (nt - 1) / 2) for complex to
    complex transforms.  For a forward transform, nx, ny, nz, and nt are the
    input dimensions after padding; for a reverse transform, nx, ny, nz, and
    nt are the input dimensions.
  <LI>If the <EM>Convert units</EM> toggle button is on, FTransform4D
    converts the units of the pixel spacing (i.e. from spatial units to
    frequency units during a forward transform and vice versa during a reverse
    transform) and sets the origin in the same units (on a reverse transform,
    the information about the spatial origin is not longer available and
    FTransform4D sets the origin to zero).  If the <EM>Convert units</EM>
    toggle button is off, FTransform4D does not modify the pixel spacing values
    and only modifies the origin values to reflect region selection during a
    forward transform.
  <LI>Use the <A HREF="#Shift">Shift field</A> to specify a translation
    that is applied in conjunction with the transformation.  For a forward
    transform, a shift of (<VAR>x</VAR>, <VAR>y</VAR>, <VAR>z</VAR>) will
    cause pixel (<VAR>x</VAR>, <VAR>y</VAR>, <VAR>z</VAR>) to be shifted to
    the origin, (0,0,0).  For a reverse transform, the same shift will place
    what would appear at the origin, (0,0,0), at pixel (<VAR>x</VAR>,
    <VAR>y</VAR>, <VAR>z</VAR>).
  <LI>Use the <A HREF="#Preprocessing">button labeled "Set preprocessing"</A>
    to display and change the parameters which control the processing of the
    data before it is padded and transformed.  Preprocessing can only be done
    before forward transforms.  By default, no preprocessing is done.
  <LI>Use the <A HREF="#Window">button labeled "Set window/taper"</A> to
    select a function used to smooth out discontinuities at the edges of the
    data after preprocessing and before padding and transforming the data.
    This option is only available if a forward transform is done.  By default,
    no smoothing is done.
  <LI>Use the <A HREF="#Edges">button labeled "Set edge handling"</A>
    to control the number and values of the elements that are appended to
    the input region before the transform.  By default, for a forward transform
    the input data is padded with zeroes so that it is a size which can be
    efficiently processed and on the reverse transform the data is not padded.
  <LI>Use the <A HREF="#OutputSize">button labeled "Set output size"</A>
    to open a dialog with the controls for trimming the output region.
    Trimming can only be done when a reverse transform is applied.  By
    default, no trimming is done.
</UL>

<P>Because of the nature of the Fourier transform, the handling of the
data header is different than most other Priism applications:

<UL>
  <LI>The pixel format for the output is always complex when a forward
    transform is used, and may be complex or real when the reverse transform
    is used.
  <LI>When the <EM>Convert units</EM> toggle button is on, the pixel spacing,
    origin, and start indices are modified as follows:
    <UL>
      <LI>The pixel spacing is 1 / (nx * dx), 1 / (ny * dy), and
        1 / (nz * dz).  dx, dy, and dz are the input pixel spacing.  For a
        forward transform, nx, ny, and nz are the dimensions, in pixels, of
        the input region plus any padding.  For a reverse transform, nx, ny,
        and nz are the dimensions, in pixels, after the transform but before
        the output is trimmed.
      <LI>The coordinates for the origin are set to zero for reverse
        transforms or for forward transforms when the zero frequency is not
        centered.  For forward transforms where the zero frequency is
        centered, the coordinates for the for the origin are set to the most
        negative frequencies present, in units of the output pixel spacing.
      <LI>The start indices in the header are set to zero.
    </UL>
  <LI>When the <EM>Convert units</EM> toggle button is off, the pixel spacing
    does not change.  For a forward transform, the origin and start indices
    are adjusted to account for the region selected for processing.  For
    a reverse transform, the origin and start indices are not modified.
</UL>

<P>The Fourier transforms calculated have these properties:

<UL>
  <LI>If the <EM>Zero frequency centered</EM> toggle button is off, the
    zero frequency component is at (0,0,0,0) (the lower left corner) after a
    forward transform, and the component at positive Nyquist in all four
    directions is at (nx / 2, ny / 2, nz / 2, nt / 2) where nx, ny, nz,
    and nt are the input dimensions after padding.  If the <EM>Zero frequency
    centered</EM> toggle button is on and the transform is real to complex, th
    zero frequency component is at (0, (ny - 1) / 2, (nz - 1) / 2,
    (nt - 1) / 2), and the component at positive Nyquist in all four directions
    is at (nx / 2, ny - 1, nz - 1, nt - 1).  If the <EM>Zero frequency
    centered</EM> toggle button is on and the transform is complex to complex
    in the forward direction, the zero frequency component is at
    ((nx - 1) / 2, (ny - 1) / 2, (nz - 1) / 2, (nt - 1) / 2), and the
    component at positive Nyquist in all four directions is at
    (nx - 1, ny - 1, nz - 1).
  <LI>When the forward transform is applied, the result is divided by the
    number of pixels in the region.  If the data was
    <A HREF="#Window">tapered</A> it is also further scaled by a factor such
    that, if the input had on average a zero mean, the tapering operation
    would, on average, not change the variance of the data.
  <LI>The sign used in the complex exponential is negative for the forward
    transform and positive for the reverse transform.
</UL>

<H3>Topics</H3>
<P>
  Overview |
  <A HREF="Region.html">Region processing</A> |
  <A HREF="#Shift">Shift</A> |
  <A HREF="#Preprocessing">Preprocessing</A> |
  <A HREF="#Window">Window/taper</A> |
  <A HREF="#Edges">Edge handling</A> |
  <A HREF="#OutputSize">Output size</A> |
  <A HREF="#CommandLine">Command line</A>

<H3>Related Priism Topics</H3>
<P>
   <A HREF="Priism.html">Priism</A> |
   <A HREF="FTransform2D.html">2D Fourier Transform</A>

<HR>

<H2><A NAME="Shift">Shift</A></H2>
<P>The <EM>Shift</EM> field specifies a translation, measured in pixels,
that is applied in conjunction with the transform.  The translation is
circular in the sense that something which is pushed off one side wraps
around to the opposite side.

<P>When a forward transform is performed, a shift of (<VAR>x</VAR>,
<VAR>y</VAR>, <VAR>z</VAR>) moves pixel (<VAR>x</VAR>, <VAR>y</VAR>,
<VAR>z</VAR>, <VAR>t</VAR>) to the origin, (0,0,0,0).  For a reverse
transform, the same shift will place what would appear at the origin,
(0,0,0,0), at pixel (<VAR>x</VAR>, <VAR>y</VAR>, <VAR>z</VAR>, <VAR>t</VAR>).

<P>There is a potential problem using non-integral shifts and transforms
performed with the <EM>Fully complex</EM> button turned off.  If a shift
along a coordinate axis is non-integral and that dimension has an even
number of samples in the real domain after padding (but before stripping
padding on the reverse transform), the matrix of the phase shifts will not
correspond to the Fourier transform of a real-valued function (i.e. it will not
be Hermitian).  If your data does not have power in the frequency components at
Nyquist in that direction (or all the other dimensions have a size of one),
then that does not matter.  Otherwise, the result of applying the shift will
deviate from the expected result, the Fourier series evaluated at the shifted
coordinate values.  One solution is to apply the shifts in combination with
a fully complex transform, and then extract the real component
(<A HREF="CopyRegion.html">Copy Region</A> can do that if you tell it to
convert the copied data to floating-point) after the data is reverse
transformed.  Another solution is to ensure that all the dimensions have an
odd number of samples in the real domain after padding.

<H3>Topics</H3>
<P>
  <A HREF="#FTransform4D">Overview</A> |
  <A HREF="Region.html">Region processing</A> |
  Shift |
  <A HREF="#Preprocessing">Preprocessing</A> |
  <A HREF="#Window">Window/taper</A> |
  <A HREF="#Edges">Edge handling</A> |
  <A HREF="#OutputSize">Output size</A> |
  <A HREF="#CommandLine">Command line</A>
<HR>

<H2><A NAME="Preprocessing">Preprocessing</A></H2>
<P>The input region can be processed to remove an offset or trend before
the data is tapered, padded, and transformed.  To display the controls for
this processing, press the button labeled <EM>Set preprocessing</EM> in the
main dialog.  There are five types of processing that can be done; select
one by pressing the appropriate toggle in the dialog.  The processing options
are:

<DL>
  <DT>None<DD>The input is not modified before padding and transforming the
    data.
  <DT>Subtract offset<DD>The specified value is subtracted from all the input
    values.
  <DT>Subtract mean<DD>For the selected region in each wavelength, the mean of
    the selected region is subtracted from all values.
  <DT>Remove linear trend<DD>An average slope for each wavelength is estimated
    estimated by averaging values from the first and last third of each
    dimension; the linear trend corresponding to that average slope and
    the mean of the region is subtracted from the input data.  The algorithm
    used is the average slope method extended to four dimensions (Digital data
    analysis procedures, Bendat and Piersol, 1st Edition, 1971, page 288).
  <DT>Remove trends up to order<DD>A polynomial of the given order is fit to
    each wavelength.  That polynomial evaluated at each input point is
    then subtracted from the input before padding and transforming the data.
</DL>

<P>If you are intending to taper the data and the data does not already have
a zero mean, you should consider using the mean subtraction, linear trend
removal, or polynomial fit options.

<H3>Topics</H3>
<P>
  <A HREF="#FTransform4D">Overview</A> |
  <A HREF="Region.html">Region processing</A> |
  <A HREF="#Shift">Shift</A> |
  Preprocessing |
  <A HREF="#Window">Window/taper</A> |
  <A HREF="#Edges">Edge handling</A> |
  <A HREF="#OutputSize">Output size</A> |
  <A HREF="#CommandLine">Command line</A>
<HR>

<H2><A NAME="Window">Window/taper</A></H2>
<P>Applying a windowing function, also called tapering, multiplies the
data by a function which goes to zero (or near zero) at the edges of the
data.  This is done before the forward transform to remove discontinuities
at the edges which can complicate the interpretation of frequency spectra;
the disadvantage of applying a window is that it essentially throws away
parts of the input and it broadens features in the spectra.

<P>The windowing functions used are separable, i.e, the windowing function,
W(x,y,z,t), can be written as the product of WX(x), WY(y), WZ(z), and WT(t).
WX, WY, WZ, and WT are calculated from the same formula but with different
inputs for the number of pixels, n, and the fraction, f, of the dimension that
is attenuated by the windowing function.  The four values in the
<EM>Coverage</EM> field are the values of f divided by two for the x, y,
z, and time directions, respectively.  Commonly used values for the
coverage are 0.5 (a "full taper") and 0.1 (a 10% taper).  The power, x, is
used by half-sine windowing function.

<P>The functions used to calculate the windowing functions are shown below.
i is the pixel index and runs from 0 to n minus 1, and e is given by

<PRE>
      { floor(0.5 + f / 2.0 * n)          n even
  e = {
      { floor(0.5 + f / 2.0 * (n - 1))    n odd
</PRE>

<H3>Rectangular</H3>
<PRE>
         { 0     i &lt; e
  w(i) = { 1     e &lt;= i &lt;= n - e
         { 0     i &gt; n - e
</PRE>
<P>Because of the sharp cutoffs of the rectangular window, it is
not particularly useful; it's provided for completeness.

<H3>Triangular</H3>
<PRE>
         { i / e           i &lt; e
  w(i) = { 1               e &lt;= i &lt;= n - e
         { (n - i) / e     i &gt; n - e
</PRE>

<H3>Half-sine^power</H3>
<PRE>
         { (sin(pi * i / (2 * e)))^x           i &lt; e
  w(i) = { 1                                   e &lt;= i &lt;= n - e
         { (sin(pi * (n - i) / (2 * e)))^x     i &gt; n - e
</PRE>

<H3>Hamming</H3>
<PRE>
         { 0.54 - 0.46 * cos(pi * i / e)           i &lt; e
  w(i) = { 1                                       e &lt;= i &lt;= n - e
         { 0.54 - 0.46 * cos(pi * (n - i) / e)     i &gt; n - e
</PRE>

<H3>Blackman</H3>
<PRE>
         { cos(pi * i / e)           i &lt; e
  a(i) = { -1                        e &lt;= i &lt;= n - e
         { cos(pi * (n - i) / e)     i &gt; n - e

  w(i) = 0.34 - a(i) * (0.5 - a(i) * 0.16)
</PRE>

<H3>Topics</H3>
<P>
  <A HREF="#FTransform4D">Overview</A> |
  <A HREF="Region.html">Region processing</A> |
  <A HREF="#Shift">Shift</A> |
  <A HREF="#Preprocessing">Preprocessing</A> |
  Window/taper |
  <A HREF="#Edges">Edge handling</A> |
  <A HREF="#OutputSize">Output size</A> |
  <A HREF="#CommandLine">Command line</A>
<HR>

<H2><A NAME="Edges">Edge handling</A></H2>
<P>The dimensions of the input region can be extended by adding elements
at the end of each dimension.  This is typically done for two reasons:

<UL>
  <LI>Adding the extra elements gives a size that is efficiently handled
    by Fourier transforms.
  <LI>Adding the extra elements reduces the blending of opposite edges of
    the data when filtering or cross-correlations are being performed.
</UL>

<P>To display the controls for the amount of padding and the values of the
elements added, press the button labeled <EM>Set edge handling</EM> in the
main dialog.  For each dimension the <EM>Width</EM> field sets the number
of elements that will be added.  When the toggle labeled
<EM>Use default width</EM> is on, the <EM>Width</EM> field will automatically
be set so the padded size can be efficiently handled.  There are three
ways in which the values of the added elements are set.  These are:

<DL>
  <DT>Pad with value<DD>Use the given value for all the elements added to
    a dimension.  The imaginary component of the value is only used if the
    input data is complex.
  <DT>Pad with mean<DD>Use the mean of the input region for the wavelength
    being processed when padding the dimension.
  <DT>Pad with linear ramp<DD>For each line in x, y, z, or time, the padding
    elements added to the line are a linear combination of the first and last
    element of that input line.
</DL>

<P>If a forward transform is being done and the data was
<A HREF="#Window">tapered</A>, than padding with zeroes is the best choice.
Padding with zeroes is also appropriate if a reverse transform is being done
and you want the grid sampled on a finer grid using Fourier interpolation.

<H3>Topics</H3>
<P>
  <A HREF="#FTransform4D">Overview</A> |
  <A HREF="Region.html">Region processing</A> |
  <A HREF="#Shift">Shift</A> |
  <A HREF="#Preprocessing">Preprocessing</A> |
  <A HREF="#Window">Window/taper</A> |
  Edge handling |
  <A HREF="#OutputSize">Output size</A> |
  <A HREF="#CommandLine">Command line</A>
<HR>

<H2><A NAME="OutputSize">Output size</A></H2>
<P>When a reverse transform is performed, the size of the region written to
the output file may be smaller than that of the straight Fourier transform
of the input after padding.  Press the button labeled <EM>Set output size</EM>
to open a dialog with controls for trimming the data.  For each dimension,
there is a display of the size of the transformed data.  The amount
of trimming for each dimension is listed in an editable field.

<H3>Topics</H3>
<P>
  <A HREF="#FTransform4D">Overview</A> |
  <A HREF="Region.html">Region processing</A> |
  <A HREF="#Shift">Shift</A> |
  <A HREF="#Preprocessing">Preprocessing</A> |
  <A HREF="#Window">Window/taper</A> |
  <A HREF="#Edges">Edge handling</A> |
  Output size |
  <A HREF="#CommandLine">Command line</A>
<HR>


<H2><A NAME="CommandLine">Command line</A></H2>
<P>FTransform4D accepts the command-line arguments described in
<A HREF="Region.html#COMMANDLINE">Region.html</A>.  In addition, FTransform4D
accepts the options shown below (optional parts are shown in brackets).  If
mutually exclusive options (i.e. for selection of the transform direction or
windowing function), the last option that appears on the command line takes
precedence.  The exception to this is if you specify both a transform type
and an output pixel format: then, if the output pixel format is inconsistent
with the transform type, the transform type takes precedence and the output
pixel format will be the default for that transform type.  The defaults for
real-valued data are to compute a forward transform where the negative x
frequencies are not retained, no preprocessing or windowing is done, the data
is padded with zeros to an efficient size, and the output pixel format is
complex stored as floating-point.  The defaults for complex-valued data are to
compute a reverse complex-to-real transform with a result whose x size is even
before trimming, no padding before the transform or trimming after the
transform is done, and the output pixel format is floating-point.

<DL>
  <DT><CODE>-complex_forward</CODE>
  <DD>Causes a forward transform of complex data to be computed.  The
    default output pixel format is the same as the input pixel format.

  <DT><CODE>-real_complex</CODE>
  <DD>Causes a forward transform of real-valued data to be computed;
    the negative x frequencies (redundant because of conjugate symmetry)
    are not retained.  The default output pixel format is complex
    stored as floating-point.

  <DT><CODE>-real_complex_full</CODE>
  <DD>Causes a forward transform of real-valued data to be computed;
    the negative x frequencies are retained.  The default output pixel format
    is complex stored as floating point.

  <DT><CODE>-complex_reverse</CODE>
  <DD>Causes a reverse transform of complex data to be computed.  The
    default output pixel format is the same as the input pixel format.

  <DT><CODE>-complex_real</CODE>
  <DD>Causes a reverse complex-to-real reverse transform to be computed.
    Assumes that the padded size for the forward transform was even.  The
    default output pixel format is floating-point.

  <DT><CODE>-complex_real_odd</CODE>
  <DD>Causes a reverse complex-to-real reverse transform to be computed.
    Assumes that the padded size for the forward transform was odd.  The
    default output pixel format is floating-point.

  <DT><CODE>-center_zero</CODE>
  <DD>Specifies that the zero frequency is at (0, (ny - 1) / 2, (nz - 1) / 2,
    (nt - 1) / 2) for real to complex or complex to real transforms and at
    ((nx - 1) / 2, (ny - 1) / 2, (nz - 1) / 2, (nt - 1) / 2) for complex to
    complex transforms.  If not present on the command line, the zero
    frequency is at (0,0,0,0).

  <DT><CODE>-same_units</CODE>
  <DD>If specified, the pixel spacing units are preserved and the origin
    and start indices are modified only for region selection during forward
    transforms.  Otherwise, the pixel spacing units are converted (to
    frequency units during a forward transform and to spatial units
    during a reverse transform), the origin is expressed in the same units,
    and the start indices are set to zero.

  <DT><CODE>-shift=</CODE><VAR>x_shift</VAR><CODE>:</CODE><VAR>y_shift</VAR><CODE>:</CODE><VAR>z_shift</VAR><CODE>:</CODE><VAR>t_shift</VAR>
  <DD>Specifies that, in conjunction with the transform, the data should be
    shifted by <VAR>x_shift</VAR> pixels in x, <VAR>y_shift</VAR> pixels
    in y, <VAR>z_shift</VAR> pixels in z, and <VAR>t_shift</VAR> pixels in
    time.  For a forward transform, a positive shift, <VAR>s</VAR>, moves
    pixel <VAR>s</VAR> to the origin.  For a reverse transform, a positive
    shift, <VAR>s</VAR>, moves the origin to pixel <VAR>s</VAR>.  The default
    shift values are zero pixels in all directions.

  <DT><CODE>-subtract=</CODE><VAR>value</VAR> or <CODE>-subtract=mean</CODE>
  <DD>Specifies that the input data should be preprocessed by subtracting
    <VAR>value</VAR> or the mean.  This option is ignored for reverse
    transforms.

  <DT><CODE>-linear_detrend</CODE>
  <DD>Specifies that the input data should be preprocessed by subtracting the
    linear trend which corresponds to the estimated average slope.  This
    option is ignored for reverse transforms.

  <DT><CODE>-polyfit=</CODE><VAR>n</VAR>
  <DD>Specifies that the input data should be preprocessed by subtracting
    the least-squares fit polynomial of order <VAR>n</VAR>.  Valid values
    of <VAR>n</VAR> range from one to 10.  This option is ignored for reverse
    transforms.

  <DT><CODE>-rectangular=</CODE><VAR>x_coverage</VAR><CODE>:</CODE><VAR>y_coverage</VAR><CODE>:</CODE><VAR>z_coverage</VAR><CODE>:</CODE><VAR>t_coverage</VAR>
  <DD>Selects a rectangular windowing function that attenuates 200 times
    <VAR>x_coverage</VAR> percent of the data in x, 200 times
    <VAR>y_coverage</VAR> percent of the data in y, 200 times
    <VAR>z_coverage</VAR> percent of the data in z, and 200 times
    <VAR>t_coverage</VAR> percent of the data in time.  Valid values for
    <VAR>x_coverage</VAR>, <VAR>y_coverage</VAR>, <VAR>z_coverage</VAR>, and
    <VAR>t_coverage</VAR> are between 0 and 0.5.

  <DT><CODE>-triangular=</CODE><VAR>x_coverage</VAR><CODE>:</CODE><VAR>y_coverage</VAR><CODE>:</CODE><VAR>z_coverage</VAR><CODE>:</CODE><VAR>t_coverage</VAR>
  <DD>Selects a triangular windowing function that attenuates 200 times
    <VAR>x_coverage</VAR> percent of the data in x, 200 times
    <VAR>y_coverage</VAR> percent of the data in y, 200 times
    <VAR>z_coverage</VAR> percent of the data in z, and 200 times
    <VAR>t_coverage</VAR> percent of the data in time.  Valid values for
    <VAR>x_coverage</VAR>, <VAR>y_coverage</VAR>, <VAR>z_coverage</VAR>, and
    <VAR>t_coverage</VAR> are between 0 and 0.5.

  <DT><CODE>-halfsine=</CODE><VAR>x_coverage</VAR><CODE>:</CODE><VAR>y_coverage</VAR><CODE>:</CODE><VAR>z_coverage</VAR><CODE>:</CODE><VAR>t_coverage</VAR>
  <DD>Selects a half-sine windowing function (consult the
    <A HREF="#Window">Window/taper topic</A> for details) that attenuates 200
    times <VAR>x_coverage</VAR> percent of the data in x, 200 times
    <VAR>y_coverage</VAR> percent of the data in y, 200 times
    <VAR>z_coverage</VAR> percent of the data in z, and 200 times
    <VAR>t_coverage</VAR> percent of the data in time.  Valid values for
    <VAR>x_coverage</VAR>, <VAR>y_coverage</VAR>, <VAR>z_coverage</VAR>, and
    <VAR>t_coverage</VAR> are between 0 and 0.5.  Use -halfsine_power to
    set the exponent, which controls the sharpness of the window edges.

  <DT><CODE>-halfsine_power=</CODE><VAR>p</VAR>
  <DD>Sets the exponent for the half-sine windowing function.  This option is
    ignored when other windowing functions are used.  If this option is not
    explicitly specified when the half-sine windowing function is used, the
    exponent used is one.

  <DT><CODE>-hamming=</CODE><VAR>x_coverage</VAR><CODE>:</CODE><VAR>y_coverage</VAR><CODE>:</CODE><VAR>z_coverage</VAR><CODE>:</CODE><VAR>t_coverage</VAR>
  <DD>Selects a Hamming window function (consult the
    <A HREF="#Window">Window/taper topic</A> for details) that attenuates 200
    times <VAR>x_coverage</VAR> percent of the data in x, 200 times
    <VAR>y_coverage</VAR> percent of the data in y, 200 times
    <VAR>z_coverage</VAR> percent of the data in z, and 200 times
    <VAR>t_coverage</VAR> percent of the data in time.  Valid values for
    <VAR>x_coverage</VAR>, <VAR>y_coverage</VAR>, <VAR>z_coverage</VAR>, and
    <VAR>t_coverage</VAR> are between 0 and 0.5.

  <DT><CODE>-blackman=</CODE><VAR>x_coverage</VAR><CODE>:</CODE><VAR>y_coverage</VAR><CODE>:</CODE><VAR>z_coverage</VAR><CODE>:</CODE><VAR>t_coverage</VAR>
  <DD>Selects a Blackman window function (consult the
    <A HREF="#Window">Window/taper topic</A> for details) that attenuates 200
    time <VAR>x_coverage</VAR> percent of the data in x, 200 times
    <VAR>y_coverage</VAR> percent of the data in y, 200 times
    <VAR>z_coverage</VAR> percent of the data in z, and 200 times
    <VAR>t_coverage</VAR> percent of the data in time.  Valid values for
    <VAR>x_coverage</VAR>, <VAR>y_coverage</VAR>, <VAR>z_coverage</VAR>, and
    <VAR>t_coverage</VAR> are between 0 and 0.5.

  <DT><CODE>-xpad=default</CODE> or <CODE>-xpad=</CODE><VAR>n</VAR>
  <DD>Specifies that the x dimension should be padded by the default amount
    or by <VAR>n</VAR> pixels, where <VAR>n</VAR> is a non-negative integer.

  <DT><CODE>-xpad_value=mean</CODE> or <CODE>-xpad_value=ramp</CODE> or <CODE>-xpad_value=</CODE><VAR>rv</VAR>[<CODE>:</CODE><VAR>iv</VAR>]
  <DD>Specifies what values to use when padding the x dimension.
    <CODE>-xpad_value=mean</CODE> causes the data to be padded with the
    mean value.  <CODE>-xpad_value=ramp</CODE> causes the data to be padded
    with values which range linearly from the value at one boundary to the
    value at the other boundary.  The last form causes the data to be
    padded with a constant value whose real component is <VAR>rv</VAR> and
    whose imaginary component is <VAR>iv</VAR>.  If the imaginary component
    is omitted, it is assumed to be zero.

  <DT><CODE>-ypad=default</CODE> or <CODE>-ypad=</CODE><VAR>n</VAR>
  <DD>Is similar to <CODE>-xpad</CODE> but specifies the amount of padding
    in the y dimension.

  <DT><CODE>-ypad_value=mean</CODE> or <CODE>-ypad_value=ramp</CODE> or <CODE>-ypad_value=</CODE><VAR>rv</VAR>[<CODE>:</CODE><VAR>iv</VAR>]
  <DD>Is similar to <CODE>-xpad_value</CODE> but specifies the padding values
    for the y dimension.

  <DT><CODE>-zpad=default</CODE> or <CODE>-zpad=</CODE><VAR>n</VAR>
  <DD>Is similar to <CODE>-xpad</CODE> but specifies the amount of padding
    in the z dimension.

  <DT><CODE>-zpad_value=mean</CODE> or <CODE>-zpad_value=ramp</CODE> or <CODE>-zpad_value=</CODE><VAR>rv</VAR>[<CODE>:</CODE><VAR>iv</VAR>]
  <DD>Is similar to <CODE>-xpad_value</CODE> but specifies the padding values
    for the z dimension.

  <DT><CODE>-tpad=default</CODE> or <CODE>-tpad=</CODE><VAR>n</VAR>
  <DD>Is similar to <CODE>-xpad</CODE> but specifies the amount of padding
    in the time dimension.

  <DT><CODE>-tpad_value=mean</CODE> or <CODE>-tpad_value=ramp</CODE> or <CODE>-tpad_value=</CODE><VAR>rv</VAR>[<CODE>:</CODE><VAR>iv</VAR>]
  <DD>Is similar to <CODE>-xpad_value</CODE> but specifies the padding values
    for the time dimension.

  <DT><CODE>-xtrim=</CODE><VAR>n</VAR>
  <DD>Trims <VAR>n</VAR> pixels from the x dimension before output;
    <VAR>n</VAR> must be a non-negative integer.  Trimming is only done
    on reverse transforms, and is ignored for forward transforms.

  <DT><CODE>-ytrim=</CODE><VAR>n</VAR>
  <DD>Is similar to <CODE>-xtrim</CODE> but controls the amount trimmed
    from the y dimension before output.

  <DT><CODE>-ztrim=</CODE><VAR>n</VAR>
  <DD>Is similar to <CODE>-xtrim</CODE> but controls the amount trimmed
    from the z dimension before output.

  <DT><CODE>-ttrim=</CODE><VAR>n</VAR>
  <DD>Is similar to <CODE>-xtrim</CODE> but controls the amount trimmed
    from the or time dimension before output.
</DL>

<P>As an example, if fft.dat is the result of a complex-to-complex forward
transform, then

<PRE>
    FTransform4D fft.dat out.dat -complex_reverse -shift=-3.1:-7.3:5.0:0
</PRE>

<P>computes the reverse transform, applies a shift that moves what was at
(3.1, 7.3, 5.0, 0) prior to the forward transform to the origin, and writes
the result in out.dat.

<H3>Topics</H3>
<P>
  <A HREF="#FTransform4D">Overview</A> |
  <A HREF="Region.html">Region processing</A> |
  <A HREF="#Shift">Shift</A> |
  <A HREF="#Preprocessing">Preprocessing</A> |
  <A HREF="#Window">Window/taper</A> |
  <A HREF="#Edges">Edge handling</A> |
  <A HREF="#OutputSize">Output size</A> |
  Command line
<HR>

</BODY>
</HTML>

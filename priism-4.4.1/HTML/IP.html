<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <TITLE>Priism's IP Framework</TITLE>
  <META NAME="Description" CONTENT="Describes the Priism IP framework for writing image processing applications.">
  <META NAME="Keywords" CONTENT="Priism,IP,ProcFunc,image,processing">
  <LINK REV=MADE HREF="mailto:ive@msg.ucsf.edu">
</HEAD>
<BODY>

<H1><A NAME="Overview">Priism's IP Framework</A></H1>
<H2>Overview</H2>

<P>The IP framework is intended to allow rapid development of image
processing applications for Priism; it is especially useful for applications
which do 2D processing on each section.  The framework provides the basics
of a user interface (a graphical user interface is always provided; a
non-interactive batch interface and text-mode interface are optional) and
a processing loop (verification of parameters; setup of inputs and outputs;
looping through the data).

<P>The basics of writing an application with the framework are covered in
the <A HREF="#Writing">Writing section</A>; the
<A HREF="#Examples">example code</A> should also be helpful.  For more
information about the order of operations performed by the framework, consult
the <A HREF="#Details">Details section</A>.

<H3>Topics</H3>
<P>
   Overview |
   <A HREF="#Writing">Writing</A> |
   <A HREF="#CompilingLinking">Compiling and linking</A> |
   <A HREF="#Examples">Examples</A> |
   <A HREF="#Details">Details</A> |
   <A HREF="#ReleaseNotes">Release Notes</A> |
   <A HREF="#Reference">Reference</A> |
   <A HREF="Region.html">Dialog Elements</A>
<HR>

<H2><A NAME="Writing">Writing an Application with IP</A></H2>

<P>An IP application has 3 parts: the first is the body of the application
which is already written for you; the second is the
<A HREF="#IPAppSpecifics">IPAppSpecifics</A> routine which defines what parts
of the IP framework you want to customize; the third consists of the routines
that were registered (using calls to
<A HREF="#IPSetCustRoutine">IPSetCustRoutine</A> in IPAppSpecifics) to perform
certain customizations.

<P>The <A HREF="#IPAppSpecifics">IPAppSpecifics</A> routine performs a
series of calls to IP library routines to define the application's behavior.
The handling of <A HREF="#FunctionsIO">input/output</A>,
<A HREF="#FunctionsUI">user interaction</A>, and
<A HREF="#FunctionsProc">image processing</A> can all be customized.
A brief description of the most commonly used customizations is
given below.

<P><A HREF="#IPAddInput">IPAddInput</A> and
<A HREF="#IPAddOutput">IPAddOutput</A> are the most used calls for
customizing input/output.  For each input image file that you want the IP
framework to handle for your application, you call IPAddInput from
IPAppSpecifics.  This call will create the elements at the top of the
dialog so the user can specify the input file or window and initializes the
framework to handle an additional input image.  IPAddOutput functions
similarly.

<P>Custom dialog elements are added by registering a function using
<A HREF="#IPSetCustRoutine">IPSetCustRoutine</A> with the
CUS_MENU option.  The registered function then makes the
<A HREF="WM.html">WM</A> calls to create the widgets.  The placement of
the application dialog and the title that appears on the dialog's frame
are usually customized with calls to
<A HREF="#IPSetMenuLoc">IPSetMenuLoc</A> and
<A HREF="#IPSetMenuTitle">IPSetMenuTitle</A>.

<P>For processing, a typical application registers a PROC_FUNC routine
with IPSetCustRoutine and uses a PROC_FUNC routine (and, if necessary,
CHECK_PARAMS, INIT_PROC, or AFTER_DO_IT routines as well).  A
stereotypical 2D processing application using this approach defines a routine
which processes a single section and registers that routine with the PROC_FUNC
option to <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>.  The prototype for
the registered routine, in C, is

<PRE>
     void routine_name(int nxyz[3], float dmms[3], int argu);
</PRE>

<P>and, in Fortran, is

<PRE>
     subroutine routine_name(nxyz, dmms, argu)
     integer nxyz(3), argu
     real dmms(3)
</PRE>

<P><VAR>nxyz</VAR> holds the dimensions of the region being processed.  The
elements of <VAR>dmms</VAR> should be set to the minimum, maximum, and sum of
the pixel values in the result of processing the section.  <VAR>argu</VAR> is
the parameter passed when the function was registered.  Within the processing
function, call <A HREF="#IPGetDataPtr">IPGetDataPtr</A> to get pointers to
the input and output arrays.

<P>3D and 4D processing can be performed similarly.  The prototype
for the PROC_FUNC routine is different:

<PRE>
     void routine_name(int argu);
</PRE>

<P>in C and, in Fortran,

<PRE>
    subroutine routine_name(argu)
    integer argu
</PRE>

<P>Also, when 3D or 4D processing is done, the application must handle
reading and writing of the image data, rearranging the extended header,
if any, and computing and setting the statistics values for each wavelength in
the outputs (using <A HREF="#IPSetFirstWaveMMM">IPSetFirstWaveMMM</A> or
<A HREF="#IPSetFirstWaveMMMExt">IPSetFirstWaveMMMExt</A>
for the first wavelength and <A HREF="IM_ref2.html#IMAlWavMM">IMAlWavMM</A>
for the others).  As in the 2D case, the framework allocates buffers for
the inputs and outputs, but because of the size of 3D or 4D data, it is likely
that the application will do its own allocation and completely or partially
disable what the framework normally does by calling
<A HREF="#IPSetNoAutoIO">IPSetNoAutoIO</A>.

<H3>Topics</H3>
<P>
   <A HREF="#Overview">Overview</A> |
   Writing |
   <A HREF="#CompilingLinking">Compiling and linking</A> |
   <A HREF="#Examples">Examples</A> |
   <A HREF="#Details">Details</A> |
   <A HREF="#ReleaseNotes">Release Notes</A> |
   <A HREF="#Reference">Reference</A> |
   <A HREF="Region.html">Dialog Elements</A>
<HR>

<H2><A NAME="CompilingLinking">Compiling and Linking IP Applications</A></H2>
<P>C/C++ programs which make calls to the IP library should include ip.h
to define constants and function prototypes.  Fortran programs may want
to include ip.inc which defines parameters for the different types of
processing (two-, three-, or four- dimensional) and the different classes
of functions that may be registered with
<A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>.

<P>When linking your application, link against libProcFunc.a or libProcFunc.so
(libProcFunc.dylib on Mac OS X) if the
<A HREF="#IPAppSpecifics">IPAppSpecifics</A> routine for your application is
written in C or C++.  Link against libFProcFunc.a or libFProcFunc.so
(libFProcFunc.dylib on Mac OS X) if the IPAppSpecifics routine for your
application is written in Fortran.  If you use one of the archive versions
of the library (libProcFunc.a or libFProcFunc.a), you will also have to
explicitly link against libSelectRegion.a, the <A HREF="IW.html">IW library</A>
(libIWL.so (.dylib for Mac OS X) or libIWL.a), <A HREF="WM.html">WM library</A>
(libWM.so (.dylib for MacOS X) or libWM.a), and libIVE (libive.so
(libive.dylib for Mac OS X) or libive.a).

<H3>Platform Specifics</H3>
<H4><A NAME="CompilingLinking_x86Linux">x86 Linux</A></H4>
<P>The requirements for the x86 Linux version of the library are the combined
requirements for the <A HREF="IM_ref2.html#CompilingLinking_x86Linux">IW</A>
and <A HREF="WM.html#CompilingLinking_x86Linux">WM</A> libraries.

<P>The headers are located in the Linux/x86/INCLUDE directory of the Priism
distribution.  For C/C++ programs, include ip.h has the side effect of
including X headers; if the path to those headers is not in the default
search path then it will be necessary to include it in the search path
(in most cases adding

<PRE>
    -I/usr/X11R6/include
</PRE>

<P>to the compilation options will do this).

<P>The libraries are located in the Linux/x86/LIB directory of the Priism
distribution.  If you use one of the shared libraries (libProcFunc.so or
libFProcFunc.so) it is  necessary to instruct
the linker to search Linux/x86/LIB for additional libraries that are used
internally.  If you invoke the linker directly, this can be done by adding

<PRE>
    -rpath-link <VAR>install_dir</VAR>/Linux/x86/LIB
</PRE>

<P>to the linker options (replace <VAR>install_dir</VAR> with the path to
the Priism distribution).  If the compiler is used to invoke the linker, then
you will need to determine how to instruct the compiler to pass the above
option to the linker; for most compilers it can be done with

<PRE>
    -Wl,-rpath-link,<VAR>install_dir</VAR>/Linux/x86/LIB
</PRE>

<P>The shared libraries also depend, indirectly, on the Motif (or LessTif),
X, and OpenGL libraries; if the paths to those libraries are not in the
directory search path, it will be necessary to supply additional -rpath-link
options.

<P>For Fortran programs, the name mangling of the libraries is compatible
with the default mangling done by the Portland Group Fortran compiler.  The
library include alternate entry points which are compatible with the default
name mangling done by g77.

<H4><A NAME="CompilingLinking_x86_64Linux">x86_64 Linux</A></H4>
<P>The requirements for the x86_64 Linux version of the library are the
combined requirements for the
<A HREF="IM_ref2.html#CompilingLinking_x86_64Linux">IW</A>
and <A HREF="WM.html#CompilingLinking_x86_64Linux">WM</A> libraries.

<P>The headers are located in the Linux/x86_64/INCLUDE directory of the Priism
distribution.  For C/C++ programs, include ip.h has the side effect of
including X headers; if the path to those headers is not in the default
search path then it will be necessary to include it in the search path
(in most cases adding

<PRE>
    -I/usr/X11R6/include
</PRE>

<P>to the compilation options will do this).

<P>The libraries are located in the Linux/x86_64/LIB directory of the Priism
distribution.  If you use one of the shared libraries (libProcFunc.so or
libFProcFunc.so) it is  necessary to instruct the linker to search
Linux/x86_64/LIB for additional libraries that are used internally.  If you
invoke the linker directly, this can be done by adding

<PRE>
    -rpath-link <VAR>install_dir</VAR>/Linux/x86_64/LIB
</PRE>

<P>to the linker options (replace <VAR>install_dir</VAR> with the path to
the Priism distribution).  If the compiler is used to invoke the linker, then
you will need to determine how to instruct the compiler to pass the above
option to the linker; for most compilers it can be done with

<PRE>
    -Wl,-rpath-link,<VAR>install_dir</VAR>/Linux/x86_64/LIB
</PRE>

<P>The shared libraries also depend, indirectly, on the Motif (or LessTif),
X, and OpenGL libraries; if the paths to those libraries are not in the
directory search path, it will be necessary to supply additional -rpath-link
options.

<P>For Fortran programs, the name mangling of the libraries is compatible
with the default mangling done by the Intel Fortran compiler.  The library
include alternate entry points which are compatible with the default name
mangling done by g77.

<H4><A NAME="CompilingLinking_MacOSX">Mac OS X</A></H4>
<P>The requirements for the Mac OS X version of the library are the combined
requirements for the <A HREF="IM_ref2.html#CompilingLinking_MacOSX">IW</A>
and <A HREF="WM.html#CompilingLinking_MacOSX">WM</A> libraries.

<P>The headers for 32-bit applications are located in the Darwin/INCLUDE
directory of the Priism distribution.  The headers for 64-bit applications
are located in the Darwin64/INCLUDE directory.  For C/C++ programs,
include ip.h has the side effect of including X headers; if the path to those
headers is not in the default search path then it will be necessary to include
it in the search path (in most cases adding

<PRE>
    -I/usr/X11R6/include
</PRE>

<P>to the compilation options will do this).

<P>The 32-bit libraries are located in the Darwin/LIB directory of the Priism
distribution.  The 64-bit libraries are located in the Darwin64/LIB directory
of the Priism distribution.  If you link against one of the shared libraries (
libProcFunc.dylib or libFProcFunc.dylib) it is also necessary to link against
libWM, libIWL, libive, libGLw, and libXm, i.e. add
<PRE>
    -lWM -lIWL -live -lGLw -lXm
</PRE>

<P>the link options.  Except for the Motif/LessTif library, libXm, these
libraries are in the same directory as the IP shared libraries.

<P>For Fortran programs, the name mangling of the libraries is compatible
with typical Unix behavior (names converted to all lowercase with an
underscore appended).  When using the Absoft Fortran compiler, the options
<PRE>
     -N15 -f
</PRE>
<P>are necessary to force that style of name mangling.

<H3>Topics</H3>
<P>
   <A HREF="#Overview">Overview</A> |
   <A HREF="#Writing">Writing</A> |
   Compiling and Linking |
   <A HREF="#Examples">Examples</A> |
   <A HREF="#Details">Details</A> |
   <A HREF="#ReleaseNotes">Release Notes</A> |
   <A HREF="#Reference">Reference</A> |
   <A HREF="Region.html">Dialog Elements</A>
<HR>

<H2><A NAME="Examples">IP Examples</A></H2>

<H3>Some Priism Applications which use the IP Framework</H3>
<DL>

<DT><A HREF="FindBorder.html">FindBorder</A>
<DD>Uses the basic IP dialog with just one additional widget, an input for the
threshold to use.

<DT><A HREF="Threshold.html">Threshold</A>
<DD>Adds more widgets for the thresholds to apply, the form of the output,
and to specify an optional non-image output file.

<DT><A HREF="NewConvolution.html">NewConvolution</A>
<DD>Includes the IP option for processing a single section.

<DT><A HREF="ImageArith.html">Image Arith</A>
<DD>Combines two input image files to form one output.

</DL>

<H3>Sample Source Code</H3>
<DL>

<DT><A HREF="../EXAMPLE/Select.c">Select.c</A>
<DD>Copies a subset of the input to the output performing any necessary
real/complex conversions.

<DT><A HREF="../EXAMPLE/FindBorder.c">FindBorder.c</A>
<DD>Creates an image file where borders (determined from a single threshold)
are marked with 1's and the rest of the image is 0's.

<DT><A HREF="../EXAMPLE/FindBorderF.f">FindBorderF.f</A>
<DD>Has the same functionality as FindBorder.c above but is written in
Fortran.

<DT><A HREF="../EXAMPLE/interpo.c">interpo.c</A> and <A HREF="../EXAMPLE/gettransmatrix.f">gettransmatrix.f</A>
<DD>Resamples a data stack to a new grid in two dimensions; it is functionally
equivalent to Priism's <A HREF="Resample2D.html">Resample2D</A>,

</DL>

<H3>Topics</H3>
<P>
   <A HREF="#Overview">Overview</A> |
   <A HREF="#Writing">Writing</A> |
   <A HREF="#CompilingLinking">Compiling and Linking</A> |
   Examples |
   <A HREF="#Details">Details</A> |
   <A HREF="#ReleaseNotes">Release Notes</A> |
   <A HREF="#Reference">Reference</A> |
   <A HREF="Region.html">Dialog Elements</A>
<HR>

<H2><A NAME="Details">Details</A></H2>
<P>When an application based on the IP framework is run, it initializes
the framework and calls <A HREF="#IPAppSpecifics">IPAppSpecifics</A>.
Certain customizations can only be performed from within IPAppSpecifics,
namely <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A> for the CUS_MENU,
OPT_MENU, CMD_LINE_FUNC, USAGE_FUNC, WRITE_CMD, and PROMPT_FUNC routines (as
you will see below, these routines, if called at all, are called just after
IPAppSpecifics returns so any later modifications have no effect),
<A HREF="#IPAddInput">IPAddInput</A>, and
<A HREF="#IPAddOutput">IPAddOutput</A>.

<P>When IPAppSpecifics returns, the framework makes a decision about which
interface to present to the user.  If there is only one command-line
argument and that argument is <CODE>-prompt</CODE>, the text-mode interactive
interface is started.  If the text-mode interface is started but the
application has not registered a PROMPT_FUNC routine with
<A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>, the application will exit
with a message that the text-mode interface is not handled.  If there
are any command-line arguments, the non-interactive interface is started.
When the application is started with no command-line arguments the graphical
user interface is started.

<P>In the graphical user interface, the framework does the following:
<OL>
  <LI>If not already set (via a command-line which included the -menu
    option), names for the output data sets are initialized to available
    image window numbers.
  <LI>The framework creates the main dialog and adds the input and
    output controls to it.
  <LI>The framework calls the CUS_MENU routine registered with
    <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A> to add the
    application-specific controls to the main dialog.
  <LI>The framework completes the main dialog.  If
    <A HREF="#IPEnableDoSec">IPEnableDoSec</A> or the application
    has registered a WRITE_CMD routine with
    <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>, then the main dialog
    contains an "Options" menu with entries for controlling trial runs
    (only enabled if IPEnableDoSec has been called) and an entry to create
    a command file (only enabled if a WRITE_CMD routine has been registered).
  <LI>The framework calls the OPT_MENU routine registered with
    <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>.
  <LI>The framework enters a loop waiting for user input.  If the
    user presses the "DoIt" button, processing is started; the steps in
    processing are described separately below.  When the user presses
    the "Quit" button or asks the window manager to close the application, the
    loop terminates and the framework performs a set of cleanup actions
    described below.  The application then exits with a exit code of zero.
</OL>

<P>In the command-line interface, the framework does the following:
<OL>
  <LI>If the application has not registered a CMD_LINE_FUNC routine
    with <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>, the application
    exits after displaying a message that the application does not support
    a command-line interface.
  <LI>Scans the command-line argument for the input and output data stack
    names and any command-line arguments handled by the framework.  These
    are stripped from the command-line.  The framework opens any input stack
    whose name was set, reads its header, and calls the callback for the input
    registered with <A HREF="#IPAddInput">IPAddInput</A> and the OPEN_FILE
    routine from <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>.
    The parameters for the input region and output file modes are set and
    the related routines (the NEW_REGION, WAVE_FUNC, and CHANGE_MODE
    routines set with <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A> are
    called.
  <LI>Call the CMD_LINE_FUNC routine the application has registered with
    <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>
  <LI>If the <CODE>-menu</CODE> option was specified on the command-line,
    the application proceeds to execute with a graphical interface (see
    the description above for what happens).  Otherwise, the application
    starts processing; the processing stages are described separately below.
    When processing completes, the cleanup actions, also described below,
    are performed and then the application exits.  The exit code is 0 if
    the processing ran to completion without an interrupt or a detected fatal
    error and 1 otherwise.
</OL>

<P>In the text-mode interface, the application enters a loop which, until
terminated by the user, does the following:
<OL>
  <LI>Prompts the user for the parameters handled by the framework:  names
    of input and output files, size of the selected region, pixel format
    for output, etc.
  <LI>Calls the PROMPT_FUNC routine registered with
    <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A> to ask the user for
    the parameters specific to the application.
  <LI>With the given parameters, starts processing.  The stages involved
    in processing are described separately below.
</OL>
<P>When the user asks to terminate the text-mode loop, the cleanup actions
described below are called and the application exits with an exit code of 0.

<P>The cleanup actions performed in any of the three forms of user interaction
are:
<OL>
  <LI>The framework calls the CLEAN_UP_PROC routine which was
    registered with <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>.
  <LI>The framework closes any open input added with
    <A HREF="#IPAddInput">IPAddInput</A>.  In the process any graphics or
    window event handlers added by the framework are removed.
</OL>

<P>Processing is proceeded by a couple of steps to check the input parameters
and set up the handling of interrupts and is followed by a couple of steps
to wrap things up.  Those steps are:

<OL>
  <LI>If the application is not running with a graphical interface, the
    framework installs signal handlers for SIGHUP, SIGINT, and SIGTERM
    which cause those signals to set a flag that processing should be
    interrupted (the application can check this flag with
    <A HREF="#IPCheckInterrupt">IPCheckInterrupt</A>.
  <LI>The framework calls the CHECK_PARAMS routine registered with
    <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>.
  <LI>If the application or framework has not detected an error or problem
    in the input parameters, then the actual data processing is started.
    This is described in detail separately.  If there is an error or problem
    in the input parameters and the application is running with the
    command-line interface, the framework prints a summary of the allowed
    command-line parameters and calls the DISPLAY_USAGE routine registered
    with <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A> to display a
    summary of the application-specific command-line parameters.  To flag an
    error in the inputs, the application would call
    <A HREF="#IPDesist">IPDesist</A> from within the CHECK_PARAMS routine or,
    if the application is running with a command-line interface, from within
    the CMD_LINE_FUNC routine.
  <LI>The framework calls the UNDO_CHECK routine registered with
    <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>.
  <LI>If the application is running without a graphical interface and
    processing was interrupted, the INTERRUPT routine registered with
    <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A> is called at this point.
    When run with a graphical interface, the INTERRUPT routine is called
    when the interrupt is detected; usually this would be from within a call to
    <A HREF="#IPCheckInterrupt">IPCheckInterrupt</A>.
  <LI>If the application is not running with a graphical interface, the
    application restores the prior signal handlers for SIGHUP, SIGINT, and
    SIGTERM.
</OL>

<P>The actual processing is done in one of two ways.  If the application
has registered a CUST_DOIT routine with
<A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>, then, as far as the
framework is concerned, processing is only a matter of calling the CUST_DOIT
routine.  The more common approach which forces the framework to do more
of the work is to not register a CUST_DOIT routine.  Then the processing
proceeds as follows:

<OL>
  <LI>The framework computes the size of the input region based on the
    selected region for the first input.
  <LI>For each output from <A HREF="#IPAddOutput">IPAddOutput</A> that has a
    name specified, the framework calls the callback registered with
    <A HREF="#IPSetComputeSize">IPSetComputeSize</A> to determine the size of
    the data to be generated; if a callback is not registered, the framework
    assumes that the size of data generated for that output will be the same
    as the input size.
  <LI>The framework determines which outputs have names which already exist
    and whether to append or overwrite those that do.
  <LI>The framework opens all the outputs from
    <A HREF="#IPAddOutput">IPAddOutput</A> and sets up or adjusts the
    headers as appropriate.  If a callback was registered with
    <A HREF="#IPAddOutput">IPAddOutput</A>, that callback is invoked
    after the output is open and the headers are set.
  <LI>If it was not possible to open a required output or
    <A HREF="#IPDesist">IPDesist</A> was called from one or more of the
    <A HREF="#IPSetComputeSize">IPSetComputeSize</A> or
    <A HREF="#IPAddOutput">IPAddOutput</A> callbacks, processing does not
    proceed any further.
  <LI>If <A HREF="#IPSetNoAutoIO">IPSetNoAutoIO</A> has not been called,
    buffers for each input and output are allocated (some buffers may be
    shared; see <A HREF="#IPSetIncoreProc">IPSetIncoreProc</A> and
    <A HREF="#IPSetIncoreProcExt">IPSetIncoreProcExt</A> for details).
    If allocation fails, processing is halted at this point and the opened
    outputs are closed. If <A HREF="#IPSetNoAutoIO">IPSetNoAutoIO</A> was
    called the pointers to the buffers are all initialized to be NULL.
    Applications can access the pointers to the buffers with
    <A HREF="#IPGetDataPtr">IPGetDataPtr</A> and
    <A HREF="#IPSetDataPtr">IPSetDataPtr</A>.
  <LI>The framework calls the INIT_PROC routine registered with
    <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>.  If the routine calls
    <A HREF="#IPDesist">IPDesist</A>, processing is halted when the routine
    is returned:  the buffers are deallocated and open outputs from
    <A HREF="#IPAddOutput">IPAddOutput</A> are closed.
  <LI>The framework loops over the input region making calls to the PROC_FUNC
    routine.  The form of this loop is described below and depends upon which
    processing type was set with <A HREF="#IPSetProcType">IPSetProcType</A>
    (the default type is 2D).
  <LI>The framework calls the AFTER_DO_IT routine registered with
    <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>.
  <LI>The framework deallocates all the buffers and closes the outputs
    from <A HREF="#IPAddOutput">IPAddOutput</A>.  Prior to closing each,
    the header is updated with the final statistics for the first
    wavelength and new labels.
</OL>

<P>The loop in which PROC_FUNC is called has the following structure for
2D processing (the TWO_D option to <A HREF="#IPSetProcType">IPSetProcType</A>):

<OL>
  <LI>Loop over the wavelengths to process or until interrupted.  If run from
    the graphical interface, the order of the wavelengths is from the lowest
    to highest index in the inputs; if run from the command-line it is
    possible for the user to specify a different ordering.  Use
    <A HREF="#IPGetWaveOrder">IPGetWaveOrder</A> to determine
    the order in which wavelengths are drawn from a particular input.
  <OL>
    <LI>Set the output's initial scaling for the current wavelength (see
      <A HREF="#IPSetSclParam">IPSetSclParam</A> for details).
    <LI>Loop over time points for lowest index to highest index or until
      interrupted.
    <OL>
      <LI>Loop over z from lowest to highest section number or until
        interrupted.
      <OL>
        <LI>For each open input from <A HREF="#IPAddInput">IPAddInput</A>,
          position the input at the appropriate section, and if the input
          has an associated buffer (it will if
          <A HREF="#IPSetNoAutoIO">IPSetNoAutoIO</A> has not been called or
          <A HREF="#IPSetDataPtr">IPSetDataPtr</A> has been used to set the
          pointer to the buffer to a non-NULL value), read in the data for
          the section.
        <LI>For each open output from <A HREF="#IPAddOutput">IPAddOutput</A>,
          position the output at the appropriate section.
        <LI>Call the PROC_FUNC routine registered with
          <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>.
        <LI>For each open output from <A HREF="#IPAddOutput">IPAddOutput</A>
          update the cumulative statistics, the statistics for the section,
          and the image scaling (only if writing to an image window).  The
          extended header corresponding to the processed section from the
          first output is transferred, if possible.  If the output has
          an associated buffer (it will if
          <A HREF="#IPSetNoAutoIO">IPSetNoAutoIO</A> has not been called or
          <A HREF="#IPSetDataPtr">IPSetDataPtr</A> has been used to set the
          pointer to the buffer to a non-NULL value), then the contents of
          that buffer are written to the output file.
      </OL>
    </OL>
    <LI>For each output, adjust the wavelength's statistics in the header.
  </OL>
  <LI>If processing terminated early, attempt to fix the header of the
    output file to accurately reflect what was completed.
</OL>

<P>The 3D and 4D processing loops are similar, but there is no reading and
writing of the image data done by the framework nor handling of the extended
header.  For 3D processing (the THREE_D option to
<A HREF="#IPSetProcType">IPSetProcType</A>), the loop structure is:
<OL>
  <LI>Loop over the wavelengths to process or until interrupted.  If run from
    the graphical interface, the order of the wavelengths is from the lowest
    to highest index in the inputs; if run from the command-line it is
    possible for the user to specify a different ordering.  Use
    <A HREF="#IPGetWaveOrder">IPGetWaveOrder</A> to determine
    the order in which wavelengths are drawn from a particular input.
  <OL>
    <LI>Set each output's initial scaling for the current wavelength (see
      <A HREF="#IPSetSclParam">IPSetSclParam</A> for details).
    <LI>Loop over time points for lowest index to highest index or until
      interrupted.
    <OL>
      <LI>Call the PROC_FUNC routine registered with
        <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>.
    </OL>
  </OL>
  <LI>If processing terminated early, attempt to fixup the header of the
    output file to accurately reflect what was completed.
</OL>

<P>For the alternative 3D processing loop where time is used as the third
dimension (the THREE_D_XYT option to
<A HREF="#IPSetProcType">IPSetProcType</A>), the loop structure is:
<OL>
  <LI>Loop over the wavelengths to process or until interrupted.  If run from
    the graphical interface, the order of the wavelengths is from the lowest
    to highest index in the inputs; if run from the command-line it is
    possible for the user to specify a different ordering.  Use
    <A HREF="#IPGetWaveOrder">IPGetWaveOrder</A> to determine
    the order in which wavelengths are drawn from a particular input.
  <OL>
    <LI>Set each output's initial scaling for the current wavelength (see
      <A HREF="#IPSetSclParam">IPSetSclParam</A> for details).
    <LI>Loop over z from lowest to highest section number or until interrupted.
    <OL>
      <LI>Call the PROC_FUNC routine registered with
        <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>.
    </OL>
  </OL>
  <LI>If processing terminated early, attempt to fixup the header of the
    output file to accurately reflect what was completed.
</OL>

<P>For 4D processing (the FOUR_D option to
<A HREF="#IPSetProcType">IPSetProcType</A>), the loop structure is:

<OL>
  <LI>Loop over the wavelengths to process or until interrupted.  If run from
    the graphical interface, the order of the wavelengths is from the lowest
    to highest index in the inputs; if run from the command-line it is
    possible for the user to specify a different ordering.  Use
    <A HREF="#IPGetWaveOrder">IPGetWaveOrder</A> to determine
    the order in which wavelengths are drawn from a particular input.
  <OL>
    <LI>Set each open output's initial scaling for the current wavelength (see
      <A HREF="#IPSetSclParam">IPSetSclParam</A> for details).
    <LI>Call the PROC_FUNC routine registered with
      <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>.
  </OL>
  <LI>If processing terminated early, attempt to fixup the header of the
    output file to accurately reflect what was completed.
</OL>

<P>An alternative 4D processing loop (the FOUR_D_WAVE option to
<A HREF="#IPSetProcType">IPSetProcType</A>) has this loop structure:

<OL>
  <LI>For each open output from <A HREF="#IPAddOutput">IPAddOutput</A>,
    loop over the wavelengths to generate for that output and set the
    initial scaling for the wavelengths (see
    <A HREF="#IPSetSclParam">IPSetSclParam</A> for details).
  <LI>Loop over time points for lowest index to highest index or until
    interrupted.
  <OL>
    <LI>Call the PROC_FUNC routine registered with
      <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>.
  </OL>
  <LI>If processing terminated early, attempt to fixup the header of the
    output file to accurately reflect what was completed.
</OL>

<H3>Topics</H3>
<P>
   <A HREF="#Overview">Overview</A> |
   <A HREF="#Writing">Writing</A> |
   <A HREF="#CompilingLinking">Compiling and Linking</A> |
   <A HREF="#Examples">Examples</A> |
   Details |
   <A HREF="#ReleaseNotes">Release Notes</A> |
   <A HREF="#Reference">Reference</A> |
   <A HREF="Region.html">Dialog Elements</A>
<HR>

<H2><A NAME="ReleaseNotes">Release Notes</A></H2>
<P>In IVE 4.2.2, added the following features that were not available in
previous versions:

<UL>
  <LI>Added the functions,
    <A HREF="#IPEnableResolutionSelection">IPEnableResolutionSelection</A> and
    <A HREF="#IPGetCurRes">IPGetCurRes</A>.
  <LI>Added the constant NEW_RES.
</UL>

<P>In IVE 4.2.3, introduced the constant THREE_D_XYT; that constant is not
present in previous implementations of the library.

<P>The following changes made between IVE 3.3 and IVE 4 break backward
source or makefile compatibility:

<UL>
  <LI>In IVE 3.3, it was necessary to link against ProcFunc.o or FProcFunc.o
    and, in some cases, ipintermed.o, to access the IP calls.  ProcFunc.o
    and FProcFunc.o still exist for backward compatibility, but may be
    removed in a future release.  ipintermed.o is not needed and is not present
    in IVE 4.
  <LI>The functions ipaddinputc_, ipaddoutputc_, ippostinfoc_, and
    ipsetmenutitlec_, which were used internally to support the Fortran
    interface, have been removed; use <A HREF="#IPAddInput">IPAddInput</A>,
    <A HREF="#IPAddOutput">IPAddOutput</A>,
    <A HREF="#IPPostInfo">IPPostInfo</A>,
    or <A HREF="#IPSetMenuTitle">IPSetMenuTitle</A>, respectively, instead.
  <LI>The locations of the headers and libraries has changed.  In previous
    versions, the headers were in the INCLUDE subdirectory and the libraries
    were in the LIB (or LIB_IRIX) subdirectory for IRIX.
</UL>

<P>In IVE 4.0.7, the value of the constant, SAME_AS_FIRST_INPUT, was changed in
to avoid a clash with the value of IW_COMPLEX_SHORT.  This breaks backward
binary compatibility with previous versions.  Executables linked against the
IP shared libraries or object files which used this constant (or its
equivalent integer value) should be recompiled to operate correctly with
the IP library.

<P>The following changes made between IVE 4.0 and IVE 4.1 break backward
source or makefile compatibility:

<UL>
  <LI>ProcFunc.o and FProcFunc.o are no longer provided; link against
    libProcFunc.so, libProcFunc.a, libFProcFunc.so, or libFProcFunc.a
    instead.
  <LI>Applications which link against the libProcFunc.a or libFProcFunc.a
     must now also link with libSelectRegion.a and libive.so (libive.dylib
     for MacOS X) or libive.a in addition to the WM and IW libraries.  The
     correct link order for these libraries is -lSelectRegion -lWM -lIWL -live.
  <LI>The IPGetCMD, IPSetNoresize, and IPStartCMD functions are no longer
    provided.  The IPGetCMD was for returning command line parameters; use
    <A HREF="#IPGetArg">IPGetArg</A> and
    <A HREF="#IPGetArgCount">IPGetArgCount</A> instead.  IPSetNoresize
    had no effect in previous versions of the library and it was not clear
    what its intended function was.  IPStartCMD was used internally.
  <LI>The region.h header file which described internal library structures
    is no longer provided; any application that relied on those internal
    structures or undocumented library routines will need to be modified
    since those internals have been extensively changed and are opaque
    to the application.
  <LI>An ENV_CMD routine, if registered, is not used.  Use
    CMD_LINE_FUNC, USAGE_FUNC, and WRITE_CMD in conjunction
    with <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A> to implement a
    command-line interface.
  <LI><A HREF="#IPAddInput">IPAddInput</A> and
    <A HREF="#IPAddOutput">IPAddOutput</A> now honor the parameters to
    specify that an input or output must be present or must be an image
    window.
  <LI>The CLEAN_UP_PROC routine is invoked in all cases; previous versions
    only did so if an input from <A HREF="#IPAddInput">IPAddInput</A> was
    open.
  <LI>The CLEAN_UP_PROC routine is invoked if the application is exited
    via the window manager.  Previous versions did not do that.  If your
    application calls WMSetExitFunction to work around the behavior of
    previous versions, it will prevent the library from performing certain
    cleanup tasks.  Use the CLEAN_UP_PROC routine instead.
  <LI>The NEW_REGION routine is invoked when the user releases the mouse
    button after interactively selecting the x/y region to process in an
    image window.  Previous versions did not do that.
  <LI>The CHECK_PARAMS routine, which was mentioned in the header file but
    not invoked by the library, is now invoked prior to processing.
  <LI>Previous versions would call the UN_REG_DIS_CHG routine just prior
    to CLEAN_UP_PROC.  That is no longer done.
  <LI>With the 3D and 4D variants of PROC_FUNC processing, previous versions
    would position IM stream number 2 to the first section in the starting
    output wavelength.  That is no longer done.
  <LI>Previous versions had the undocumented behavior of initializing the
    output array to have all bits zero prior to starting processing.  That
    is no longer the case.
  <LI>Added the functions <A HREF="#IPAllowMode">IPAllowMode</A>,
    <A HREF="#IPAllowModeChange">IPAllowModeChange</A>,
    <A HREF="#IPAppendCommand">IPAppendCommand</A>,
    <A HREF="#IPDesist">IPDesist</A>,
    <A HREF="#IPDisplayMessage">IPDisplayMessage</A>,
    <A HREF="#IPEnableRegionSelection">IPEnableRegionSelection</A>,
    <A HREF="#IPGetAppendOptions">IPGetAppendOptions</A>,
    <A HREF="#IPGetArg">IPGetArg</A>,
    <A HREF="#IPGetArgCount">IPGetArgCount</A>,
    <A HREF="#IPGetCurZWTExt">IPGetCurZWTExt</A>,
    <A HREF="#IPGetDefOutPutModeExt">IPGetDefOutPutModeExt</A>,
    <A HREF="#IPGetRegionInfoExt">IPGetRegionInfoExt</A>,
    <A HREF="#IPGetWaveOrder">IPGetWaveOrder</A>,
    <A HREF="#IPHasGUI">IPHasGUI</A>,
    <A HREF="#IPIsAppending">IPIsAppending</A>,
    <A HREF="#IPIsInteractive">IPIsInteractive</A>,
    <A HREF="#IPIsOpen">IPIsOpen</A>,
    <A HREF="#IPParseIntArg">IPParseIntArg</A>,
    <A HREF="#IPParseRealArg">IPParseRealArg</A>,
    <A HREF="#IPPromptInt">IPPromptInt</A>,
    <A HREF="#IPPromptReal">IPPromptReal</A>,
    <A HREF="#IPPromptString">IPPromptString</A>,
    <A HREF="#IPReportSectionStats">IPReportSectionStats</A>,
    <A HREF="#IPSetAppendOptions">IPSetAppendOptions</A>,
    <A HREF="#IPSetAutoScale">IPSetAutoScale</A>,
    <A HREF="#IPSetComputeSize">IPSetComputeSize</A>,
    <A HREF="#IPSetDefOutPutModeExt">IPSetDefOutPutModeExt</A>,
    <A HREF="#IPSetFirstWaveMMMExt">IPSetFirstWaveMMMExt</A>,
    <A HREF="#IPSetIncoreProcExt">IPSetIncoreProcExt</A>, and
    <A HREF="#IPSetSclParamExt">IPSetSclParamExt</A>.
  <LI>Added the constants, UNDO_CHECK, CMD_LINE_FUNC, USAGE_FUNC, WRITE_CMD,
    PROMPT_FUNC, IP_LOG_ERROR, IP_LOG_WARN, IP_LOG_INFO, IP_LOG_PROGRESS,
    IP_LOG_DEBUG.
</UL>

<H3>Topics</H3>
<P>
   <A HREF="#Overview">Overview</A> |
   <A HREF="#Writing">Writing</A> |
   <A HREF="#CompilingLinking">Compiling and Linking</A> |
   <A HREF="#Examples">Examples</A> |
   <A HREF="#Details">Details</A> |
   Release Notes |
   <A HREF="#Reference">Reference</A> |
   <A HREF="Region.html">Dialog Elements</A>
<HR>

<H2><A NAME="Reference">IP Function Reference</A></H2>

<H3>Functions by Category:</H3>
<UL>
   <LI><STRONG><A NAME="FunctionsIO">Input/Output</A></STRONG>
     <DL>
       <DT><A HREF="#IPAddInput">IPAddInput</A><DD>Adds an image input which
         the framework will automatically handle (unless overridden).
       <DT><A HREF="#IPAddOutput">IPAddOutput</A><DD>Adds an image output which
         the framework will automatically handle (unless overridden).
       <DT><A HREF="#IPSetCustRoutine">IPSetCustRoutine</A><DD>Use the
         the OPEN_FILE option to this routine to customize what happens when
         an image input is opened.  Use the CUST_DOIT option to have the
         application be responsible for handling any image output (and many
         other things normally done by the framework).
       <DT><A HREF="#IPSetDefOutPutMode">IPSetDefOutPutMode</A><DD>Sets the
         initial selection for the pixel format of output image data.
         <A HREF="#IPSetDefOutPutModeExt">IPSetDefOutPutModeExt</A> is a more
         flexible version to handle cases where the application has more
         than one output registered with
         <A HREF="#IPAddOutput">IPAddOutput</A>.
       <DT><A HREF="#IPSetNoAutoIO">IPSetNoAutoIO</A><DD>Provides an
         alternative to using CUST_DOIT for cases where application needs
         to perform the image data input and output differently from what
         the framework normally does but is otherwise compatible with the other
         operations the framework performs.
       <DT><A HREF="#IPSetDataPtr">IPSetDataPtr</A><DD>Use in conjunction with
         IPSetNoAutoIO to control which image inputs or output are handled
         automatically or not.
     </DL>
   <LI><STRONG><A NAME="FunctionsUI">User Interaction</A></STRONG>
     <DL>
       <DT><A HREF="#IPSetCustRoutine">IPSetCustRoutine</A><DD>Use of the
         CUS_MENU option is the primary way to customize the main dialog;
         the OPT_MENU option may be useful in unusual circumstances.  Use the
         OPEN_FILE, NEW_REGION, WAVE_FUNC, NEW_XYAREA, CHANGE_MODE, and NEW_RES
         options to update the application-specific user interface elements
         when the user interacts with one of the user interface elements
         created directly by the framework.  Use the CLEAN_UP_PROC option to
         customize what happens when the application exits.  Register
         a CMD_LINE_FUNC routine if you want to allow users to run
         the application in a batch mode.  Typically if you use CMD_LINE_FUNC,
         you will also use USAGE_FUNC and WRITE_CMD.  The former is called
         to print a description of the application-specific command-line
         parameters, and the latter enables the graphical user interface to
         write a command file for the application.  Register a PROMPT_FUNC
         routine if you to allow users to run the application interactively
         with a text interface.
       <DT><A HREF="#IPAddInput">IPAddInput</A><DD>Adds an image input.
       <DT><A HREF="#IPAddOutput">IPAddOutput</A><DD>Adds an image output.
       <DT><A HREF="#IPSetDisChgHandler">IPSetDisChgHandler</A><DD>Registers
         a function so that the user interface can respond to a user's
         interaction with an image window that is an input to the application.
       <DT><A HREF="#IPSetMenuTitle">IPSetMenuTitle</A><DD>Labels the
         window manager frame and icon for your dialog with something more
         informative than "IVEApp".
       <DT><A HREF="#IPSetMenuLoc">IPSetMenuLoc</A><DD>Sets a preferred
         location on the screen for the applications main dialog.
       <DT><A HREF="#IPGetRegionWidgets">IPGetRegionWidgets</A><DD>Returns
         the IDs for the controls over the region processed.
       <DT><A HREF="#IPEnableDoSec">IPEnableDoSec</A><DD>Allows the user
         to select a <A HREF="Region.html#TRIAL_RUN">trial run</A> mode if
         he or she wishes.
       <DT><A HREF="#IPEnableResolutionSelection">IPEnableResolutionSelection</A><DD>
         Allows the user to select which <A HREF="Region.html#R">resolution</A>
         to process.
       <DT><A HREF="#IPEnableRegionSelection">IPEnableRegionSelection</A><DD>
         If the application has multiple inputs registered
         <A HREF="#IPAddInput">IPAddInput</A>, use IPEnableRegionSelection
         to enable region selection (and the corresponding controls in
         the graphical interface) for one or more of the additional inputs.
       <DT><A HREF="#IPAllowMode">IPAllowMode</A><DD>Adds or removes a pixel
         format from the set the user can choose for an output.
       <DT><A HREF="#IPAllowModeChange">IPAllowModeChange</A><DD>Enables or
         disables the user's ability to alter the pixel format for an output.
       <DT><A HREF="#IPGetArg">IPGetArg</A><DD>Returns a command-line argument.
       <DT><A HREF="#IPGetArgCount">IPGetArgCount</A><DD>Returns the number
         of command-line arguments.
       <DT><A HREF="#IPParseIntArg">IPParseIntArg</A><DD>Parses a command-line
         argument for integer values.
       <DT><A HREF="#IPParseRealArg">IPParseRealArg</A><DD>Parses a
         command-line argument for floating-point values.
       <DT><A HREF="#IPPromptInt">IPPromptInt</A><DD>Prompts, via a text
         interface, for one or more integer values.
       <DT><A HREF="#IPPromptReal">IPPromptReal</A><DD>Prompts, via a text
         interface, for one or more floating-point values.
       <DT><A HREF="#IPPromptString">IPPromptString</A><DD>Prompts, via a text,
         interface, for a string of characters.
       <DT><A HREF="#IPAppendCommand">IPAppendCommand</A><DD>For use from
         a WRITE_CMD routine, appends to the command file.
       <DT><A HREF="#IPHasGUI">IPHasGui</A><DD>Indicates whether the
         application is running with a graphical interface or not.
       <DT><A HREF="#IPIsInteractive">IPIsInteractive</A><DD>Indicates whether
         or not the application can query the user.
       <DT><A HREF="#IPDisplayMessage">IPDisplayMessage</A><DD>Displays a
         message to the user.
       <DT><A HREF="#IPPostInfo">IPPostInfo</A><DD>Is a synonym for
         <A HREF="#IPDisplayMessage">IPDisplayMessage</A>(message, IP_LOG_PROGRESS).
     </DL>
   <LI><STRONG><A NAME="FunctionsProc">Image Processing</A></STRONG>
     <DL>
       <DT><A HREF="#IPSetCustRoutine">IPSetCustRoutine</A><DD>To customize
         the processing done, applications either use a combination of the
         INIT_PROC, PROC_FUNC, and AFTER_DO_IT options or use the CUST_DOIT
         option.  In either case, the routine registered with CHECK_PARAMS
         is invoked prior to processing, and the routine registered with
         UNDO_CHECK is invoked afterwards.
       <DT><A HREF="#IPSetProcType">IPSetProcType</A><DD>Controls which
         dimensions are the inner loops which the application is responsible
         for and which dimensions are the outer loops which the framework
         handles.
       <DT><A HREF="#IPSetComputeSize">IPSetComputeSize</A><DD>If results of
         processing are not the same size as the input region, use
         IPSetComputeSize to register a callback with the library to inform
         it what the processed size is.
       <DT><A HREF="#IPSetNoAppend">IPSetNoAppend</A><DD>Call to prohibit
         appending output image results to an existing data set.
       <DT><A HREF="#IPSetAppendOptions">IPSetAppendOptions</A><DD>Controls
         whether appending is allowed on a per-output basis.
       <DT><A HREF="#IPGetAppendOptions">IPGetAppendOptions</A><DD>Returns
         whether appending is allowed on a per-output basis.
       <DT><A HREF="#IPSetIncoreProc">IPSetIncoreProc</A><DD>Enables a
         memory saving optimization when using PROC_FUNC and the processing
         can be done in place.
         <A HREF="#IPSetIncoreProcExt">IPSetIncoreProcExt</A> is a more
         flexible version to handle cases where the application has more
         than one output registered with
         <A HREF="#IPAddOutput">IPAddOutput</A>.
       <DT><A HREF="#IPSetSclParam">IPSetSclParam</A><DD>Modifies the image
         scaling parameters that are initially set for output image windows.
         <A HREF="#IPSetSclParamExt">IPSetSclParamExt</A> is a more flexible
         version to handle cases where more than one output is registered
         with <A HREF="#IPAddOutput">IPAddOutput</A>.
       <DT><A HREF="#IPSetAutoScale">IPSetAutoScale</A><DD>For 2D processing
         done via a PROC_FUNC routine, use this function to set whether
         images in output image windows are scaled separately or by wavelength.
       <DT><A HREF="#IPIsOpen">IPIsOpen</A><DD>Returns whether or not an
         input or output under the framework's control is open.
       <DT><A HREF="#IPGetDefOutPutMode">IPGetDefOutPutMode</A><DD>Returns
         how pixel values in the output are formatted.
         <A HREF="#IPGetDefOutPutModeExt">IPGetDefOutPutModeExt</A> is a more
         flexible version and is useful if the application registers more than
         one output with <A HREF="#IPAddOutput">IPAddOutput</A>.
       <DT><A HREF="#IPGetRegionInfo">IPGetRegionInfo</A><DD>Returns the
         bounds of the region selected for processing.
         <A HREF="#IPGetRegionInfoExt">IPGetRegionInfoExt</A> is a more
         flexible version to handle cases where the application has
         registered more than one input with
         <A HREF="#IPAddInput">IPAddInput</A> and allows region selection
         to be done independently for the different inputs.
       <DT><A HREF="#IPGetWaveOrder">IPGetWaveOrder</A><DD>Returns the ordering
         of the wavelengths to process.
       <DT><A HREF="#IPGetDataPtr">IPGetDataPtr</A><DD>Returns a pointer to
         the input image data to be processed or the output image data to be
         filled in.
       <DT><A HREF="#IPGetCurZWT">IPGetCurZWT</A><DD>Returns the source
         and destination for the chunk of data currently being processed.
         <A HREF="#IPGetCurZWT">IPGetCurZWTExt</A> is a more flexible version
         to handle the case where the application has more than one input
         registered with <A HREF="#IPAddInput">IPAddInput</A> or more than
         one output registered with <A HREF="#IPAddOutput">IPAddOutput</A>.
       <DT><A HREF="#IPGetCurRes">IPGetCurRes</A><DD>Returns the resolution
         selected by the user.
       <DT><A HREF="#IPCheckInterrupt">IPCheckInterrupt</A><DD>Checks for
         whether or not the user has chosen to interrupt the processing.
       <DT><A HREF="#IPDesist">IPDesist</A><DD>Halts processing.
       <DT><A HREF="#IPIsAppending">IPIsAppending</A><DD>If processing
         is done via a PROC_FUNC routine registered with
         <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>, returns whether
         or not an output is appending to existing data.
       <DT><A HREF="#IPSetFirstWaveMMM">IPSetFirstWaveMMM</A><DD>If processing
         is done via a PROC_FUNC routine registered with
         <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A> and the processing
         is not 2D, the application should use IPSetFirstWaveMMM to inform
         the library what the statistics are for the first wavelength of
         output.  <A HREF="#IPSetFirstWaveMMMExt">IPSetFirstWaveMMMExt</A> is
         a more flexible version to handle the case where the application has
         more than one output registered with
         <A HREF="#IPAddOutput">IPAddOutput</A>.
       <DT><A HREF="#IPReportSectionStats">IPReportSectionStats</A><DD>If the
         application performs 2D processing via a PROC_FUNC routine and has
         more than one output registered with
         <A HREF="#IPAddOutput">IPAddOutput</A>, it should use
         IPReportSectionStats to report the statistics for the most recently
         processed section in outputs other than the first.
     </DL>
</UL>

<H3>Functions by Name:</H3>
<UL>
   <LI><A HREF="#IPAddInput">IPAddInput</A>
   <LI><A HREF="#IPAddOutput">IPAddOutput</A>
   <LI><A HREF="#IPAllowMode">IPAllowMode</A>
   <LI><A HREF="#IPAllowModeChange">IPAllowModeChange</A>
   <LI><A HREF="#IPAppendCommand">IPAppendCommand</A>
   <LI><A HREF="#IPAppSpecifics">IPAppSpecifics</A>
   <LI><A HREF="#IPCheckInterrupt">IPCheckInterrupt</A>
   <LI><A HREF="#IPDesist">IPDesist</A>
   <LI><A HREF="#IPDisplayMessage">IPDisplayMessage</A>
   <LI><A HREF="#IPEnableDoSec">IPEnableDoSec</A>
   <LI><A HREF="#IPEnableRegionSelection">IPEnableRegionSelection</A>
   <LI><A HREF="#IPEnableResolutionSelection">IPEnableResolutionSelection</A>
   <LI><A HREF="#IPGetAppendOptions">IPGetAppendOptions</A>
   <LI><A HREF="#IPGetCurRes">IPGetCurRes</A>
   <LI><A HREF="#IPGetCurZWT">IPGetCurZWT</A>
   <LI><A HREF="#IPGetCurZWTExt">IPGetCurZWTExt</A>
   <LI><A HREF="#IPGetDataPtr">IPGetDataPtr</A>
   <LI><A HREF="#IPGetDefOutPutMode">IPGetDefOutPutMode</A>
   <LI><A HREF="#IPGetDefOutPutModeExt">IPGetDefOutPutModeExt</A>
   <LI><A HREF="#IPGetFilename">IPGetFilename</A>
   <LI><A HREF="#IPGetRegionInfo">IPGetRegionInfo</A>
   <LI><A HREF="#IPGetRegionInfoExt">IPGetRegionInfoExt</A>
   <LI><A HREF="#IPGetWaveOrder">IPGetWaveOrder</A>
   <LI><A HREF="#IPGetRegionWidgets">IPGetRegionWidgets</A>
   <LI><A HREF="#IPHasGUI">IPHasGUI</A>
   <LI><A HREF="#IPIsAppending">IPIsAppending</A>
   <LI><A HREF="#IPIsInteractive">IPIsInteractive</A>
   <LI><A HREF="#IPIsOpen">IPIsOpen</A>
   <LI><A HREF="#IPParseIntArg">IPParseIntArg</A>
   <LI><A HREF="#IPParseRealArg">IPParseRealArg</A>
   <LI><A HREF="#IPPromptInt">IPPromptInt</A>
   <LI><A HREF="#IPPromptReal">IPPromptReal</A>
   <LI><A HREF="#IPPromptString">IPPromptString</A>
   <LI><A HREF="#IPPostInfo">IPPostInfo</A>
   <LI><A HREF="#IPReportSectionStats">IPReportSectionStats</A>
   <LI><A HREF="#IPSetAppendOptions">IPSetAppendOptions</A>
   <LI><A HREF="#IPSetAutoScale">IPSetAutoScale</A>
   <LI><A HREF="#IPSetComputeSize">IPSetComputeSize</A>
   <LI><A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>
   <LI><A HREF="#IPSetDataPtr">IPSetDataPtr</A>
   <LI><A HREF="#IPSetDefOutPutMode">IPSetDefOutPutMode</A>
   <LI><A HREF="#IPSetDefOutPutModeExt">IPSetDefOutPutModeExt</A>
   <LI><A HREF="#IPSetDisChgHandler">IPSetDisChgHandler</A>
   <LI><A HREF="#IPSetFirstWaveMMM">IPSetFirstWaveMMM</A>
   <LI><A HREF="#IPSetFirstWaveMMMExt">IPSetFirstWaveMMMExt</A>
   <LI><A HREF="#IPSetIncoreProc">IPSetIncoreProc</A>
   <LI><A HREF="#IPSetIncoreProcExt">IPSetIncoreProcExt</A>
   <LI><A HREF="#IPSetMenuLoc">IPSetMenuLoc</A>
   <LI><A HREF="#IPSetMenuTitle">IPSetMenuTitle</A>
   <LI><A HREF="#IPSetNoAppend">IPSetNoAppend</A>
   <LI><A HREF="#IPSetNoAutoIO">IPSetNoAutoIO</A>
   <LI><A HREF="#IPSetProcType">IPSetProcType</A>
   <LI><A HREF="#IPSetSclParam">IPSetSclParam</A>
   <LI><A HREF="#IPSetSclParamExt">IPSetSclParamExt</A>
</UL>

<H3>Topics</H3>
<P>
   <A HREF="#Overview">Overview</A> |
   <A HREF="#Writing">Writing</A> |
   <A HREF="#CompilingLinking">Compiling and Linking</A> |
   <A HREF="#Examples">Examples</A> |
   <A HREF="#Details">Details</A> |
   <A HREF="#ReleaseNotes">Release Notes</A> |
   Reference |
   <A HREF="Region.html">Dialog Elements</A>
<HR>

<H2><A NAME="IPAddInput">IPAddInput</A></H2>
<H3>Overview</H3>
<P>Adds an input image file that will be automatically handled by the IP
framework (automatic handling can be overridden with
<A HREF="#IPSetNoAutoIO">IPSetNoAutoIO</A> or doing processing with a
CUST_DOIT function).  IPAddInput should be called from within
<A HREF="#IPAppSpecifics">IPAppSpecifics</A>.  In the graphical user
interface, each input image file will have a button to open a file selection
dialog and a text entry field to display and edit the file selected.  These
user interface elements appear at the top of the dialog, immediately below the
user interface elements added by any previous calls to IPAddInput.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPAddInput(int in_stream, char* str, int req_flag, int win_only, IPCallback file_open_hdl, int argu);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPAddInput(in_stream, str, req_flag, win_only, file_open_hdl, argu)</CODE>
<BR><CODE>integer in_stream, req_flag, win_only, argu</CODE>
<BR><CODE>character*(*) str</CODE>
<BR><CODE>external file_open_hdl</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>in_stream</VAR><DD>(in) <VAR>in_stream</VAR> is the IM
    stream number to use for the file.  <VAR>in_stream</VAR> must be a valid
    IM stream number (i.e. greater than zero).
  <DT><VAR>str</VAR><DD>(in) <VAR>str</VAR> is used as the label for the button
    to open the file selection dialog.
  <DT><VAR>req_flag</VAR><DD>(in) If <VAR>req_flag</VAR> is nonzero, the file
    must be present before processing proceeds.
  <DT><VAR>window_only</VAR><DD>(in) If <VAR>window_only</VAR> is nonzero, the
    input must be from a window; otherwise the input may come from a window
    or file.
  <DT><VAR>file_open_hdl</VAR><DD>(in) Specifies the routine that is called
    after <VAR>instr</VAR> is opened and its header is read.  If IPAddInput is
    called from C/C++, <VAR>file_open_hdl</VAR> should be a NULL or a
    function which does not return a value and takes a single integer
    argument; the value of <VAR>in_stream</VAR> is passed as this argument.  If
    called from Fortran, <VAR>file_open_hdl</VAR> should be a subroutine
    which has one integer argument; a temporary copy of <VAR>in_stream</VAR>
    will be passed as this argument.
  <DT><VAR>argu</VAR><DD>(in) Is currently not used.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPAddOutput">IPAddOutput</A></H2>
<H3>Overview</H3>
<P>Adds an output image file that will be automatically handled by the IP
framework (automatic handling can be overridden with
<A HREF="#IPSetNoAutoIO">IPSetNoAutoIO</A>.  IPAddOutput should be called
from within <A HREF="#IPAppSpecifics">IPAppSpecifics</A>.  In the graphical
user interface, the output image file will have a button to open a file
selection dialog, a text entry field to display and edit the file selected,
and a pulldown menu to control the format of data values. These controls
will appear immediately below the controls added previous calls to
IPAddOutput or, if there were no previous calls to IPAddOutput, all the
controls for the input data stacks.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPAddOutput(int out_stream, char* str, int req_flag, int win_only, IPCallback file_open_hdl, int argu);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPAddOutput(out_stream, str, req_flag, win_only, file_open_hdl, argu)</CODE>
<BR><CODE>integer out_stream, req_flag, win_only, argu</CODE>
<BR><CODE>character*(*) str</CODE>
<BR><CODE>external file_open_hdl</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>out_stream</VAR><DD>(in) <VAR>out_steam</VAR> is the IM stream
    number to use for the file.  <VAR>out_stream</VAR> must be a valid IM
    stream number (greater than zero).
  <DT><VAR>str</VAR><DD>(in) <VAR>str</VAR> is used as the label for the button
    to open the file selection dialog.
  <DT><VAR>req_flag</VAR><DD>(in) If <VAR>req_flag</VAR> is nonzero, the file
    must be present before processing proceeds.
  <DT><VAR>window_only</VAR><DD>(in) If <VAR>window_only</VAR> is nonzero, the
    input must be from a window; otherwise the input may come from a window
    or file.
  <DT><VAR>file_open_hdl</VAR><DD>(in) If a CUST_DOIT routine has not been
    registered with <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>,
    <VAR>file_open_hdr</VAR> specifies the routine that is called
    after <VAR>instr</VAR> is opened and its header is set.  If called from
    C/C++, <VAR>file_open_hdl</VAR> should be a NULL or a
    function which does not return a value and takes a single integer
    argument; the value of <VAR>in_stream</VAR> is passed as this argument.  If
    called from Fortran, <VAR>file_open_hdl</VAR> should be a subroutine
    which has one integer argument; a temporary copy of
    <VAR>out_stream</VAR> will be passed as this argument.
  <DT><VAR>argu</VAR><DD>(in) Is currently not used.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPAllowMode">IPAllowMode</A></H2>
<H3>Overview</H3>
<P>For one of the outputs registered with
<A HREF="#IPAddOutput">IPAddOutput</A>, adds or removes a pixel format from
the set of choices available to the user.  If you want to have the pixel
format for an output be completely under control of the application (via
<A HREF="#IPSetDefOutPutMode">IPSetDefOutPutMode</A> or
<A HREF="#IPSetDefOutPutModeExt">IPSetDefOutPutModeExt</A>), use
<A HREF="#IPAllowModeChange">IPAllowModeChange</A> instead.

<P>When using this function to remove a choice from the set, the application
should check what the current choice is (via
<A HREF="#IPGetDefOutPutMode">IPGetDefOutPutMode</A> or
<A HREF="#IPGetDefOutPutModeExt">IPGetDefOutPutModeExt</A>) and, if it
matches the choice be removed, set the current choice to one of the allowed
choices.

<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPAllowMode(int out_stream, int mode, int yesno);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPAllowMode(out_stream, mode, yesno)</CODE>
<BR><CODE>integer out_stream, mode, yesno</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>out_stream</VAR><DD>(in) Is the IM stream number of the output
    to modify.
  <DT><VAR>mode</VAR><DD>(in) Is either SAME_AS_FIRST_INPUT or the
    <A HREF="IM_ref2.html#PixelDataTypes">IM pixel type code</A> that is
    to be added or removed from the set of available choices.
  <DT><VAR>yesno</VAR><DD>(in) If zero, <VAR>mode</VAR> is removed from the
    set of available choices; otherwise, <VAR>mode</VAR> is added to the set
    of available choices.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPAllowModeChange">IPAllowModeChange</A></H2>
<H3>Overview</H3>
<P>Use this function to enable or disable the user's control over the format
of an output.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPAllowModeChange(int out_stream, int yesno);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPAllowMode(out_stream, yesno)</CODE>
<BR><CODE>integer out_stream, yesno</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>out_stream</VAR><DD>(in) Is the IM stream number of the output
    to modify.
  <DT><VAR>yesno</VAR><DD>(in) If zero, the user can not set the format
    for <VAR>out_stream</VAR> and the format is completely under the
    application's control.  If one, the user can change the format
    for <VAR>out_stream</VAR>.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPAppendCommand">IPAppendCommand</A></H2>
<H3>Overview</H3>
<P>Appends the given text to the command file currently being generated.
The appended text will be separated from what was previously written by at
least a space character.  This function only has an effect when a command
file is being generated (i.e. a WRITE_CMD callback, registered with
<A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>, is in progress).
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPAppendCommand(const char* text);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPAppendCommand(text)</CODE>
<BR><CODE>character*(*) text</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>text</VAR><DD>(in) Is the text to be appended to the command file.
    Since the text is included as part of a command line for the shell, care
    should be taken that characters with special meaning to the shell
    (for example spaces, newlines, dollar signs...) are quoted when necessary.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPAppSpecifics">IPAppSpecifics</A></H2>
<H3>Overview</H3>
<P>The IP framework calls the user-provided routine IPAppSpecifics at
startup.  Any calls to the following functions should be made from
within IPAppSpecifics to have the intended effect (these calls add user
interface elements or control what parameters are expected in the command-line
or text interfaces):
<UL>
  <LI><A HREF="#IPSetMenuTitle">IPSetMenuTitle</A>
  <LI><A HREF="#IPSetMenuLoc">IPSetMenuLoc</A>
  <LI><A HREF="#IPAddInput">IPAddInput</A>
  <LI><A HREF="#IPAddOutput">IPAddOutput</A>
  <LI><A HREF="#IPEnableDoSec">IPEnableDoSec</A>
  <LI><A HREF="#IPEnableRegionSelection">IPEnableRegionSelection</A>
  <LI><A HREF="#IPEnableResolutionSelection">IPEnableResolutionSelection</A>
</UL>

<P>The following functions are frequently called from within IPAppSpecifics:
<UL>
  <LI><A HREF="#IPSetProcType">IPSetProcType</A>
  <LI><A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>
  <LI><A HREF="#IPSetIncoreProc">IPSetIncoreProc</A>
  <LI><A HREF="#IPSetIncoreProcExt">IPSetIncoreProcExt</A>
  <LI><A HREF="#IPSetDefOutPutMode">IPSetDefOutPutMode</A>
  <LI><A HREF="#IPSetDefOutPutModeExt">IPSetDefOutPutModeExt</A>
  <LI><A HREF="#IPSetComputeSize">IPSetComputeSize</A>
  <LI><A HREF="#IPSetDisChgHandler">IPSetDisChgHandler</A>
  <LI><A HREF="#IPSetAppendOptions">IPSetAppendOptions</A>
  <LI><A HREF="#IPSetNoAppend">IPSetNoAppend</A>
  <LI><A HREF="#IPSetNoAutoIO">IPSetNoAutoIO</A>
  <LI><A HREF="#IPAllowMode">IPAllowMode</A>
  <LI><A HREF="#IPAllowModeChange">IPAllowModeChange</A>
</UL>

<H3>C Prototype</H3>
<P><CODE>int IPAppSpecifics(void);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPAppSpecifics()</CODE>
<H3>Return Value</H3>
<P>The value returned by IPAppSpecifics in C is not used.

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPCheckInterrupt">IPCheckInterrupt</A></H2>
<H3>Overview</H3>
<P>If the application does extensive processing within one of the functions
registered with <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A> (typically
PROC_FUNC or CUST_DOIT), periodic calls to IPCheckInterrupt should be made
to check if the user has requested for processing to halt.  If a halt has
been requested, the application should return from the registered function
promptly.

<P>For standard processing, the framework checks for a user-requested halt
between each call to the PROC_FUNC routine (i.e. for each section in 2D
processing or for each volume in 3D processing).  That may be sufficient,
depending on the application, to maintain adequate responsiveness without
additional calls to IPCheckInterrupt.

<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>int IPCheckInterrupt(void);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>integer function IPCheckInterrupt()</CODE>
<H3>Return Value</H3>
<P>Returns one if the user has requested that processing be interrupted and
zero if not.

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPDesist">IPDesist</A></H2>
<H3>Overview</H3>
<P>If IPDesist is called from within a routine while the application is
processing data or parsing the command line, the application will then stop
processing when the callback returns, invoke any cleanup actions, and then
either resume prompting for input parameters in the interactive case or exit
in the non-interactive case.  To be specific, IPDesist will have the above
effect when called from within one of the following routines: the INIT_PROC,
PROC_FUNC, CHECK_PARAMS, CMD_LINE_FUNC, or PROMPT_FUNC routines registered
with <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A> or callbacks registered
with <A HREF="#IPSetComputeSize">IPSetComputeSize</A>,
<A HREF="#IPAddOutput">IPAddOutput</A>, or
<A HREF="#IPSetDisChgHandler">IPSetDisChgHandler</A> (for IPSetDisChgHandler
callbacks, the effect will only happen if the callback occurs during
processing).  IPDesist will also halt processing if the application is running
non-interactively and IPDesist is called from one of the following callbacks:
the OPEN_FILE, NEW_REGION, WAVE_FUNC, CHANGE_MODE, or NEW_RES routines
registered with <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A> or a callback
registered with <A HREF="#IPAddInput">IPAddInput</A>.

<P>If IPDesist is called from a WRITE_CMD routine registered with
<A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>, the framework will try to
complete writing the script when the callback returns.  However, it will not
take any further actions (running it locally or submitting it to a batch
queue) that the user had requested.

<P>In all other cases IPDesist has no effect.

<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPDesist(void);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPDesist()</CODE>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPDisplayMessage">IPDisplayMessage</A></H2>
<H3>Overview</H3>
<P>Displays a message for the user in a manner that is consistent with the mode
(interactive with a graphical interface, interactive with a text interface,
or non-interactive) that the application is running in.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPDisplayMessage(const char* msg, int priority);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPDisplayMessage(msg, priority)</CODE>
<BR><CODE>character*(*) msg</CODE>
<BR><CODE>integer priority</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>msg</VAR><DD>(in) Is the message to be displayed.
  <DT><VAR>priority</VAR><DD>(out) The <VAR>priority</VAR> affects the
    formatting of the message.  <VAR>priority</VAR> is also used to filter and
    tag messages.  Valid values for <VAR>priority</VAR>, in order of
    decreasing priority level, are (these constants defined in ip.h for C/C++
    and ip.inc for Fortran):
    <DL>
      <DT>IP_LOG_ERROR<DD>Use for messages about conditions which prevent
        further processing.  When running with a graphical user interface,
        messages with this priority are displayed in dialogs like those
        created by <A HREF="WM.html#WMConfirmError">WMConfirmError</A>.  When
        running interactively in text-mode or running non-interactively,
        messages with this priority are written to standard error.
      <DT>IP_LOG_WARN<DD>Use for messages about conditions which may be
        serious but which do not prevent further processing.  When running
        with a graphical user interface, messages with this priority are
        displayed in dialogs like those created by
        <A HREF="WM.html#WMConfirmError">WMConfirmError</A>.  When running
        interactively in text-mode or running non-interactively, messages with
        this priority are written to standard error.
      <DT>IP_LOG_INFO<DD>Use for useful informational messages.  When
        running with a graphical user interface, messages with this priority
        are displayed in dialogs like those created by
        <A HREF="WM.html#WMPostInfo">WMPostInfo</A>.  When running
        interactively in text-mode or running non-interactively, messages
        with this priority are written to standard output.
      <DT>IP_LOG_PROGRESS<DD>Use for messages which indicate the progress
        of processing.  When running with a graphical user interface, messages
        with this priority are written to the status field.  This field can
        only display twenty characters; messages longer than that are
        truncated.  When running interactively in text-mode or running
        non-interactively, messages with this priority are not displayed
        by default.
      <DT>IP_LOG_DEBUG<DD>Use for messages which are only of interest
        when by debugging.  Messages with this priority are written to
        standard output and, by default, are not displayed.
    </DL>
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPEnableDoSec">IPEnableDoSec</A></H2>
<H3>Overview</H3>
<P>The documentation for the user interface common to all IP-based applications
describes a <A HREF="Region.html#TRIAL_RUN">trial run mode</A> to make it
easier for the user to iteratively adjust processing parameters to achieve
the desired output.  Calling IPEnableDoSec from within
<A HREF="#IPAppSpecifics">IPAppSpecifics</A>, tells the library to offer the
user the choice of whether or not to perform processing in a trial run mode.
The application does not need to do anything else for the trial run mode as
the other details are handled internally by the IP framework.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPEnableDoSec(void);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPEnableDoSec()</CODE>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPEnableRegionSelection">IPEnableRegionSelection</A></H2>
<H3>Overview</H3>
<P>If an application has multiple inputs registered with
<A HREF="#IPAddInput">IPAddInput</A>, the user is allowed to select the
region to process from the first input, and the same region is used for all
the other inputs.  The application can choose to allow the user to
independently select a region for the one or more of the other inputs by
calling IPEnableRegionSelection for each of the inputs that should allow
region selection.  To have the desired effect, IPEnableRegionSelection
must be called from within <A HREF="#IPAppSpecifics">IPAppSpecifics</A>.

<P>If region selection is allowed for multiple inputs, the framework still
imposes the restriction that the regions have the same sizes in all dimensions.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPEnableRegionSelection(int in_stream);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPEnableRegionSelection(in_stream)</CODE>
<BR><CODE>integer in_stream</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>in_stream</VAR><DD>(in) Is the IM stream number of the input
    for which region selection should be allowed.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPEnableResolutionSelection">IPEnableResolutionSelection</A></H2>
<H3>Overview</H3>
<P>By default, IP-based applications process the highest resolution data set
present in a file.  If you want to allow the user to select which resolution
to process, call IPEnableResolutionSelection from within
<A HREF="#IPAppSpecifics">IPAppSpecifics</A>.  Your application can then use
<A HREF="#IPGetCurRes">IPGetCurRes</A> to determine the resolution the user
has selected.  To have a callback function invoked when the user changes the
resolution, call <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A> with the
NEW_RES option.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPEnableResolutionSelection(void);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPEnableResolutionSelection()</CODE>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPGetAppendOptions">IPGetAppendOptions</A></H2>
<H3>Overview</H3>
<P>When an output registered with <A HREF="#IPAddOutput">IPAddOutput</A> would
modify existing data, there are two factors that determine what choices the
user has:  compatibility between the size of the existing data and the output
to be generated and restrictions placed by the application on what sort of
operations are permitted.  IPGetAppendOptions returns the settings for the
latter.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPGetAppendOptions(int out_stream, int* in_z, int* in_w, int* in_t, int* replace);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPGetAppendOptions(out_stream, in_z, in_w, in_t, replace)</CODE>
<BR><CODE>integer out_stream, in_z, in_w, in_t, replace</CODE>
<H3>Parameters</H3>
<DL>
   <DT><VAR>out_stream</VAR><DD>(in) Is the IM stream number for the output of
     interest.
   <DT><VAR>in_z</VAR><DD>(out) If *in_z in C or in_z in Fortran is not zero,
     then the application allows the framework to append to existing
     data along the z dimension when the sizes and layout of the existing
     data and the processing results permit it.  Otherwise, appending along
     the z dimension is not allowed.
   <DT><VAR>in_w</VAR><DD>(out) If *in_w in C or in_w in Fortran is not zero,
     then the application allows the framework to append to existing
     data as additional wavelengths if the sizes and layout of the existing
     data and the processing results permit it.  Otherwise, appending
     wavelengths is not allowed.
   <DT><VAR>in_t</VAR><DD>(out) If *in_t in C or in_t in Fortran is not zero,
     then the application allows the framework to append to existing
     data as additional time points when the sizes and layout of the existing
     data and the processing results permit it.  Otherwise, appending
     additional time points is not allowed.
   <DT><VAR>replace</VAR><DD>(out) If *replace in C or replace in Fortran is
     not zero, then the application allows the framework to replace the
     contents of an input with an output in the case where an input and output
     have the same name and the layout and sizes of the existing data and
     processing results permit the replacement.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPGetArg">IPGetArg</A></H2>
<H3>Overview</H3>
<P>Returns an application-specific argument from the command-line.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>char* IPGetArg(int iarg);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>integer IPGetArg(iarg, arg)</CODE>
<BR><CODE>integer iarg</CODE>
<BR><CODE>character arg(*)</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>iarg</VAR><DD>(in) Is the index of the argument to retrieve.
    A value of zero retrieves the name of the application used on the command
    line; a value of one retrieves the first application-specific argument.
  <DT><VAR>arg</VAR><DD>(out, Fortran only) The argument to be retrieved
    is copied to arg and either truncated (if arg is shorter than the argument)
    or padded with spaces (if arg is longer than the argument).  If
    <VAR>iarg</VAR> is less than zero or greater than the result of
    <A HREF="#IPGetArgCount">IPGetArgCount</A>, arg is filled with spaces.
</DL>
<H3>Return Value</H3>
<P>In C, a pointer to the argument is returned or NULL if <VAR>iarg</VAR>
is less than zero or greater than the result of
<A HREF="#IPGetArgCount">IPGetArgCount</A>.  In Fortran, the actual length
of the argument is returned (i.e. the length before any truncation or
padding necessary to fit it into <VAR>arg</VAR>) or -1 if <VAR>iarg</VAR>
was out of bounds.
<HR>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPGetArgCount">IPGetArgCount</A></H2>
<H3>Overview</H3>
<P>Returns the number of application-specific arguments on the command-line.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>int IPGetArgCount(void);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>integer function IPGetArgCount()</CODE>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPGetCurRes">IPGetCurRes</A></H2>
<H3>Overview</H3>
<P>Returns the resolution selected for a given input.  Zero is the highest
resolution, one is the next highest resolution, and so on.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>int IPGetCurRes(int im_stream);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>integer function IPGetCurRes(im_stream)</CODE>
<BR><CODE>integer im_stream</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>im_stream</VAR><DD>(in) Is the IM stream number for the input
    of interest.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPGetCurZWT">IPGetCurZWT</A></H2>
<H3>Overview</H3>
<P>This function has the same affect as the following sequence of calls in
C:
<BR><CODE>int zwt[6];</CODE>
<BR><CODE><A HREF="#IPGetCurZWTExt">IPGetCurZWTExt</A>(i_stream, zwt);</CODE>
<BR><CODE><A HREF="#IPGetCurZWTExt">IPGetCurZWTExt</A>(o_stream, zwt + 3);</CODE>
<BR>where <VAR>i_stream</VAR> is the stream number for the first input
registered with <A HREF="#IPAddInput">IPAddInput</A> and <VAR>o_stream</VAR>
is the stream number for the first output registered with
<A HREF="#IPAddOutput">IPAddOutput</A>.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPGetCurZWT(int zwt[6]);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPGetCurZWT(zwt)</CODE>
<BR><CODE>integer zwt(6)</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>zwt</VAR><DD>(out) The first 3 elements of zwt are set to the
    current z, wavelength, and time indices, respectively, of the first
    input stack.  The fourth through sixth elements of zwt are set to the
    current z, wavelength, and time indices, respectively, of the first
    output stack.  See the documentation of
    <A HREF="#IPGetCurZWTExt">IPGetCurZWTExt</A> for details.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPGetCurZWTExt">IPGetCurZWTExt</A></H2>
<H3>Overview</H3>
<P>If an application does not use a CUST_DOIT routine for processing, it can
call IPGetCurZWTExt to determine the z, wavelength, and time indices
corresponding to the current stage or processing.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPGetCurZWT(int im_stream, int izwt[3]);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPGetCurZWT(im_stream, izwt)</CODE>
<BR><CODE>integer in_stream, izwt(3)</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>im_stream</VAR><DD>(in) Is the IM stream number for the input
    or output of interest.
  <DT><VAR>izwt</VAR><DD>(out) <VAR>izwt</VAR>[0] (<VAR>izwt</VAR>(1) in
    Fortran) is the current z index (0-based) for <VAR>im_stream</VAR>.
    <VAR>izwt</VAR>[1] (<VAR>izwt</VAR>(2) in Fortran) is the current
    wavlength index (0-based).  <VAR>izwt</VAR>[2] (<VAR>izwt</VAR>(2) in
    Fortran) is the current time point index (0-index).  If called from
    an application with a CUST_DOIT routine registered or while processing
    is not in progress, the values returned in <VAR>izwt</VAR> are the
    the indices for the first section to process.  For an application which
    does not use a CUST_DOIT routine but which does three or four dimensional
    processing, the values in <VAR>izwt</VAR> are the indices for the first
    section in the current three or four dimensional chunk:  if three
    dimensional processing is done via the THREE_D option to
    <A HREF="#IPSetProcType">IPSetProcType</A>, the first element of
    <VAR>izwt</VAR> is always the starting z index; if three dimensional
    processing is done via the THREE_D_XYT option to
    <A HREF="#IPSetProcType">IPSetProcType</A>, the third element of
    <VAR>izwt</VAR> is always the starting time point index; if four
    dimensional processing is done via the FOUR_D option to
    <A HREF="#IPSetProcType">IPSetProcType</A>, the first element of
    of <VAR>izwt</VAR> is always the starting z index and the third element
    is always the starting time point index; if four dimensional processing is
    done via the FOUR_D_WAVE option to
    <A HREF="#IPSetProcType">IPSetProcType</A>, the first element of
    <VAR>izwt</VAR> is always the starting z index and the second element of
    <VAR>izwt</VAR> is always the index of the first wavelength.  If
    <VAR>im_stream</VAR> is an input stream, the z index (i.e. the first
    element of <VAR>izwt</VAR>) is always with respect to the highest
    resolution data set in the input.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPGetDataPtr">IPGetDataPtr</A></H2>
<H3>Overview</H3>
<P>During processing (i.e. in the INIT_PROC, PROC_FUNC, CUST_DOIT, or
AFTER_DO_IT routines registered through
<A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>), use IPGetDataPtr
to return the array that holds the image data for one of the inputs or outputs.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>float* IPGetDataPtr(int im_stream);</CODE>
<H3>Fortran Prototype</H3>
<P><VAR>pointer_type</VAR> <CODE>function IPGetDataPtr(im_stream)</CODE>
<BR><CODE>integer im_stream</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>im_stream</VAR><DD>(in) Is a stream number that had been used in a
    call to <A HREF="#IPAddInput">IPAddInput</A> or
    <A HREF="#IPAddOutput">IPAddOutput</A>.
</DL>
<H3>Return Value</H3>
<P>A pointer to the first element in the array is returned.  The elements
of the array are floating-point values (unless the application has used
<A HREF="IM_ref2.html">IMAlCon</A> on the stream).  If the input or output
associated with <VAR>im_stream</VAR> has complex-valued image data, there
will be two floating-point values per pixel: the first is the real part and
the second is the imaginary part; otherwise there is one floating-point value
per pixel.

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPGetDefOutPutMode">IPGetDefOutPutMode</A></H2>
<H3>Overview</H3>
<P>Returns the current selection for the format of each pixel in the first
output registered with <A HREF="#IPAddOutput">IPAddOutput</A>.  Use
<A HREF="#IPGetDefOutPutModeExt">IPGetDefOutPutModeExt</A> to get the
format selection for other outputs.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>int IPGetDefOutPutMode(void);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>integer function IPGetDefOutPutMode()</CODE>
<H3>Return Value</H3>
<P>If no output has been registered with <A HREF="#IPAddOutput">IPAddOutput</A>
this function returns SAME_AS_FIRST_INPUT.  Otherwise, the current selection
in the mode menu for the first output is returned.  It will either be
SAME_AS_FIRST_INPUT (defined in ip.h for C/C++ or ip.inc for Fortran) or one
of the  <A HREF="IM_ref2.html#PixelDataTypes">IM pixel type codes</A>.  

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPGetDefOutPutModeExt">IPGetDefOutPutModeExt</A></H2>
<H3>Overview</H3>
<P>Returns the current selection for the format of each pixel in an output
registered with <A HREF="#IPAddOutput">IPAddOutput</A>.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>int IPGetDefOutPutModeExt(int out_stream);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>integer function IPGetDefOutPutModeExt(out_stream)</CODE>
<BR><CODE>integer out_stream</CODE>
<H3>Parameters</H3>
<DL>
   <DT><VAR>out_stream</VAR><DD>(in) Is the stream number that was used when
     registering the output of interest with
     <A HREF="#IPAddOutput">IPAddOutput</A>.
</DL>
<H3>Return Value</H3>
<P>If <VAR>out_stream</VAR> does not correspond to an output registered,
with <A HREF="#IPAddOutput">IPAddOutput</A>, this function returns
SAME_AS_FIRST_INPUT.  Otherwise, the current selection in the mode menu for
the first output is returned.  It will either be SAME_AS_FIRST_INPUT (defined
in ip.h for C/C++ or ip.inc for Fortran) or one of the 
<A HREF="IM_ref2.html#PixelDataTypes">IM pixel type codes</A>.  

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPGetFilename">IPGetFilename</A></H2>
<H3>Overview</H3>
<P>Returns the file name currently associated with one of the inputs or
outputs.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPGetFilename(int im_stream, char* file);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPGetFilename(im_stream, file)</CODE>
<BR><CODE>integer im_stream</CODE>
<BR><CODE>character*(*) file</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>im_stream</VAR><DD>(in) Is a stream number that had been used in a
    call to <A HREF="#IPAddInput">IPAddInput</A> or
    <A HREF="#IPAddOutput">IPAddOutput</A>.
  <DT><VAR>file</VAR><DD>(out) Is filled with the file name associated with
    <VAR>im_stream</VAR> or is set to the empty string if <VAR>im_stream</VAR>
    does not match a stream number used with IPAddInput or IPAddOutput.  If
    called from Fortran, the file name is either padded with blanks or
    truncated in order to fill <VAR>file</VAR>.  For IPGetFilename to
    function reliably when called from C, <VAR>file</VAR> must point to space
    for at least 256 characters (including the terminating null).
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPGetRegionInfo">IPGetRegionInfo</A></H2>
<H3>Overview</H3>
<P>Returns the currently selected region for the first input registered with
<A HREF="#IPAddInput">IPAddInput</A>.  Use
<A HREF="#IPGetRegionInfoExt">IPGetRegionInfoExt</A> to retrieve the
selected region for other inputs (this is only necessary if the application
has multiple inputs and has enabled independent region selection, via
<A HREF="#IPEnableRegionSelection">IPEnableRegionSelection</A>, for one of the
inputs other than the first).  The x, y, and z indices returned always refer
to the highest resolution data set in the first input.  Until processing
starts, the bounds for an input may be inconsistent with the input's header if
the input is not the first input and the input's bounds are derived from the
first input's bounds.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPGetRegionInfo(int nxyzt[4][3], int iwave[IW_MAX_WAVE]);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPGetRegionInfo(nxyzt, iwave)</CODE>
<BR><CODE>integer nxyzt(3, 4), iwave(5)</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>nxyzt</VAR><DD>(out) Let <VAR>i</VAR> be the dimension; where
    <VAR>i</VAR> = 1 is x, <VAR>i</VAR> = 2 is y, <VAR>i</VAR> = 3 is z,
    and <VAR>i</VAR> = 4 is time.  Then <VAR>nxyzt</VAR>[<VAR>i</VAR>-1][0]
    (<VAR>nxyzt</VAR>(1,<VAR>i</VAR>) in Fortran) is the zero-based index for
    the start of the region in the <VAR>i</VAR>th dimension,
    <VAR>nxyzt</VAR>[<VAR>i</VAR>-1][1] (<VAR>nxyzt</VAR>(2,<VAR>i</VAR>) in
    Fortran) is the zero-based index for the end of the region in the
    <VAR>i</VAR>th dimension, and <VAR>nxyzt</VAR>[i-1][2]
    (<VAR>nxyzt</VAR>(3,i) in Fortran) is the index increment between points
    that are processed in the <VAR>i</VAR>th dimension.  For the x and
    y directions, a further constraint is applied, and the returned increment
    is always one.  If processing the highest resolution, it follows that the
    number of points processed in the <VAR>i</VAR>th dimension is
    (nxyzt[<VAR>i</VAR>-1][1] - nxyzt[<VAR>i</VAR>-1][0]) / ((nxyzt[<VAR>i</VAR>-1][2] != 0) ? nxyzt[<VAR>i</VAR>-1][2] : 1) + 1
     (or, in Fortran, (nxyzt(2,<VAR>i</VAR>) - nxyzt(1,<VAR>i</VAR>)) / max(nxyzt(3,<VAR>i</VAR>), 1) + 1).
    If processing a resolution other than the highest, the x and y sizes are
    decreased by a factor of 2 raised to the <VAR>j</VAR> power where
    <VAR>j</VAR> is the resolution index.  The z size is
    (nxyzt[2][1] - nxyzt[2][0]) / zstep + 1 ((nxyzt(2,3) - nxyzt(1,3)) / zstep
    in Fortran).   zstep is the smallest multiple of the z downsampling factor
    raised to the resolution index power which is greater than or equal to
    nxyzt[2][2] (nxyzt(3,3) in Fortran).
  <DT><VAR>iwave</VAR><DD>(out) If the <VAR>i</VAR>th wavelength (<VAR>i</VAR>
    greater than zero and less than 5 (IW_MAX_WAVE)) is to be processed then
    <VAR>iwave</VAR>[<VAR>i</VAR>-1] (<VAR>iwave</VAR>(<VAR>i</VAR>) in
    Fortran) is 1; otherwise <VAR>iwave</VAR>[<VAR>i</VAR>-1] is zero.  If
    the application is not running with the graphical user interface,
    this information is not adequate to describe which wavelengths are
    processed:  the text and non-interactive modes allow reordering and
    repetition of wavelengths.  Use
    <A HREF="#IPGetWaveOrder">IPGetWaveOrder</A> to get the complete
    information when running in one of those modes.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPGetRegionInfoExt">IPGetRegionInfoExt</A></H2>
<H3>Overview</H3>
<P>Returns the currently selected region for an input registered with
<A HREF="#IPAddInput">IPAddInput</A>.  The x, y, and z indices returned
always refer to the highest resolution data set in the input.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPGetRegionInfoExt(int in_stream, int nxyzt[4][3], int iwave[IW_MAX_WAVE]);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPGetRegionInfoExt(in_stream, nxyzt, iwave)</CODE>
<BR><CODE>integer in_stream, nxyzt(3, 4), iwave(5)</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>in_stream</VAR><DD>(in) Is the IM stream number for the input
    of interest.
  <DT><VAR>nxyzt</VAR><DD>(out) Let <VAR>i</VAR> be the dimension; where
    <VAR>i</VAR> = 1 is x, <VAR>i</VAR> = 2 is y, <VAR>i</VAR> = 3 is z,
    and <VAR>i</VAR> = 4 is time.  Then <VAR>nxyzt</VAR>[<VAR>i</VAR>-1][0]
    (<VAR>nxyzt</VAR>(1,<VAR>i</VAR>) in Fortran) is the zero-based index for
    the start of the region in the <VAR>i</VAR>th dimension,
    <VAR>nxyzt</VAR>[<VAR>i</VAR>-1][1] (<VAR>nxyzt</VAR>(2,<VAR>i</VAR>) in
    Fortran) is the zero-based index for the end of the region in the
    <VAR>i</VAR>th dimension, and <VAR>nxyzt</VAR>[i-1][2]
    (<VAR>nxyzt</VAR>(3,i) in Fortran) is the index increment between points
    that are processed in the <VAR>i</VAR>th dimension.  For the x and
    y directions, a further constraint is applied, and the returned increment
    is always one.  If processing the highest resolution, it follows that the
    number of points processed in the
    <VAR>i</VAR>th dimension is (nxyzt[<VAR>i</VAR>-1][1] - nxyzt[<VAR>i</VAR>-1][0]) / ((nxyzt[<VAR>i</VAR>-1][2] != 0) ? nxyzt[<VAR>i</VAR>-1] : 1) + 1
     (or, in Fortran, (nxyzt(2,<VAR>i</VAR>) - nxyzt(1,<VAR>i</VAR>)) / max(nxyzt(3,<VAR>i</VAR>), 1) + 1).
    If processing a resolution other than the highest, the x and y sizes are
    decreased by a factor of 2 raised to the <VAR>j</VAR> power where
    <VAR>j</VAR> is the resolution index.  The z size is
    (nxyzt[2][1] - nxyzt[2][0]) / zstep + 1 ((nxyzt(2,3) - nxyzt(1,3)) / zstep
    in Fortran).   zstep is the smallest multiple of the z downsampling factor
    raised to the resolution index power which is greater than or equal to
    nxyzt[2][2] (nxyzt(3,3) in Fortran).
  <DT><VAR>iwave</VAR><DD>(out) If the <VAR>i</VAR>th wavelength (<VAR>i</VAR>
    greater than zero and less than 5 (IW_MAX_WAVE)) is to be processed then
    <VAR>iwave</VAR>[<VAR>i</VAR>-1] (<VAR>iwave</VAR>(<VAR>i</VAR>) in
    Fortran) is 1; otherwise <VAR>iwave</VAR>[<VAR>i</VAR>-1] is zero.  If
    the application is not running with the graphical user interface,
    this information is not adequate to describe which wavelengths are
    processed:  the text and non-interactive modes allow reordering and
    repetition of wavelengths.  Use
    <A HREF="#IPGetWaveOrder">IPGetWaveOrder</A> to get the complete
    information when running in one of those modes.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPGetRegionWidgets">IPGetRegionWidgets</A></H2>
<H3>Overview</H3>
<P>Returns the IDs of the user interface elements used to control the
selection of the input region for the first input.  The returned values could
be used with the <A HREF="WM.html">WM library</A> calls to disable or hide the
widgets.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPGetRegionWidgets(Widget widgets[IW_MAX_WAVE + 3]);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPGetRegionWidgets(widgets)</CODE>
<BR><CODE>integer widgets(8)</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>widgets</VAR><DD>(out) <VAR>widgets</VAR>[0] (<VAR>widgets</VAR>(1)
    in Fortran) is the ID of the text field for the x and y bounds of the
    region.   <VAR>widgets</VAR>[1] is the ID of the text field for the z
    bounds and increment.  <VAR>widgets</VAR>[2] is the ID of the text field
    for the time bounds and increment.  <VAR>widgets</VAR>[<VAR>i</VAR>+2]
    (<VAR>widgets</VAR>(<VAR>i</VAR>+3) in Fortran) is the ID for the toggle
    button controlling whether or not the <VAR>i</VAR>th wavelength is
    processed (<VAR>i</VAR> is greater than zero and less then or equal to
    5 (IW_MAX_WAVE)).  If the program is not running with the graphical
    interface or does not have an input registered with
    <A HREF="#IPAddInput">IPAddInput</A>, the elements of <VAR>widgets</VAR>
    are set to zero.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPGetWaveOrder">IPGetWaveOrder</A></H2>
<H3>Overview</H3>
<P>Returns the mapping of input wavelengths to output wavelengths.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPGetWaveOrder(int in_stream, int* nout, int waves[]);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPGetWaveOrder(in_stream, nout, waves)</CODE>
<BR><CODE>integer in_stream, nout, waves(*)</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>in_stream</VAR><DD>(in) Is the IM stream number of the input
    of interest.
  <DT><VAR>nout</VAR><DD>(out) The number of wavelengths to be processed
    from <VAR>in_stream</VAR> is returned in <VAR>nout</VAR>
  <DT><VAR>waves</VAR><DD>(out) When IPGetWaveOrder returns,
    <VAR>waves</VAR>[<VAR>i</VAR>] (<VAR>waves</VAR>(<VAR>i</VAR> + 1) in
    Fortran if one-based indexing is used) is the index of the input wavelength
    from <VAR>in_stream</VAR> used as the source for the <VAR>i</VAR>th output
    wavelength.  The behavior is undefined if <VAR>waves</VAR> has less than
    <VAR>nout</VAR> elements.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPHasGUI">IPHasGUI</A></H2>
<H3>Overview</H3>
<P>Returns whether or not the application is using a graphical user interface.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>int IPHasGUI(void);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>integer function IPHasGUI()</CODE>
<H3>Return Value</H3>
<P>Returns zero if the application is not running with a graphical interface
(it is either running interactively in text-mode or running non-interactively).
Returns one if the application s running with a graphical interface.

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPIsAppending">IPIsAppending</A></H2>
<H3>Overview</H3>
<P>Checks whether an output registered with
<A HREF="#IPAddOutput">IPAddOutput</A> is appending to existing data.
IPIsAppending is only useful if the application does not do its processing
with a CUST_DOIT function and if IPIsAppending is called after the framework
has made the decision to append (this occurs after CHECK_PARAMS is called
but before INIT_PROC is called) and before the outputs are closed (this occurs
after AFTER_DO_IT is called).
<H3>C Prototype</H3>
<P><CODE>include "ip.h"</CODE>
<BR><CODE>int IPIsAppending(int out_stream);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>integer function IPIsAppending(out_stream)</CODE>
<BR><CODE>integer out_stream</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>out_stream</VAR><DD>(in) Is the IM stream number of the output
    to check.
</DL>
<H3>Return Value</H3>
<P>Returns zero if <VAR>out_stream</VAR> is not the IM stream of an output
registered with <A HREF="#IPAddInput">IPAddInput</A> or if that output is
not appending to existing data.  Otherwise, one is returned if the output
data is appended along the z dimension, two is returned if the output
is appended along the wavelength dimension, or three is returned if the
data is appended along the time dimension.

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPIsInteractive">IPIsInteractive</A></H2>
<H3>Overview</H3>
<P>Returns whether or not the application is running interactively (i.e. it
can query the user for input).
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>int IPIsInteractive(void);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>integer function IPIsInteractive()</CODE>
<H3>Return Value</H3>
<P>If the application is running interactively (either with a graphical
user interface or with a text interface), the function returns one.  Otherwise,
the function returns zero.

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPIsOpen">IPIsOpen</A></H2>
<H3>Overview</H3>
<P>Checks whether an input registered with <A HREF="#IPAddInput">IPAddInput</A>
or an output registered with <A HREF="#IPAddOutput">IPAddOutput</A> is
currently open.
<H3>C Prototype</H3>
<P><CODE>include "ip.h"</CODE>
<BR><CODE>int IPIsOpen(int im_stream);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>integer function IPIsOpen(im_stream)</CODE>
<BR><CODE>integer im_stream</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>im_stream</VAR><DD>(in) Is the IM stream number to check.
</DL>
<H3>Return Value</H3>
<P>Returns one if <VAR>im_stream</VAR> is open and corresponds to an input
registered with <A HREF="#IPAddInput">IPAddInput</A> or an output registered
with <A HREF="#IPAddOutput">IPAddOutput</A>.  Otherwise, returns zero.

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPParseIntArg">IPParseIntArg</A></H2>
<H3>Overview</H3>
<P>Given a character string, parses it to see if it matches the format,
<CODE>-</CODE><VAR>prefix</VAR><CODE>=</CODE><VAR>integer_1</VAR>[<CODE>:</CODE><VAR>integer_2</VAR>...].
<H3>C Prototype</H3>
<P><CODE>#include ip.h"</CODE>
<BR><CODE>int IPParseIntArg(const char* arg, const char* prefix, int max_count, int values[]);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>integer function IPParseIntArg(arg, prefix, max_count, values)</CODE>
<BR><CODE>character*(*) arg, prefix</CODE>
<BR><CODE>integer max_count</CODE>
<BR><CODE>integer values(max_count)</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>arg</VAR><DD>(in) <VAR>arg</VAR> is the string to process.  In C, it
    should be null-terminated.  In Fortran, only the portion up to the last
    printable character which is not a space is considered.
  <DT><VAR>prefix</VAR><DD>(in) If the start of <VAR>arg</VAR> does not match
    a '-' followed by the contents of <VAR>prefix</VAR> followed by an equals
    sign, IPParseIntArg returns zero and does not modify the contents of
    <VAR>values</VAR>.  In C, <VAR>prefix</VAR> should be null-terminated.
    In Fortran, only the portion up to the last printable character which is
    not a space is considered.
  <DT><VAR>max_count</VAR><DD>(in) <VAR>max_count</VAR> is the maximum number
    of integers expected.
  <DT><VAR>values</VAR><DD>(in/out) The parsed integer values from the string
    are returned in <VAR>values</VAR>.
</DL>
<H3>Return Value</H3>
<P>The return value indicates the number of integers that was successfully
scanned and transfered to <VAR>values</VAR>.  If <VAR>n</VAR> is the
value returned then:
<UL>
  <LI>If <VAR>n</VAR> is zero, the start of <VAR>arg</VAR> did not match
    <CODE>-</CODE><VAR>prefix</VAR><CODE>=</CODE>.
  <LI>If <VAR>n</VAR> is greater than zero and less than or equal to
    <VAR>max_count</VAR>, there are exactly <VAR>n</VAR> integer parameters
    in <VAR>arg</VAR>, and their values have been transferred to the first
    <VAR>n</VAR> elements of <VAR>values</VAR>.
  <LI>If <VAR>n</VAR> is greater than <VAR>max_count</VAR>, there are exactly
    <VAR>n</VAR> integer parameters in <VAR>arg</VAR>, and the values of
    the first <VAR>max_count</VAR> of them have been transfered to
    <VAR>values</VAR>.
  <LI>If <VAR>n</VAR> is negative, the first abs(<VAR>n</VAR>) minus one
    integer values were successfully parsed and transfered to <VAR>values</VAR>
    but the next integer value could not be read due to an error in its format.
</UL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPParseRealArg">IPParseRealArg</A></H2>
<H3>Overview</H3>
<P>Given a character string, parses it to see if it matches the format,
<CODE>-</CODE><VAR>prefix</VAR><CODE>=</CODE><VAR>real_1</VAR>[<CODE>:</CODE><VAR>real_2</VAR>...].
<H3>C Prototype</H3>
<P><CODE>#include ip.h"</CODE>
<BR><CODE>int IPParseRealArg(const char* arg, const char* prefix, int max_count, float values[]);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>integer function IPParseRealArg(arg, prefix, max_count, values)</CODE>
<BR><CODE>character*(*) arg, prefix</CODE>
<BR><CODE>integer max_count</CODE>
<BR><CODE>real values(max_count)</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>arg</VAR><DD>(in) <VAR>arg</VAR> is the string to process.  In C, it
    should be null-terminated.  In Fortran, only the portion up to the last
    printable character which is not a space is considered.
  <DT><VAR>prefix</VAR><DD>(in) If the start of <VAR>arg</VAR> does not match
    a '-' followed by the contents of <VAR>prefix</VAR> followed by an equals
    sign, IPParseRealArg returns zero and does not modify the contents of
    <VAR>values</VAR>.  In C, <VAR>prefix</VAR> should be null-terminated.
    In Fortran, only the portion up to the last printable character which is
    not a space is considered.
  <DT><VAR>max_count</VAR><DD>(in) <VAR>max_count</VAR> is the maximum number
    of real values expected.
  <DT><VAR>values</VAR><DD>(in/out) The parsed real values from the string are
    returned in <VAR>values</VAR>.
</DL>
<H3>Return Value</H3>
<P>The return value indicates the number of floating-point values that was
successfully scanned and transfered to <VAR>values</VAR>.  If <VAR>n</VAR> is
the value returned then:
<UL>
  <LI>If <VAR>n</VAR> is zero, the start of <VAR>arg</VAR> did not match
    <CODE>-</CODE><VAR>prefix</VAR><CODE>=</CODE>.
  <LI>If <VAR>n</VAR> is greater than zero and less than or equal to
    <VAR>max_count</VAR>, there are exactly <VAR>n</VAR> real parameters
    in <VAR>arg</VAR>, and their values have been transferred to the first
    <VAR>n</VAR> elements of <VAR>values</VAR>.
  <LI>If <VAR>n</VAR> is greater than <VAR>max_count</VAR>, there are exactly
    <VAR>n</VAR> real parameters in <VAR>arg</VAR>, and the values of
    the first <VAR>max_count</VAR> of them have been transfered to
    <VAR>values</VAR>.
  <LI>If <VAR>n</VAR> is negative, the first abs(<VAR>n</VAR>) minus one
    real values were successfully parsed and transfered to <VAR>values</VAR>
    but the next real value could not be read due to an error in its format.
</UL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPPromptInt">IPPromptInt</A></H2>
<H3>Overview</H3>
<P>Prompts the user for one or more integer values.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>int IPPromptInt(const char* name, int set_count, int min_count, int max_count, int values[]);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>integer function IPPromptInt(name, set_count, min_count, max_count, values)</CODE>
<BR><CODE>character*(*) name</CODE>
<BR><CODE>integer set_count, min_count, max_count</CODE>
<BR><CODE>integer values(count)</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>name</VAR><DD>(in) <VAR>name</VAR> is used to label the prompt.  The
    prompt has the form "<VAR>name</VAR> (default <VAR>value1</VAR> ...)=".
    In C, <VAR>name</VAR> should be null-terminated.  In Fortran, only the
    portion up to the last printable character which is not a space is
    considered.
  <DT><VAR>set_count</VAR><DD>(in) The first <VAR>set_count</VAR> of
    <VAR>values</VAR> are printed as the default selection in the prompt;
    if <VAR>set_count</VAR> is less than or equal to zero no default is
    printed.
  <DT><VAR>min_count</VAR><DD>(in) <VAR>min_count</VAR> is the minimum number
    of values that the user is allowed to enter.
  <DT><VAR>max_count</VAR><DD>(in) <VAR>max_count</VAR> is the maximum number of
    values that the user is allowed to enter.
  <DT><VAR>values</VAR><DD>(in/out) The elements of <VAR>values</VAR> when
    IPPromptInt is called are used as the default values.  When IPPromptInt
    returns, the elements of <VAR>values</VAR> are modified to correspond to
    the user's entries.  The results are undefined if <VAR>values</VAR> has
    less than <VAR>max_count</VAR> elements.
</DL>
<H3>Return Value</H3>
<P>IPPromptInt returns the number of values that the user entered.  The
returned value will be negative one if a memory allocation error occurred or
zero if the user accepted the defaults; otherwise, it will be between
<VAR>min_count</VAR> and <VAR>max_count</VAR>.

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPPromptReal">IPPromptReal</A></H2>
<H3>Overview</H3>
<P>Prompts the user for one or more real values.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>int IPPromptReal(const char* name, int set_count, int min_count, int max_count, float values[]);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>integer function IPPromptReal(name, set_count, min_count, max_count, values)</CODE>
<BR><CODE>character*(*) name</CODE>
<BR><CODE>integer set_count, min_count, max_count</CODE>
<BR><CODE>real values(count)</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>name</VAR><DD>(in) <VAR>name</VAR> is used to label the prompt.  The
    prompt has the form "<VAR>name</VAR> (default <VAR>value1</VAR> ...)=".
    In C, <VAR>name</VAR> should be null-terminated.  In Fortran, only the
    portion up to the last printable character which is not a space is
    considered.
  <DT><VAR>set_count</VAR><DD>(in) The first <VAR>set_count</VAR> of
    <VAR>values</VAR> are printed as the default selection in the prompt;
    if <VAR>set_count</VAR> is less than or equal to zero no default is
    printed.
  <DT><VAR>min_count</VAR><DD>(in) <VAR>min_count</VAR> is the minimum number
    of values that the user is allowed to enter.
  <DT><VAR>max_count</VAR><DD>(in) <VAR>max_count</VAR> is the maximum number of
    values that the user is allowed to enter.
  <DT><VAR>values</VAR><DD>(in/out) The elements of <VAR>values</VAR> when
    IPPromptReal is called are used as the default values.  When IPPromptReal
    returns, the elements of <VAR>values</VAR> are modified to correspond to
    the user's entries.  The results are undefined if <VAR>values</VAR> has
    less than <VAR>max_count</VAR> elements.
</DL>
<H3>Return Value</H3>
<P>IPPromptReal returns the number of values that the user entered.  The
returned value will be negative one if a memory allocation error occurred
or zero if the user accepted the defaults; otherwise, it will be between
<VAR>min_count</VAR> and <VAR>max_count</VAR>.

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPPromptString">IPPromptString</A></H2>
<H3>Overview</H3>
<P>Prompts the user for a string.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>int IPPromptString(const char* prompt, char* value, int max_length);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>integer function IPPromptString(prompt, value)</CODE>
<BR><CODE>character*(*) prompt, value</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>prompt</VAR><DD>(in) <VAR>prompt</VAR> is printed before waiting
    for input.  In C, <VAR>prompt</VAR> should be null-terminated.  In Fortran,
    only the portion up to the last printable character which is not a space
    is considered.
  <DT><VAR>value</VAR><DD>(out) When IPPromptString returns, <VAR>value</VAR>
    holds what the user entered.  <VAR>value</VAR> will be null-terminated
    in C.  In Fortran, it will be padded, if necessary, with spaces to fill
    the full size of the string.
  <DT><VAR>max_length</VAR><DD>(in) In C, <VAR>max_length</VAR> is the maximum
    number of characters including the terminating null that <VAR>value</VAR>
    can hold.
</DL>
<H3>Return Value</H3>
<P>The total number of characters entered by the user is returned.  This
may exceed the length of <VAR>value</VAR> if <VAR>value</VAR> was not big
enough to hold what was entered.

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPPostInfo">IPPostInfo</A></H2>
<H3>Overview</H3>
<P>Is a synonym for <A HREF="#IPDisplayMessage">IPDisplayMessage</A>(<VAR>string</VAR>, IP_LOG_PROGRESS).
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPPostInfo(const char* string);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPPostInfo(string)</CODE>
<BR><CODE>character*(*) string</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>string</VAR><DD>(in) <VAR>string</VAR> holds the message to be
    displayed.  When the application is run with a graphical interface, 
    at most twenty characters are displayed; any contents of <VAR>string</VAR>
    beyond that will not be visible.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPReportSectionStats">IPReportSectionStats</A></H2>
<H3>Overview</H3>
<P>For applications which do 2D processing via a PROC_FUNC callback, an
argument to that callback is used to return that statistics (minimum, maximum,
and sum) for the section just processed and written to the first output.
If the application has more than one output registered with
<A HREF="#IPAddOutput">IPAddOutput</A>, the statistics for the section just
processed and written to those outputs are reported with IPReportSectionStats.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPReportSectionStats(int out_stream, float smin, float smax, float ssum);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPReportSectionStats(out_stream, smin, smax, ssum)</CODE>
<BR><CODE>integer out_stream</CODE>
<BR><CODE>real smin, smax, ssum</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>out_stream</VAR><DD>(in) Is the IM stream number for the output
    whose section statistics are given.
  <DT><VAR>smin</VAR><DD>(in) Is the minimum data value in the section just
    processed.
  <DT><VAR>smax</VAR><DD>(in) Is the maximum data value in the section just
    processed.
  <DT><VAR>ssum</VAR><DD>(in) Is the sum of the data values in the section
    just processed.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetAppendOptions">IPSetAppendOptions</A></H2>
<H3>Overview</H3>
<P>When an output registered with <A HREF="#IPAddOutput">IPAddOutput</A> would
modify existing data, there are two factors that determine what choices the
user has:  compatibility between the size of the existing data and the output
to be generated and restrictions placed by the application on what sort of
operations are permitted.  IPSetAppendOptions modifies the settings for the
latter.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetAppendOptions(int out_stream, int in_z, int in_w, int in_t, int replace);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetAppendOptions(out_stream, in_z, in_w, in_t, replace)</CODE>
<BR><CODE>integer out_stream, in_z, in_w, in_t, replace</CODE>
<H3>Parameters</H3>
<DL>
   <DT><VAR>out_stream</VAR><DD>(in) Is the IM stream number for the output of
     interest.
   <DT><VAR>in_z</VAR><DD>(in) If in_z is not zero, then the application
     allows the framework to append to existing data along the z dimension
     when the sizes and layout of the existing data and the processing results
     permit it.  Otherwise, appending along the z dimension is not allowed.
   <DT><VAR>in_w</VAR><DD>(in) If in_w in C is not zero, then the application
     allows the framework to append to existing data as additional wavelengths
     if the sizes and layout of the existing data and the processing results
     permit it.  Otherwise, appending wavelengths is not allowed.
   <DT><VAR>in_t</VAR><DD>(in) If in_t is not zero, then the application
     allows the framework to append to existing data as additional time points
     when the sizes and layout of the existing data and the processing results
     permit it.  Otherwise, appending additional time points is not allowed.
   <DT><VAR>replace</VAR><DD>(in) If replace is not zero, then the application
     allows the framework to replace the contents of an input with an output
     in the case where an input and output have the same name and the layout
     and sizes of the existing data and processing results permit the
     replacement.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetAutoScale">IPSetAutoScale</A></H2>
<H3>Overview</H3>
<P>If 2D processing is done via a PROC_FUNC callback and the output is an
image window, the framework sets the scaling parameters for the image window.
By default, these scaling parameters are set so each section in a wavelength
is scaled to the same range.  The range is the full range of processed data
values in the wavelength.  Alternatively, the scales may be set so that each
section is scaled independently; the scaled range for each section will be
the full range of processed data values in that section.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetAutoScale(int onoff);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetAutoScale(onoff)</CODE>
<BR><CODE>integer onoff</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>onoff</VAR><DD>(in) If onoff is zero, the default method for
    assigning the scaling parameters (scaling each section in a wavelength
    to the same range) is used.  Otherwise, the alternative method of scaling
    each section separately is used.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetComputeSize">IPSetComputeSize</A></H2>
<H3>Overview</H3>
<P>If the result of processing has a different size than the input region
processed, the application can use IPSetComputeSize to register a callback
function which the framework will call to determine what the size of the
processing result will be.  Doing so will allow the framework to correctly
identify when it is possible to append to an existing data set.  Also, if the
application did not notify the framework of the modified size, it might have
to free and reallocate the memory that the framework does on behalf of the
application (using a combination of <A HREF="#IPGetDataPtr">IPGetDataPtr</A>
and <A HREF="#IPSetDataPtr">IPSetDataPtr</A>) or disable the framework's memory
allocation mechanism entirely with <A HREF="#IPSetNoAutoIO">IPSetNoAutoIO</A>.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetComputeSize(int out_stream, void (*func)(int istrm, int arg, int sizes[5]), int arg);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPComputeSize(out_stream, func, arg)</CODE>
<BR><CODE>integer out_stream, arg</CODE>
<BR><CODE>external func</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>out_stream</VAR><DD>(in) Is the IM stream number associated with
    the output whose size may vary from the dimensions of the input region.
  <DT><VAR>func</VAR><DD>(in) Is the routine that the framework will call
    to determine the size of the processed region.  The routine is expected
    to take three arguments.  The first is the IM stream number for the
    output.  The second is the <VAR>arg</VAR> passed to IPSetComputeSize.
    The third is an array of five integers corresponding to the x, y, z,
    wavelength and time sizes for the processed region.  When the
    <VAR>func</VAR> is called the array is filled with the sizes for the
    input region; <VAR>func</VAR> is expected to modify the sizes to
    correspond to what the size of the processed data will be.  <VAR>func</VAR>
    should not return a value.
  <DT><VAR>arg</VAR><DD>(in) <VAR>arg</VAR> is passed as the second argument
    to <VAR>func</VAR> when it is called.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetCustRoutine">IPSetCustRoutine</A></H2>
<H3>Overview</H3>
<P>For a number of operations, an application may register a routine with
the IP framework in order to customize how the framework behaves.  To register
a routine, call IPSetCustRoutine.  In most cases the routine takes a
single integer argument and has no return value; the exceptions are noted
below.  The behaviors that can be customized are:
<DL>
  <DT>OPEN_FILE<DD>The routine registered for OPEN_FILE is invoked whenever
    one of the inputs set with <A HREF="#IPAddInput">IPAddInput</A> is called.
  <DT>CUS_MENU<DD>The routine registered for CUS_MENU is invoked to insert
    user interface elements into the main dialog.  This occurs after the
    elements for the input and output files from
    <A HREF="#IPAddInput">IPAddInput</A> and
    <A HREF="#IPAddOutput">IPAddOutput</A> but before the "Title", "Status",
    "Quit", and "DoIt" controls are added.  To have an effect, the CUS_MENU
    function must be set from within
    <A HREF="#IPAppSpecifics">IPAppSpecifics</A> or a routine that
    IPAppSpecifics calls.
  <DT>INIT_PROC<DD>The routine registered for INIT_PROC only has an effect if
    no routine has been registered for CUST_DOIT.  It is called during
    processing after the input files and output files have been opened and
    memory has been allocated for the input and output arrays and before the
    loop over the region to process has begun.
  <DT>PROC_FUNC<DD>The routine registered for PROC_FUNC only has an effect if
    no routine has been registered for CUST_DOIT.  It is called once
    for every loop over the region to process (see the
    <A HREF="#Details">Details section</A> for more information on this loop).
    For 2D processing, the routine is passed the x, y, and z dimensions of the
    region (taking into account resolution changes, if any) as a three element
    integer array, a three element floating-point array which should be filled
    with the minimum value, maximum value, and sum of the section processed,
    and the integer argument registered with IPSetCustRoutine.  For the other
    processing types, it is passed the integer argument registered with
    IPSetCustRoutine.
  <DT>CLEAN_UP_PROC<DD>The routine registered for CLEAN_UP_PROC is invoked
    when the user presses the "Quit" button.
  <DT>CHECK_PARAMS<DD>The routine registered with CHECK_PARAMS is invoked
    when processing starts.  At that point, any input added by
    <A HREF="#IPAddInput">IPAddInput</A> is open unless no name was specified
    for the input or an error occurred while opening the input, but no memory
    allocation or opening of output files has been done.  If the application
    calls <A HREF="#IPDesist">IPDesist</A> from within the CHECK_PARAMS
    callback, the framework will not call the processing callbacks
    (either CUST_DOIT or the combination of INIT_PROC, PROC_FUNC, and
    AFTER_DO_IT) when the CHECK_PARAMS callback returns:  the framework will
    simply call the UNDO_CHECK callback, if any, and return control to the
    user.
  <DT>INTERRUPT<DD>The routine registered for INTERRUPT is invoked if the
    user chooses to interrupt processing while it is in progress.
  <DT>NEW_REGION<DD>The routine registered for NEW_REGION is invoked when
    the user changes the x, y, z, or time bounds of the region.  If the first
    input is from an image window, it is also possible to change the x and y
    bounds by selecting a region in the window.  In that case, the NEW_XYAREA
    callback is invoked while the region is changed; when the user
    releases the mouse button, the NEW_REGION callback is invoked.  There are
    two situations (command-line operation and changing whether or not an
    input uses the first input's bounds) when the spatial and wavelength
    bounds and selected resolution can change simultaneously.  If your
    application makes use of two or more of the NEW_REGION, NEW_RES, and
    WAVE_FUNC callback routines, you should write those routines so they
    handle the case where all three parameters (spatial bounds, wavelengths,
    and resolution) have changed.
  <DT>NEW_RES<DD>The routine registered for NEW_RES is invoked when
    the user changes the resolution selection.  There are
    two situations (command-line operation and changing whether or not an
    input uses the first input's bounds) when the spatial and wavelength
    bounds and selected resolution can change simultaneously.  If your
    application makes use of two or more of the NEW_REGION, NEW_RES, and
    WAVE_FUNC callback routines, you should write those routines so they
    handle the case where all three parameters (spatial bounds, wavelengths,
    and resolution) have changed.
  <DT>OPT_MENU<DD>The routine registered for OPT_MENU is invoked when
    the framework has completed.  The application could use the OPT_MENU
    to initialize other subdialogs (though this can often be done on the fly)
    or to add user interface items below the "DoIt" button (though that is
    not recommended since it could violate the user's expectations for how
    IP based user interfaces are structured).  To have an effect, the OPT_MENU
    function must be set from within
    <A HREF="#IPAppSpecifics">IPAppSpecifics</A> or a routine that
    IPAppSpecifics calls.
  <DT>CUST_DOIT<DD>If a routine is registered for CUST_DOIT, the application
    becomes responsible for many of the tasks that the framework normally
    handles when the "DoIt" button is pressed.  In the normal case, pressing
    the "DoIt" button causes the framework to check the output file,
    open it, set up the header, allocate memory for the input and output
    arrays, invoke the INIT_PROC routine, perform a loop over the input region
    invoking PROC_FUNC routine once per iteration, invoke the AFTER_DO_IT
    routine, and then tidy up the header of the output file and close it.
    None of that happens if a CUST_DOIT routine is registered; the framework
    simply calls the CUST_DOIT routine.  In both cases, the input image sources
    registered with <A HREF="#IPAddInput">IPAddInput</A> are open and have
    had their headers read when the "DoIt" button is pressed.
  <DT>WAVE_FUNC<DD>The routine registered for WAVE_FUNC is invoked when
    the user changes the wavelengths that are currently selected for
    processing.  There are two situations (command-line operation and changing
    whether or not an input uses the first input's bounds) when the spatial
    and wavelength bounds and selected resolution can change simultaneously.
    If your application makes use of two or more of the NEW_REGION, NEW_RES,
    and WAVE_FUNC callback routines, you should write those routines so they
    handle the case where all three parameters (spatial bounds, wavelengths,
    and resolution) have changed.
  <DT>NEW_XYAREA<DD>If the user chooses to select the x and y bounds of
    the region using the mouse, the routine registered for NEW_XYAREA is
    invoked when the mouse moves and possibly causes a change to the selected
    region.  Because the application and image window should respond promptly
    when the mouse is moved, the NEW_XYAREA routine should avoid performing
    time-consuming operations.
  <DT>AFTER_DO_IT<DD>The routine registered for AFTER_DO_IT only has an
    effect if no routine has been registered for CUST_DOIT.  It is called
    after the processing loop has completed and before the final update to
    the header (with final values for the minimum, maximum, and mean, and
    additional labels are added) is performed and the output file is closed.
  <DT>CHANGE_MODE<DD>The routine registered for CHANGE_MODE is invoked when
    the user changes the data format for each pixel in the output.
  <DT>UNDO_CHECK<DD>The routine registered with UNDO_CHECK is invoked after
    processing is complete (or has been skipped because an error was detected
    in the input parameters).  At that point all output files have been closed,
    but any inputs that were open remain open.
  <DT>CMD_LINE_FUNC<DD>The function registered with CMD_LINE_FUNC is invoked
    when the application is invoked with any command-line arguments (the
    exception is if there is a single command-line argument which is -prompt;
    then the application will enter an interactive text mode if a PROMPT_FUNC
    callback has been registered or exit if a PROMPT_FUNC callback has not been
    registered).  The CMD_LINE_FUNC callback is invoked after the framework
    has read and removed all command-line parameters handled by the framework.
    Any input registered with <A HREF="#IPAddInput">IPAddInput</A> will be
    open at that point unless the no name for that input was supplied or there
    was an error opening the input.  A CMD_LINE_FUNC callback can use
    <A HREF="#IPGetArgCount">IPGetArgCount</A> and
    <A HREF="#IPGetArg">IPGetArg</A> to read the command-line arguments.
  <DT>USAGE_FUNC<DD>If, when processing command-line arguments, the framework
    detects an error, it will print out a summary of valid command-line
    parameters and exit.  To have the application-specific command-line
    parameters appear in the printed summary, the application should register
    a USAGE_FUNC callback with IPSetCustRoutine and from within the callback
    use a series of <A HREF="#IPDisplayMessage">IPDisplayMessage</A> calls
    with a priority of IP_LOG_ERROR to print out information about the
    application-specific parameters.
  <DT>WRITE_CMD<DD>If the application registers a WRITE_CMD callback with
    IPSetCustRoutine, the framework will give the user the option to write
    a command file from the graphical user interface.  If the user chooses
    to do so, the WRITE_CMD callback is invoked after the framework has
    opened the command file and written the command-line parameters handled
    by the framework.  From within the callback, the application should add
    the application-specific parameters which match the current settings
    in the graphical user interface; the application writes the parameters
    to the command file via calls to
    <A HREF="#IPAppendCommand">IPAppendCommand</A>.
  <DT>PROMPT_FUNC<DD>If the application registers a PROMPT_FUNC routine,
    then the application can be run in an interactive text mode.  The
    framework calls the PROMPT_FUNC routine to prompt the user to enter
    the values for application-specific input parameters.  You may use the
    <A HREF="#IPPromptInt">IPPromptInt</A>,
    <A HREF="#IPPromptReal">IPPromptReal</A>, and
    <A HREF="#IPPromptString">IPPromptString</A> to prompt the user.
</DL>

<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetCustRoutine(int func_op, IPCallback func, int argu);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetCustRoutine(func_op, func, argu)</CODE>
<BR><CODE>integer func_op, argu</CODE>
<BR><CODE>external func</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>func_op</VAR>(in) <DD>Specifies for which category (OPEN_FILE, ...)
    the routine is to be registered.  Constants with the same names as
    the categories are defined in ip.h for C/C++ programs or ip.inc for Fortran
    programs.
  <DT><VAR>func</VAR><DD>(in) <VAR>func</VAR> is the routine to register.  In
    all cases <VAR>func</VAR> is not expected to return a value.
    <VAR>func</VAR> is expected to take a single integer argument unless the
    <VAR>func_op</VAR> is ENV_CMD or <VAR>func_op</VAR> is PROC_FUNC and 2D
    processing is done.  For those exceptions, consult the descriptions of
    PROC_FUNC and ENV_CMD for what arguments are passed.  Because of C++'s
    typing system, the exceptional cases have to be handled by casting
    <VAR>func</VAR> to a function taking an integer argument and returning
    no value.
  <DT><VAR>argu</VAR><DD>(in) For most values of <VAR>func_op</VAR>,
    <VAR>argu</VAR> is passed as the only argument to <VAR>func</VAR>.  If
    <VAR>func_op</VAR> is PROC_FUNC and 2D processing is done, <VAR>argu</VAR>
    is passed as the third argument.  If <VAR>func_op</VAR> is ENV_CMD
    when it is invoked unless <VAR>func_op</VAR> is ENV_CMD, <VAR>argu</VAR>
    is not used.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetDataPtr">IPSetDataPtr</A></H2>
<H3>Overview</H3>
<P>Call IPSetDataPtr to set a buffer for an input or output channel
when <A HREF="#IPSetNoAutoIO">IPSetNoAutoIO</A> has been called.  Since
<A HREF="#IPSetNoAutoIO">IPSetNoAutoIO</A> has the side effect of turning
off the framework's handling of all image input and output during 2D
processing, IPSetDataPtr would normally be used to turn on that handling for
one of the input or output channels.  To have such an effect, IPSetDataPtr
would be called from an INIT_PROC routine for an input channel or from
an INIT_PROC or PROC_FUNC routines for an output channel.

<P>Use of this function when <A HREF="#IPSetNoAutoIO">IPSetNoAutoIO</A>
has not been called will cause undefined results.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetDataPtr(int im_stream, float* array);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetDataPtr(im_stream, array)</CODE>
<BR><CODE>integer im_stream</CODE>
<BR><CODE>real array(*)</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>im_stream</VAR><DD>(in) <VAR>im_stream</VAR> is the IM stream number
    associated with the channel.
  <DT><VAR>array</VAR><DD>(in) <VAR>array</VAR> should either be a NULL
    pointer or a floating-point array with sufficient space to hold the
    data (for 2D processing a single x/y section, for 3D processing a
    x/y/z volume, for 4D processing either all the data for one wave (the
    FOUR_D option to <A HREF="#IPSetProcType">IPSetProcType</A>) or all the
    data for one time point (the FOUR_D_WAVE option)).  If <VAR>array</VAR>
    is non-NULL, the framework will attempt to deallocate it when processing
    if finished.  Therefore, <VAR>array</VAR> must either be such that
    it can be deallocated with the C library call free() or the application
    must call IPSetDataPtr with a NULL value for array before processing
    terminates (typically from an AFTER_DO_IT routine).
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetDefOutPutMode">IPSetDefOutPutMode</A></H2>
<H3>Overview</H3>
<P>Is similar to <A HREF="#IPSetDefOutPutModeExt">IPSetDefOutPutModeExt</A>
but only operates on the first output registered with
<A HREF="#IPAddOutput">IPAddOutput</A>.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetDefOutPutMode(int mode);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetDefOutPutMode(mode)</CODE>
<BR><CODE>integer mode</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>mode</VAR><DD>(in) The current selected entry of the mode menu is
    changed to correspond to the value of <VAR>mode</VAR>.  <VAR>mode</VAR>
    should either be SAME_AS_FIRST_INPUT (defined in ip.h for C/C++ or
    ip.inc for Fortran; this corresponds to the "Default" entry in the mode
    menu) or one the
    <A HREF="IM_ref2.html#PixelDataTypes">IM pixel type codes</A>.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetDefOutPutModeExt">IPSetDefOutPutModeExt</A></H2>
<H3>Overview</H3>
<P>The user can choose that the output data have the same format for each
pixel as the first input data (this is the "Default" option for the
<A HREF="Region.html#MODE">mode menu</A> in the dialog) or to explicitly
set the pixel format to be one of the available types described in the
<A HREF="IM_ref2.html#PixelDataTypes">IM library documentation</A>.  When
the application starts, the "Default" option is the one that is selected;
if another option is desired, call IPSetDefOutPutMode.  IPSetDefOutPutModeExt
could also be used to reset the selection from the mode menu after the
application starts.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetDefOutPutModeExt(int out_stream, int mode);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetDefOutPutModeExt(out_stream, mode)</CODE>
<BR><CODE>integer out_stream, mode</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>out_stream</VAR><DD>(in) Is the IM stream number of the output
    to modify.
  <DT><VAR>mode</VAR><DD>(in) The current selected entry of the mode menu is
    changed to correspond to the value of <VAR>mode</VAR>.  <VAR>mode</VAR>
    should either be SAME_AS_FIRST_INPUT (defined in ip.h for C/C++ or
    ip.inc for Fortran; this corresponds to the "Default" entry in the mode
    menu) or one the
    <A HREF="IM_ref2.html#PixelDataTypes">IM pixel type codes</A>.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetDisChgHandler">IPSetDisChgHandler</A></H2>
<H3>Overview</H3>
<P>For an input added with <A HREF="#IPAddInput">IPAddInput</A> which
you want to monitor for image window change events, you should call
IPSetDisChgHandler to register a callback function for that input.
Because the framework monitors image window change events for its own
purposes, if the application directly used
<A HREF="WM.html#WMProcDisplayChange">WMProcDisplayChange</A> or
<A HREF="WM.html#WMCancelDisplayChange">WMCancelDisplayChange</A> it could
interfere with what the framework does.

<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetDisChgHandler(int im_stream, IPCallback func, int argu);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetDisChgHandler(im_stream, func, argu)</CODE>
<BR><CODE>integer im_stream, argu</CODE>
<BR><CODE>external func</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>im_stream</VAR><DD>(in) <VAR>im_stream</VAR> is the IM stream number
    that is associated with the input to monitor.
  <DT><VAR>func</VAR><DD>(in) <VAR>func</VAR> is the routine to call when
    a display change is detected.  The routine is expected to not return
    a value and to take a single integer argument.
  <DT><VAR>argu</VAR><DD>(in) <VAR>argu</VAR> is passed as the single
    argument to <VAR>func</VAR> when it is invoked.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetFirstWaveMMM">IPSetFirstWaveMMM</A></H2>
<H3>Overview</H3>
<P>Similar to <A HREF="#IPSetFirstWaveMMMExt">IPSetFirstWaveMMMExt</A> but
only operates on the first output registered with
<A HREF="#IPAddOutput">IPAddOutput</A>
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetFirstWaveMMM(float fmin, float fmax, float fmean);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetFirstWaveMMM(fmin, fmax, fmean)</CODE>
<BR><CODE>real fmin, fmax, fmean</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>fmin</VAR><DD>(in) Is the minimum pixel value in the first
    wavelength.
  <DT><VAR>fmax</VAR><DD>(in) Is the maximum pixel value in the first
    wavelength.
  <DT><VAR>fmean</VAR><DD>(in) Is the mean pixel value in the first
    wavelength.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetFirstWaveMMMExt">IPSetFirstWaveMMMExt</A></H2>
<H3>Overview</H3>
<P>For 3D or 4D processing done via a PROC_FUNC routine registered with
<A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>, it is the application's
responsibility to calculate the minimum and maximum pixel value in each
wavelength (and, for the first wavelength, the mean pixel value) and update
the headers of the output data to reflect the results.  For wavelengths
other than the first one processed, the update may be done with
<A HREF="IM_ref2.html#IMAlWavMM">IMAlWavMM</A>.   For the first wavelength
processed, the application should call IPSetFirstWaveMMMExt for each output
so that the framework correctly sets the headers just before it closing the
outputs.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetFirstWaveMMMExt(int out_stream, float fmin, float fmax, float fmean);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetFirstWaveMMMExt(out_stream, fmin, fmax, fmean)</CODE>
<BR><CODE>integer out_stream</CODE>
<BR><CODE>real fmin, fmax, fmean</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>out_stream</VAR><DD>(in) Is the IM stream number of the output
    to modify.
  <DT><VAR>fmin</VAR><DD>(in) Is the minimum pixel value in the first
    wavelength.
  <DT><VAR>fmax</VAR><DD>(in) Is the maximum pixel value in the first
    wavelength.
  <DT><VAR>fmean</VAR><DD>(in) Is the mean pixel value in the first
    wavelength.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetIncoreProc">IPSetIncoreProc</A></H2>
<H3>Overview</H3>
<P>Some applications do not require separate storage for the input and output
data:  they can do the processing in place.  If the application is not using
the CUST_DOIT routine registered with
<A HREF="#IPSetCustRoutine">IPSetCustRoutine</A> and has not called
<A HREF="#IPSetNoAutoIO">IPSetNoAutoIO</A>, a call to IPSetIncoreProc
anytime before processing starts causes the data from the first input
and the data for the first output to be stored in the same array (calling
<A HREF="#IPGetDataPtr">IPGetDataPtr</A> for the respective streams will return
the same value).  This reduces the memory footprint of the application and may
improve performance.  If the application has multiple outputs, it may want
to use <A HREF="#IPSetIncoreProcExt">IPSetIncoreProcExt</A> for finer control
over which inputs and outputs share space.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetIncoreProc(void);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetIncoreProc()</CODE>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetIncoreProcExt">IPSetIncoreProcExt</A></H2>
<H3>Overview</H3>
<P>Is an extension of <A HREF="#IPSetIncoreProc">IPSetIncoreProc</A> which
allows specification of which input data set shares space with a given
output data set.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetIncoreProcExt(int out_stream, int partner_stream);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetIncoreProcExt(out_stream, partner_stream)</CODE>
<BR><CODE>integer out_stream, partner_stream</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>out_stream</VAR><DD>(in) Is the IM stream of the output data stack.
  <DT><VAR>partner_stream</VAR><DD>(in) Is the IM stream of the input data
    stack with which <VAR>out_stream</VAR> should share space.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetMenuLoc">IPSetMenuLoc</A></H2>
<H3>Overview</H3>
<P>Call IPSetMenuLoc from within <A HREF="#IPAppSpecifics">IPAppSpecifics</A>
to set where the application's main dialog initially appears on the user's
display.  The position is a suggestion and may be overridden by the window
manager.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetMenuLoc(int xpos, int ypos);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetMenuLoc(xpos, ypos)</CODE>
<BR><CODE>integer xpos, ypos</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>xpos</VAR><DD>(in) <VAR>xpos</VAR> is the suggested position, in
    pixels, of the left edge of the dialog relative to the left edge of the
    screen.  A positive value places the left edge of the dialog to the right
    of the left edge of the screen.
  <DT><VAR>ypos</VAR><DD>(in) <VAR>ypos</VAR> is the suggested position, in
    pixels, of the top edge of the dialog relative to the left edge of the
    screen.  A positive value places the top edge below the top edge of the
    screen.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetMenuTitle">IPSetMenuTitle</A></H2>
<H3>Overview</H3>
<P>Call IPSetMenuTitle from within
<A HREF="#IPAppSpecifics">IPAppSpecifics</A> to set the label that the
window manager uses for the application's main dialog.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetMenuTitle(char* title);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetMenuTitle(title)</CODE>
<BR><CODE>character*(*) title</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>title</VAR><DD>(in) Is the label to be used for the main dialog.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetNoAppend">IPSetNoAppend</A></H2>
<H3>Overview</H3>
<P>For applications that do not do their processing in a CUST_DOIT
routine registered with <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>
and have an output registered with <A HREF="#IPAddOutput">IPAddOutput</A>,
the framework checks to see if the output already exists and offers the
choice to the user to either not continue with processing, overwrite what's
there, or modify the data by appending to it.  If IPSetNoAppend is called
anytime before processing starts, the user will not be offered the option to
append to the first output registered with
<A HREF="#IPAddOutput">IPAddOutput</A>.  For finer control over what choices
the user has when an output would affect existing data, use
<A HREF="#IPSetAppendOptions">IPSetAppendOptions</A>.
<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetNoAppend(void);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetNoAppend()</CODE>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetNoAutoIO">IPSetNoAutoIO</A></H2>
<H3>Overview</H3>
<P>For applications that do not do their processing in a CUST_DOIT
routine registered with <A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>,
the framework normally allocates space to store the input and output
data.  If IPSetNoAutoIO is called any time before processing starts,
this allocation is not done.  A side effect of this for 2D processing is that
unless <A HREF="#IPSetDataPtr">IPSetDataPtr</A> is called for an input or
output, the framework does not do the reading or writing of the image data from
that channel though it still handles opening the files and reading or setting
the headers.  This side effect can be useful if the application would
otherwise have to use a CUST_DOIT routine because of how the input and output
are handled but, by suppressing the normal reading and writing, can use a
PROC_FUNC routine, do its own reading and writing of the image data, and
take advantage of the other things that the framework does (handling the
setup of the output file, setting scales on the output data if a window,
tracking the running statistics for 2D processing, etc.) for a PROC_FUNC
routine but not when CUST_DOIT is used.

<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetNoAutoIO(void);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetNoAutoIO()</CODE>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetProcType">IPSetProcType</A></H2>
<H3>Overview</H3>
<P>IPSetProcType sets the form of the processing loop used when processing
is not done via a CUST_DOIT routine.  The
<A HREF="#Details">Details section</A> provides more detail about the
processing loop.

<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetProcType(int itype);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetProcType(itype)</CODE>
<BR><CODE>integer itype</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>itype</VAR><DD>(in) Is one of the following:
    TWO_D, THREE_D, THREE_D_XYT, FOUR_D, FOUR_D_WAVE.  These constants are
    defined in ip.h (C/C++) or ip.inc (Fortran).
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetSclParam">IPSetSclParam</A></H2>
<H3>Overview</H3>
<P>Similar to <A HREF="#IPSetSclParamExt">IPSetSclParamExt</A> but only
operates on the first output registered with
<A HREF="#IPAddOutput">IPAddOutput</A>.

<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetSclParam(int ichan, float scale[4]);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetSclParam(ichan, scale)</CODE>
<BR><CODE>integer ichan</CODE>
<BR><CODE>real scale(4)</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>ichan</VAR><DD>(in) <VAR>ichan</VAR> is the index (valid values
    are greater than or equal to zero and less than the number of wavelengths
    in the output) for the wavelength whose initial scaling parameters
    are to be modified.
  <DT><VAR>scale</VAR><DD>(in) <VAR>scale</VAR> holds the desired values
    for the initial scaling parameters.  How the scaling parameters
    are interpreted is discussed in the documentation for
    <A HREF="IW.html#IWScaleImage">IWScaleImage</A>.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

<H2><A NAME="IPSetSclParamExt">IPSetSclParamExt</A></H2>
<H3>Overview</H3>
<P>When processing is not done via a CUST_DOIT routine registered with
<A HREF="#IPSetCustRoutine">IPSetCustRoutine</A>, the framework performs the
following steps to scale how the output images appear if the output
added <A HREF="#IPAddOutput">IPAddOutput</A> points to a window:

<OL>
  <LI>After calling the INIT_PROC routine, if any, an initial set
    of scaling parameters is set.  By default, these scaling parameters
    are all zeros.
  <LI>For 2D processing, if the initial set of scaling parameters
    has a minimum and maximum of zero, the scaling for a wavelength
    is reset after processing each section to the minimum and maximum
    pixel values up to that point in processing.
</OL>

<P>Calling IPSetSclParamExt sets the initial scaling parameters for an output.
Typically it would be used from within the INIT_PROC routine, but for 2D
processing it would also have an effect if called from the PROC_FUNC routine.

<H3>C Prototype</H3>
<P><CODE>#include "ip.h"</CODE>
<BR><CODE>void IPSetSclParamExt(int out_stream, int ichan, float scale[4]);</CODE>
<H3>Fortran Prototype</H3>
<P><CODE>subroutine IPSetSclParamExt(out_stream, ichan, scale)</CODE>
<BR><CODE>integer out_stream, ichan</CODE>
<BR><CODE>real scale(4)</CODE>
<H3>Parameters</H3>
<DL>
  <DT><VAR>out_stream</VAR><DD>(in) <VAR>out_stream</VAR> is the IM stream
    number for the output whose scaling parameters are to be modified.
  <DT><VAR>ichan</VAR><DD>(in) <VAR>ichan</VAR> is the index (valid values
    are greater than or equal to zero and less than the number of wavelengths
    in the output) for the wavelength whose initial scaling parameters
    are to be modified.
  <DT><VAR>scale</VAR><DD>(in) <VAR>scale</VAR> holds the desired values
    for the initial scaling parameters.  How the scaling parameters
    are interpreted is discussed in the documentation for
    <A HREF="IW.html#IWScaleImage">IWScaleImage</A>.
</DL>

<P><A HREF="#Reference">Return to function list</A>
<HR>

</BODY>
</HTML>

#!/bin/sh

# Usage:
#     emtiar input_tilt_series input_align_param output_align_param_base \
#         output_recon -start=n -runs=n -noterm -cycles=n \
#         -res=i -fullsize=nx:ny -rscale=i -skip_init -imform=mode -pcbase=b \
#         -dimxy=nx:ny -iv=start:end:step -shxyz=x:y:z \
#         -dev=tx:ty:rot:mag:axis:mag2 -imod=m -mult=s -nofilter \
#         -nooffset -phaseweight -cpd=d -spth=t -cor_out=xcname -smooth=s \
#         -reconz=nz -istrfile=reconguess -restart_recon -positivity=i \
#         -proj_pos=i -gres=i -multires -slab \
#         -tmpdir=directory -parallel -ompiexec=mpiexec_path \
#         -machinefile=file -np=n -rshcmd=cmd -bkgopt=opt -no_nodecheck \
#         -checkcmd=cmd
#
# Expects the standard Unix commands, awk, basename, cp, dirname, echo, expr,
# mkdir, mv, rm, sed, test, and time to be in the search path.
#
# Expects the Priism commands align_2d_pi, align_2d_pi_parallel, appl_prm,
# count_processors, header, print_ith_processor, reproj, tapir, and
# tapir_parallel to be in the search path.
#
# Creates temporary files (the latest aligned tilt series, reconstruction,
# and reprojection) in the directory specified by -tmpdir=.  By default
# this directory is a directory named tmp in your home directory.  Will
# create the directory for temporary files (and any parent directories, if
# necessary) if that directory does not exist.  The names of the temporary
# files use the process ID of the creator plus an extension.

# Since the script never uses pathname expansion, disable it.
set -f

status=0
trap_signals="INT QUIT TERM"

# Extract required arguments.
if test $# -lt 4; then
    echo "usage: emtiar input_tilt_series input_align_param output_align_param_base output_recon [options]" 1>&2
    exit 1
fi
input_tilt_series="$1"
shift
param_file="$1"
shift
output_param_base="$1"
shift
output_recon="$1"
shift

# Set up default values for options.  The parallel_options,
# initial_appl_prm_options, appl_prm_options, tapir_options, and
# align_2d_options variables will collect options to be passed on.  Newlines
# will be used to separate the options collected (that means that options
# which include newlines will not be handled correctly).
irun=1
nrun=1
autoterm=1
tmpdir="$HOME"/tmp
parallel=0
ompiexec=""
ompiexec_np=""
machinefile=""
nproc_used=-1
rshcmd="ssh -x"
nodecheck="yes"
parallel_options=""
ires=0
igres=0
initial_appl_prm=yes
initial_appl_prm_options="
-iprmfile=$param_file
-noalign"
appl_prm_options="
-imform=2"
apxshift=0.0
apyshift=0.0
apzshift=0.0
tapir_options="-res=0
-moderec=2
"
proj_options=""
ncycles=20
input_size=`echo 0 0 | header "$input_tilt_series" | sed -n -e '/Image Size (X,Y,Sections)\.\.*/ s/Image Size (X,Y,Sections)\.\.*//p'`
reconx=`echo " $input_size" | awk '{print $1}'`
# Structure the tests this way to handle the cases where the values are not
# integers.
if test "$reconx" -gt 0; then
    reconz=`expr "$reconx" / 4`
else
    reconz=0
    status=1
    echo "emtiar: could not determine x size" 1>&2
fi
recon_end_y=`echo " $input_size" | awk '{print $2}'`
if test "$recon_end_y" -gt 0; then
    recon_end_y=`expr "$recon_end_y" - 1`
else
    recon_end_y=0
    status=1
    echo "emtiar: could not determine y size"
fi
unset input_size
istrfile=""
restart_recon=0
align_2d_options="-resref=0
"

# Parse command line options.
while test $# -gt 0; do
    case "$1" in
        -start=*)
	    irun=`echo " $1" | sed -e 's/ -start=//'`
            # Structure the test this way (empty then clause) to handle
            # the case where the value is not an integer.
	    if test "$irun" -gt 0; then
                :
	    else
	        status=1
		echo "emtiar: starting run number must be a positive integer" 1>&2
	    fi
            ;;

        -runs=*)
	    nrun=`echo " $1" | sed -e 's/ -runs=//'`
            # Structure the test this way (empty then clause) to handle
            # the case where the value is not an integer.
	    if test "$nrun" -ge 0; then
                :
	    else
		status=1
		echo "emtiar: number of runs must be a non-negative integer" 1>&2
            fi
            ;;

        -noterm)
            autoterm=0
            ;;

        -res=*)
            ires=`echo " $1" | sed -e 's/ -res=//'`
            # Structure the test this way (empty then clause) to handle the
            # case where the values is not an integer.
            if test "$ires" -ge 0; then
                :
            else
                status=1
                echo "emtiar: selected resolution must be a non-negative integer" 1>&2
            fi
            ;;

        -fullsize=*)
            initial_appl_prm_options="$initial_appl_prm_options
$1"
            appl_prm_options="$appl_prm_options
$1"
            align_2d_options="$align_2d_options
$1"
            ;;

        -rscale=*)
            initial_appl_prm_options="$initial_appl_prm_options
$1"
            appl_prm_options="$appl_prm_options
$1"
            align_2d_options="$align_2d_options
$1"
            tapir_options="$tapir_options
$1"
            ;;

        -cycles=*)
	    ncycles=`echo " $1" | sed -e 's/ -cycles=//'`
            ;;

        -dimxy=*)
            appl_prm_options="$appl_prm_options
$1"
            ;;

        -iv=*)
            appl_prm_options="$appl_prm_options
$1"
            ;;

        -shxyz=*)
            apxshift=`echo " $1" | sed -e 's/ -shxyz=//' | cut -d : -f 1`
            i=`echo " $1" | sed -e 's/ -shxyz=//' | cut -s -d : -f 2`
            if test \! -z "$i"; then
                apyshift="$i"
            fi
            i=`echo " $1" | sed -e 's/ -shxyz=//' | cut -s -d : -f 3`
            if test \! -z "$i"; then
                apzshift="$i"
            fi
            ;;

        -dev=*)
            align_2d_options="$align_2d_options
$1"
            ;;

        -imod=*)
            align_2d_options="$align_2d_options
$1"
            ;;

        -mult=*)
            align_2d_options="$align_2d_options
$1"
            ;;

        -nofilter)
            align_2d_options="$align_2d_options
$1"
            ;;

        -nooffset)
            align_2d_options="$align_2d_options
$1"
            ;;

        -phaseweight)
            align_2d_options="$align_2d_options
$1"
            ;;

        -cpd=*)
            align_2d_options="$align_2d_options
$1"
            ;;

        -spth=*)
            align_2d_options="$align_2d_options
$1"
            ;;

        -cor_out=*)
            align_2d_options="$align_2d_options
$1"
            ;;

        -imform=*)
            initial_appl_prm_options="$initial_appl_prm_options
$1"
            ;;

	-istrfile=*)
            istrfile=`echo " $1" | sed -e 's/ -istrfile=//'`
            if test none = "$istrfile"; then
                istrfile=""
            fi
            ;;

        -pcbase=*)
            initial_appl_prm_options="$initial_appl_prm_options
$1"
            ;;

        -skip_init)
            initial_appl_prm=no
            ;;

        -smooth=*)
            tapir_options="$tapir_options
$1"
            ;;

        -reconz=*)
	    reconz=`echo " $1" | sed -e 's/ -reconz=//'`
            ;;

        -restart_recon)
            restart_recon=1
            ;;

        -tmpdir=*)
	    tmpdir=`echo " $1" | sed -e 's/ -tmpdir=//'`
            ;;

	-parallel)
            parallel=1
            ;;

        -positivity=*)
            tapir_options="$tapir_options
$1"
            ;;

        -proj_pos=*)
            tapir_options="$tapir_options
$1"
            ;;

        -gres=*)
            igres=`echo " $1" | sed -e 's/ -gres=//'`
            # Structure the test this way (empty then clause) to handle the
            # case where the values is not an integer.
            if test "$igres" -ge 0; then
                :
            else
                status=1
                echo "emtiar: selected resolution from guess must be a non-negative integer" 1>&2
            fi
            ;;

        -multires)
            tapir_options="$tapir_options
$1"
            ;;

        -slab)
            proj_options="$proj_options
$1"
            ;;

        -bkgopt=*)
            parallel_options="$parallel_options
$1"
            ;;

        -checkcmd=*)
            parallel_options="$parallel_options
$1"
            ;;

        -machinefile=*)
            machinefile=`echo " $1" | sed -e 's/ -machinefile=//'`
            parallel_options="$parallel_options
$1"
            ;;

        -no_nodecheck)
            nodecheck=""
            ;;

        -np=*)
            # Ignore -np= if NSLOTS is set.
            if test -z "$NSLOTS" ; then
		nproc_used=`echo " $1" | sed -e 's/ -np=//'`
                # Structure the test this way (empty then clause) to handle
                # the case where the value is not an integer.
		if test "$nproc_used" -gt 0; then
                    :
		else
                    status=1
                    echo "emtiar: invalid number of processors" 1>&2
		fi
		parallel_options="$parallel_options
$1"
		ompiexec_np="$1"
            fi
            ;;

        -ompiexec=*)
            ompiexec=`echo " $1" | sed -e 's/ -ompiexec=//'`
            parallel_options="$parallel_options
$1"
            ;;

        -rshcmd=*)
            # When checking nodes, the command specified with this
            # option is not quoted, so appropriate quoting is up to the
            # caller.
            rshcmd=`echo " $1" | sed -e 's/ -rshcmd=//'`
            parallel_options="$parallel_options
$1"
            ;;
    esac
    shift
done

if test -e "$tmpdir"; then
    if test \! -d "$tmpdir"; then
        echo "emtiar: $tmpdir is not a directory" 1>&2
        status=1
    fi
else
    mkdir -p "$tmpdir" || status=1
fi

if test $status -ne 0; then
    exit 1
fi

nrun=`expr $nrun + $irun`

temp_aligned="$tmpdir"/$$.MnAln

temp_recon="$tmpdir"/$$.xzy
temp_stat="$tmpdir"/$$.stat
tapir_options="$tapir_options
-reconxz=${reconx}:${reconz}
-iy=0:${recon_end_y}
-cycles=$ncycles
-statfile=$temp_stat"

tilt_series_copy="$input_tilt_series"
param_copy=""
# Use the file named by temp_recon to hold the copy; that works (and has
# the benefit of using less disk space) for the shell script tapir_parallel
# where the initial guess and output reconstruction can be the same.  It
# probably won't work for other parallelized versions of tapir.
need_istr_copy_0=0
need_istr_copy_i=0
if test $parallel -eq 0; then
    tapir_cmd=tapir
    align_2d_cmd=align_2d_pi
else
    # Verify whether or not the compute nodes can see the temporary
    # directory and check whether or not copies of the input tilt
    # series, reconstruction guess,  and most recent parameter file
    # must be maintained in the temporary directory.
    if test -n "$nodecheck" ; then
        if test -n "$ompiexec" ; then
            temp_script="$tmpdir"/$$.sh
            output_param_dir=`dirname "$output_param_base"`
            trap 'rm "$temp_script" ; exit 1' INT QUIT TERM
            cat >"$temp_script" <<EOF
#!/bin/sh
status=
test \! -r "$temp_script" && status=1\$status
if test $initial_appl_prm != yes; then
    test \! -r "$input_tilt_series" && status=2\$status
fi
test \! -r "$param_file" -o \! -d "$output_param_dir" && status=3\$status
test -n "$istrfile" -a \! -r "$istrfile" && status=4\$status
test -n "$output_recon_dir" -a \! -d "$output_recon_dir" && status=5\$status
echo \$status
exit 0
EOF
            if test $? -eq 0 ; then
		chmod a+x "$temp_script"
		if test $? -ne 0 ; then
                    echo "emtiar: could not make $temp_script executable" 1>&2
                    status=1
		fi
            else
		echo "emtiar: could not create $temp_script" 1>&2
		status=1
            fi
            if test $status -eq 0 ; then
		echo "*** Checking nodes..."
		result=`$ompiexec ${ompiexec_np:+"$ompiexec_np"} "$temp_script"`
		if test $? -ne 0 ; then
                    echo "emtiar: OpenMPI's mpiexec, ${ompiexec}, failed" 1>&2
                    status=1
		fi
		echo " $result" | grep -q 1
		if test $? -eq 0 ; then
                    echo "emtiar: one or more nodes can not see the directory, $tmpdir, or that directory is not shared by all the nodes" 1>&2
                    status=1
		fi
		echo " $result" | grep -q 2
		if test $? -eq 0 ; then
                    # One or more nodes can not see the input tilt series.
		    # Make a copy.
		    tilt_series_copy="$tmpdir"/$$.copy
		fi
 		echo " $result" | grep -q 3
		if test $? -eq 0 ; then
                    # One or more nodes can not see the parameter files.  Make
		    # a copy.
		    param_copy="$tmpdir"/$$.param_copy
		fi
		echo " $result" | grep -q 4
		if test $? -eq 0 ; then
                    # One or more nodes can not see the initial reconstruction
		    # guess.  Make a copy.
		    need_istr_copy_0=1
		fi
 		echo " $result" | grep -q 5
		if test $? -eq 0 ; then
                    # One or more nodes can not see the output reconstruction.
		    # Keep a copy in the temporary directory.
		    need_istr_copy_1=1
		fi
            fi
            rm "$temp_script"
            trap INT QUIT TERM
        elif test -n "$machinefile" ; then
            if test $nproc_used -lt 0; then
                if test -z "$NSLOTS" ; then
		    nproc_used=`count_processors "$machinefile"`
		    if test $? -eq 0; then
			if test $nproc_used -eq 0; then
			    echo "emtiar: zero processors in $machinefile" 1>&2
			    exit 1
			fi
		    else
			exit 1
		    fi
                else
		    nproc_used="$NSLOTS"
		    if test "$nproc_used" -gt 0; then
			:
		    else
			echo "emtiar: NSLOTS is not a positive integer" 1>&2
                        exit 1
		    fi
                fi
            fi

            iproc=0
            output_param_dir=`dirname "$output_param_base"`
            if test $restart_recon -eq 0; then
		output_recon_dir=`dirname "$output_recon"`
            else
		output_recon_dir=""
            fi
            while test $iproc -lt $nproc_used; do
		machine=`print_ith_processor $iproc "$machinefile"`
		if test $? -ne 0; then
                    exit 1
		elif test -n "$machine"; then
                    echo "*** Checking node, $machine, ..."
		    
                    $rshcmd "$machine" /bin/sh -s <<EOF
test \! -d "$tmpdir" && exit 1
oval=0
if test $initial_appl_prm != yes; then
    test \! -r "$input_tilt_series" && oval=\`expr \$oval + 2\`
fi
test \! -r "$param_file" -o \! -d "$output_param_dir" && oval=\`expr \$oval + 4\`
test -n "$istrfile" -a \! -r "$istrfile" && oval=\`expr \$oval + 8\`
test -n "$output_recon_dir" -a \! -d "$output_recon_dir" && oval=\`expr \$oval + 16\`
exit \$oval
EOF
                    oval=$?
                    if test $oval -eq 1; then
                        # Child node can not see the temporary directory.  Can
                        # not proceed.
			echo "emtiar: the machine, $machine," \
                            " can not see the directory, $tmpdir" 1>&2
			exit 1
                    fi
                    if test `expr $oval % 4` -eq 2; then
                        # Child node can not see the input tilt series.  Make a
                        # copy.
			tilt_series_copy="$tmpdir"/$$.copy
			oval=`expr $oval - 2`
                    fi
                    if test `expr $oval % 8` -eq 4; then
                        # Child node can not see the parameter files.  Make a
                        # copy.
			param_copy="$tmpdir"/$$.param_copy
			oval=`expr $oval - 4`
                    fi
                    if test `expr $oval % 16` -eq 8; then
                        # Child node can not see the initial reconstruction
                        # guess.  Make a copy.
			need_istr_copy_0=1
			oval=`expr $oval - 8`
                    fi
                    if test `expr $oval % 32` -eq 16; then
                        # Child node can not see the output reconstruction.
                        # Keep a copy in the temporary directory.
			need_istr_copy_i=1
			oval=`expr $oval - 16`
                    fi
                    if test $oval -ne 0; then
                        # Presumably the rshcmd failed.
			echo "emtiar: could not connect to the " \
                            "machine, $machine, with the command, $rshcmd" 1>&2
			exit 1
                    fi
		fi
		iproc=`expr $iproc + 1`
            done
	fi
    fi

    parallel_options="$parallel_options
-tmpdir=$tmpdir
-no_nodecheck"
    tapir_cmd=tapir_parallel
    tapir_options="$tapir_options
$parallel_options"
    align_2d_cmd=align_2d_pi_parallel
    align_2d_options="$align_2d_options
$parallel_options"
fi

temp_reproj="$tmpdir"/$$.reproj

output_param_ext=`basename "$param_file" | awk '{ n = split($0,a,"."); if (n > 1) print "." a[n]; else print "" }'`

lastr=1.0
increasedr=0

# Perform the data processing.

if test $initial_appl_prm = yes; then
    target_tilt_series="$tmpdir"/$$.Mn
    old_ifs="$IFS"
    # Just a newline.
    IFS='
'
    initial_appl_prm_options="$initial_appl_prm_options
-res=$ires"
    ires=0
    set -- $initial_appl_prm_options
    IFS="$old_ifs"
    echo "**** Running: appl_prm" "$input_tilt_series" "$target_tilt_series" \
        "$@"
    trap 'rm "$target_tilt_series"; exit 1' $trap_signals
    time appl_prm "$input_tilt_series" "$target_tilt_series" "$@"
    if test $? -ne 0; then
        status=1
    fi
else
    target_tilt_series="$tilt_series_copy"
    if test X"$input_tilt_series" != X"$tilt_series_copy"; then
        trap 'rm "$tilt_series_copy"; exit 1' $trap_signals
        echo "**** Copying input tilt series to $tilt_series_copy"
        cp "$input_tilt_series" "$tilt_series_copy"
        if test $? -ne 0; then
            status=1
        fi
    fi
fi
appl_prm_options="$appl_prm_options
-res=$ires"
align_2d_options="$align_2d_options
-res=$ires"

if test -n "$param_copy"; then
    trap 'test X"$input_tilt_series" != X"$target_tilt_series" && rm "$target_tilt_series"; rm "$param_copy"; exit 1' $trap_signals
    echo "**** Copying input parameter file to $param_copy"
    cp "$param_file" "$param_copy"
    if test $? -ne 0; then
        status=1
    fi
    param_file="$param_copy"
fi

need_istr_copy=$need_istr_copy_0
if test $need_istr_copy -eq 1; then
    trap 'test X"$input_tilt_series" != X"$target_tilt_series" && rm "$target_tilt_series"; rm "$temp_recon"; exit 1' $trap_signals
    echo "**** Copying initial reconstruction guess to $temp_recon"
    cp "$istrfile" "$temp_recon"
    if test $? -ne 0; then
        status=1
    fi
    istrfile="$temp_recon"
fi

while test $irun -lt $nrun -a "$increasedr" -eq 0 -a $status -eq 0; do
    old_ifs="$IFS"
    # Just a newline.
    IFS='
'
    set -- $appl_prm_options
    IFS="$old_ifs"
    echo "**** Running: appl_prm" "$target_tilt_series" "$temp_aligned" \
	-iprmfile="$param_file" -shxyz="$apxshift":"$apyshift":"$apzshift" "$@"
    trap 'test X"$input_tilt_series" != X"$target_tilt_series" && rm "$target_tilt_series"; test -n "$param_copy" && rm "$param_copy"; rm "$temp_aligned"; exit 1' $trap_signals
    time appl_prm "$target_tilt_series" "$temp_aligned" \
	-iprmfile="$param_file" -shxyz="$apxshift":"$apyshift":"$apzshift" "$@"
    if test $? -ne 0; then
        status=1
    fi

    if test $status -eq 0; then
        old_ifs="$IFS"
        # Just a newline.
        IFS='
'
        set -- $tapir_options
        IFS="$old_ifs"
        trap 'test X"$input_tilt_series" != X"$target_tilt_series" && rm "$target_tilt_series"; test -n "$param_copy" && rm "$param_copy"; rm "$temp_aligned" "$temp_stat" "$temp_recon"; exit 1' $trap_signals
        if test -z "$istrfile"; then
            echo "**** Running: $tapir_cmd" "$temp_aligned" "$temp_recon" \
	        "$@"
            time $tapir_cmd "$temp_aligned" "$temp_recon" "$@"
        else
            echo "**** Running: $tapir_cmd" "$temp_aligned" "$temp_recon" \
	        -istrfile="$istrfile" "$@"
   	    time $tapir_cmd "$temp_aligned" "$temp_recon" -istrfile="$istrfile" -gres="$igres" "$@"
        fi
        igres=0
        if test $? -ne 0; then
            status=1
        fi
    fi

    if test $autoterm -ne 0 -a $status -eq 0; then
        loc=`expr 4 + "$ncycles"`
        thisr=`awk '{ if (NR == loc) print \$2; }' loc="$loc" "$temp_stat"`
        increasedr=`awk "BEGIN { if ($thisr > $lastr) print 1; else print 0; }"`
	if test "$increasedr" -ne 0 ; then
            echo "NOTE: terminating after this alignment stage; R-factor for the reconstruction increased from $lastr to $thisr"
        fi
        lastr="$thisr"
        unset loc thisr
    fi
    rm "$temp_stat"

    rm "$temp_aligned"
    need_istr_copy=$need_istr_copy_i
    if test $need_istr_copy -eq 1; then
        cp "$temp_recon" "$output_recon"
        if test $? -ne 0; then
            status=1
        fi
        if test $restart_recon -eq 0; then
            istrfile="$temp_recon"
        else
            istrfile=""
        fi
    else
        mv "$temp_recon" "$output_recon"
        if test $? -ne 0; then
            status=1
        fi
        if test $restart_recon -eq 0; then
            istrfile="$output_recon"
        else
            istrfile=""
        fi
    fi

    if test $status -eq 0; then
        old_ifs="$IFS"
        # Just a newline.
        IFS='
'
        set -- $proj_options
        IFS="$old_ifs"
        echo "**** Running: reproj" "$output_recon" "$target_tilt_series" \
	    "$temp_reproj" "$@"
        trap 'test X"$input_tilt_series" != X"$target_tilt_series" && rm "$target_tilt_series"; test -n "$param_copy" && rm "$param_copy"; test $need_istr_copy -eq 1 && rm "$temp_recon"; rm "$temp_reproj"; exit 1' $trap_signals
        time reproj "$output_recon" "$target_tilt_series" "$temp_reproj" "$@"
        if test $? -ne 0; then
            status=1
        fi
    fi

    new_param_file="$output_param_base"_"$irun""$output_param_ext"
    if test $status -eq 0; then
        old_ifs="$IFS"
        # Just a newline.
        IFS='
'
        set -- $align_2d_options
        IFS="$old_ifs"
        echo "**** Running: $align_2d_cmd" "$temp_reproj" "$target_tilt_series" \
	    -iprmfile="$param_file" -oprmfile="$new_param_file" \
   	    -shxyz="$apxshift":"$apyshift":"$apzshift" "$@"
        time "$align_2d_cmd" "$temp_reproj" "$target_tilt_series" \
	    -iprmfile="$param_file" -oprmfile="$new_param_file" \
	    -shxyz="$apxshift":"$apyshift":"$apzshift" "$@"
        if test $? -ne 0; then
            status=1
        fi
    fi

    rm "$temp_reproj"
    if test -z "$param_copy"; then
        param_file="$new_param_file"
    else
        echo "**** Copying intermediate parameter file to $param_copy"
        cp "$new_param_file" "$param_copy"
        if test $? -ne 0; then
            status=1
        fi
    fi

    irun=`expr $irun + 1`
done

test X"$input_tilt_series" != X"$target_tilt_series" && rm "$target_tilt_series"
test -n "$param_copy" && rm "$param_copy"
test $need_istr_copy -eq 1 && rm "$temp_recon"

exit $status

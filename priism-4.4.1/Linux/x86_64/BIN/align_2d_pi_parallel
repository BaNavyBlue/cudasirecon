#!/bin/sh

# A shell script wrapper to implement a parallel alignment of two projection
# series.
#
# Usage:
#      align_2d_pi_parallel reference target -ompiexec=mpiexec_path \
#          [-np=n] [-tmpdir=dir] [-no_nodecheck] [align_2d_pi options]
# or
#      align_2d_pi_parallel reference target -machinefile=file \
#          [-np=n] [-rshcmd=cmd] [-bkgopt=opt] [-tmpdir=dir] [-no_nodecheck] \
#          [-checkcmd=cmd] [align_2d_pi options]
# or
#      align_2d_pi_parallel reference target [-np=n] [-tmpdir=dir] \
#          [align_2d_pi options]
#
# The first form is for use with OpenMPI 1.3 or later where OpenMPI's mpiexec
# or mpirun will be used to start the parallel tasks on one or more hosts.
# The second form is for a cluster of machines where the machines to use
# are listed in a MPICH-style machines file.  The third form is for a
# single machine with multiple processors (by default the script assumes 2).
# If you have both -ompiexec and -machinefile options, the former takes
# precedence.
#
# Writes files (pieces of the alignment parameter file, log file,
# and diagnostic images) to a temporary directory.  You can specify the
# directory explicitly with the -tmpdir option; otherwise it will be a
# directory named tmp in your home directory.  When used with a cluster,
# the temporary directory must be visible to all the compute nodes.  The
# directory will be created if it does not already exist.
#
# When using a cluster, it is easiest to avoid trouble if the input file
# paths (with the exception of the machines file) specified on the command
# line are absolute.  You may use a relative path for the two tilt series or
# input parameter file but that leaves a greater possibility of false positives
# when checks are performed to see if the cluster nodes can see those files.
#
# Expects the standard Unix commands, awk, cat, chmod, cp, cut, dirname, echo,
# expr, grep, kill, mkdir, pwd, rm, sed, tail, test, time, and xargs to be in
# the search path.  Uses the tail -n number syntax which the IRIX 5.3 version
# of tail does not handle.
#
# Expects the Priism commands align_2d_pi, count_processors, header, mergemrc,
# and print_ith_processor to be in the search path.  Relies on the environment
# variable IVE_ENV_SETUP being set to the commands to set the environment on
# the remote machines or that the current setting for the environment variable
# IVE_BASE can be used on the remote machines as well.

# Since the script never uses pathname expansion, disable it.
set -f

status=0

# Extract required arguments.
if test $# -lt 2; then
    echo "usage: align_2d_pi_parallel reference target [options]" 1>&2
    exit 1
fi
reference="$1"
shift
target="$1"
shift

# Set up default values for options.
ompiexec=""
ompiexec_np=""
machinefile=""
nproc_used=-1
rshcmd="ssh -x"
bkgopt=-n
checkcmd=""
tmpdir=""
nodecheck="yes"
ivstart=0
imod=1
ivend=`echo 0 0 | header "$reference" | sed -n -e '/Image Size (X,Y,Sections)\.\.*/ s/Image Size (X,Y,Sections)\.\.*//p' | awk '{print $3}'`
# Structure the test this way to handle the case where the value is not an
# integer.
if test "$ivend" -gt 0; then
    ivend=`expr "$ivend" - 1`
else
    ivend=0
    status=1
    echo "align_2d_pi_parallel: could not determine the number of sections" 1>&2
fi
cfile=""
ofile=""
iprmfile="none"
oprmfile=""
# align_2d_options will collect options to be passed on to align_2d_pi.
# Newlines will be used to separate the options collected (that means
# that options which include newlines will not be handled correctly).
align_2d_options=""

# Parse command line options.
while test $# -gt 0; do
    case "$1" in
        -bkgopt*)
            # When distributing the work, this is not quoted so the
            # appropriate quoting is up to the caller.
            bkgopt="`echo '' $1 | sed -e 's/ -bkgopt=//'`"
            ;;

        -checkcmd=*)
            checkcmd=`echo " $1" | sed -e 's/ -checkcmd=//'`
            ;;

        -machinefile=*)
            machinefile="`echo '' $1 | sed -e 's/ -machinefile=//'`"
            ;;

        -no_nodecheck)
            nodecheck=""
            ;;

        -np=*)
            # Ignore -np= if NSLOTS is set.
            if test -z "$NSLOTS" ; then
		nproc_used="`echo '' $1 | sed -e 's/ -np=//'`"
                # Structure the test this way (empty then clause) to handle
                # the case where the value is not an integer.
		if test "$nproc_used" -gt 0; then
                    :
		else
                    status=1
                    echo "align_2d_pi_parallel: invalid number of processors" 1>&2
		fi
		ompiexec_np="$1"
            fi
            ;;

        -ompiexec=*)
            ompiexec=`echo " $1" | sed -e 's/ -ompiexec=//'`
            ;;

        -rshcmd=*)
            # When distributing the work, the command specified with this
            # option is not quoted, so appropriate quoting is up to the
            # caller.
            rshcmd="`echo '' $1 | sed -e 's/ -rshcmd=//'`"
            ;;

        -tmpdir=*)
            tmpdir=`echo " $1" | sed -e 's/ -tmpdir=//'`
            ;;

        -cor_out=*)
            cfile="`echo '' $1 | sed -e 's/ -cor_out=//'`"
            if test "$cfile" = none; then
                cfile=""
            elif `echo X$cfile | grep -v -q ^X/` ; then
                # Because the merge step uses the temporary directory as the
                # current working directory, ensure that a relative path to
                # the output cross-correlation map is restated as an absolute
                # path.
                cfile=`pwd`/"$cfile"
            fi
            ;;

	-imod=*)
            imod="`echo '' $1 | sed -e 's/ -imod=//'`"
            align_2d_options="$align_2d_options"
            ;;

        -iv=*)
            ivstart="`echo '' $1 | sed -e 's/ -iv=//' | cut -d : -f 1`"
            i="`echo '' $1 | sed -e 's/ -iv=//' | cut -s -d : -f 2`"
            if test \! -z "$i"; then
                ivend="$i"
            fi
            # Structure the test this way (empty then clause) to handle
            # the case where the value is not an integer.
            if test "$ivstart" -ge 0 -a "$ivend" -ge "$ivstart"; then
                :
            else
                status=1
                echo "align_2d_pi_parallel: invalid section start or end" 1>&2
            fi
            ;;

        -iprmfile=*)
            iprmfile="`echo '' $1 | sed -e 's/ -iprmfile=//'`"
            if test -z "$iprmfile"; then
                iprmfile="none"
            fi
            ;;

        -ofile=*)
            ofile="`echo '' $1 | sed -e 's/ -ofile=//'`"
            if test "$ofile" = none; then
                ofile=""
            elif `echo X$ofile | grep -v -q ^X/` ; then
                # Because the merge step uses the temporary directory as the
                # current working directory, ensure that a relative path to
                # the output aligned series is restated as an absolute path.
                ofile=`pwd`/"$ofile"
            fi
            ;;

        -oprmfile=*)
            oprmfile="`echo '' $1 | sed -e 's/ -oprmfile=//'`"
            if test "$oprmfile" = none; then
                oprmfile=""
            elif `echo X$oprmfile | grep -v -q ^X/` ; then
                # Because the merge step uses the temporary directory as the
                # current working directory, ensure that a relative path to
                # the output parameter file is restated as an absolute path.
                oprmfile=`pwd`/"$oprmfile"
            fi
            ;;

        *)
            # Pass anything else to align_2d_pi.
            align_2d_options="$align_2d_options
$1"
            ;;
    esac
    shift
done

if test -z "$tmpdir"; then
    tmpdir="$HOME"/tmp
fi

if test -e "$tmpdir"; then
    if test \! -d "$tmpdir"; then
        echo "align_2d_pi_parallel: $tmpdir is not a directory" 1>&2
        status=1
    elif test \! -w "$tmpdir"; then
        echo "align_2d_pi_parallel: $tmpdir exists but is not writable" 1>&2
        status=1
    fi
else
    mkdir -p "$tmpdir" || status=1
fi

# If the alignment only uses the simplex method, then no cross-correlation
# file will be generated.
if test X2 = X"$imod" ; then
    cfile=""
fi

if test -z "$ompiexec" -a -n "$machinefile" ; then
    if test $nproc_used -lt 0; then
        if test -z "$NSLOTS" ; then
            nproc_used=`count_processors "$machinefile"`
            if test $? -eq 0; then
		if test $nproc_used -eq 0; then
                    echo "align_2d_pi_parallel: zero processors in $machinefile" 1>&2
                    status=1
		fi
            else
		status=1
            fi
        else
            nproc_used="$NSLOTS"
            if test "$nproc_used" -gt 0; then
                :
            else
                status=1
                echo "align_2d_pi_parallel: NSLOTS is not a positive integer" 1>&2
            fi
        fi
    fi
elif test -z "$ompiexec" ; then
    if test $nproc_used -lt 0; then
        nproc_used="${NSLOTS:-1}"
        if test "$nproc_used" -gt 0; then
            :
        else
            status=1
            echo "align_2d_pi_parallel: NSLOTS is not a positive integer" 1>&2
        fi
    fi
fi

if test $status -ne 0; then
    exit 1
fi

# The number of processors used can not exceed the number of projections in the
# tilt series.
# reconstruction.
if test -z "$ompiexec" ; then
    if test $nproc_used -gt `expr "$ivend" - "$ivstart" + 1`; then
        nproc_used=`expr "$ivend" - "$ivstart" + 1`
    fi
    iv_part_inc=`expr \( "$ivend" - "$ivstart" + 1 \) / $nproc_used`
    iv_part_rem=`expr \( "$ivend" - "$ivstart" + 1 \) - \( $nproc_used \* $iv_part_inc \)`
fi
param_part_base=$$.prm
p_part_list="$tmpdir"/$$.parts
c_part_base=$$.xcor
c_part_list="$tmpdir"/$$.cparts
o_part_base=$$.stk
o_part_list="$tmpdir"/$$.oparts
log_part_base=$$.log
temp_log_list="$tmpdir"/$$.log_parts
proc_list="$tmpdir"/$$.ids

# If using a cluster, probe each node to verify that it can see the temporary
# directory and check whether or not it can see the two tilt series and the
# input parameter file, if any.
reference_copy="$reference"
target_copy="$target"
iprmfile_copy="$iprmfile"
if test -n "$nodecheck" ; then
    if test -n "$ompiexec" ; then
        temp_script="$tmpdir"/$$.sh
        trap 'rm "$temp_script" ; exit 1' INT QUIT TERM
        cat >"$temp_script" <<EOF
#!/bin/sh
status=
test \! -r "$temp_script" && status=1\$status
test \! -r "$reference" && status=2\$status
test \! -r "$target" && status=3\$status
if test X"$iprmfile" != Xnone; then
    test \! -r "$iprmfile" && status=4\$status
fi
echo \$status
exit 0
EOF
        if test $? -eq 0 ; then
            chmod a+x "$temp_script"
            if test $? -ne 0 ; then
                echo "align_2d_pi_parallel: could not make $temp_script executable" 1>&2
                status=1
            fi
        else
            echo "align_2d_pi_parallel: could not create $temp_script" 1>&2
            status=1
        fi
        if test $status -eq 0 ; then
            echo "*** Checking nodes..."
            result=`$ompiexec ${ompiexec_np:+"$ompiexec_np"} "$temp_script"`
            if test $? -ne 0 ; then
                echo "align_2d_pi_parallel: OpenMPI's mpiexec, ${ompiexec}, failed" 1>&2
                status=1
            fi
            echo " $result" | grep -q 1
            if test $? -eq 0 ; then
                echo "align_2d_pi_parallel: one or more nodes can not see the directory, $tmpdir, or that directory is not shared by all of the nodes" 1>&2
                status=1
            fi
            echo " $result" | grep -q 2
            if test $? -eq 0 ; then
                # One or more nodes can not see the reference tilt series.
		# Make a copy.
		reference_copy="$tmpdir"/$$.ref_copy
            fi
            echo " $result" | grep -q 3
            if test $? -eq 0 ; then
                # One or more nodes can not see the target tilt series.
		# Make a copy.
		target_copy="$tmpdir"/$$.tgt_copy
            fi
	    echo " $result" | grep -q 4
            if test $? -eq 0 ; then
                # One or more nodes can not see the input parameter file.
		# Make a copy.
		iprmfile_copy="$tmpdir"/$$.prm_copy
            fi
	fi
        rm "$temp_script"
        trap INT QUIT TERM
    elif test -n "$machinefile" ; then
	iproc=0
	while test $iproc -lt $nproc_used; do
            machine=`print_ith_processor $iproc "$machinefile"`
            if test $? -ne 0; then
		exit 1
            elif test -n "$machine"; then
		echo "*** Checking node, $machine, ..."

		$rshcmd "$machine" /bin/sh -s <<EOF
test \! -d "$tmpdir" && exit 1
if test X"$iprmfile" != Xnone; then
    if test -r "$reference"; then
        if test -r "$target"; then
            test -r "$iprmfile" && exit 0
            exit 8
        else
            test -r "$iprmfile" && exit 4
            exit 12
        fi
    elif test -r "$target"; then
        test -r "$iprmfile" && exit 2
        exit 10
    else
        test -r "$iprmfile" && exit 6
        exit 14
    fi
elif test -r "$reference"; then
    test -r "$target" && exit 0
    exit 4
else
    test -r "$target" && exit 2
    exit 6
fi
EOF

		case $? in
                    0)
                        # Child node can see the temporary directory and all
                        # the input files.  Nothing special needs to be done.
			;;

                    1)
                        # Child node can not see the temporary directory.  Can
			# not proceed.
			echo "align_2d_pi_parallel: the machine, $machine," \
                            " can not see the directory, $tmpdir" 1>&2
			exit 1
			;;

                    2)
                        # Child node can not see the reference tilt series so
                        # make a copy.
			reference_copy="$tmpdir"/$$.ref_copy
			;;

                    4)
                        # Child node can not see the target tilt series so make
                        # a copy.
			target_copy="$tmpdir"/$$.tgt_copy
			;;

                    6)
                        # Child node can see either tilt series so make copies
			# of both.
			reference_copy="$tmpdir"/$$.ref_copy
			target_copy="$tmpdir"/$$.tgt_copy
			;;

                    8)
                        # Child node can not see the input parameter file.
			# Make a copy.
			iprmfile_copy="$tmpdir"/$$.prm_copy
			;;

                    10)
                        # Child node can not see the reference tilt series and
                        # input parameter file.  Make copies of both.
			reference_copy="$tmpdir"/$$.ref_copy
			iprmfile_copy="$tmpdir"/$$.prm_copy
			;;

                    12)
                        # Child node can not see the target tilt series and
                        # input parameter file.  Make copies of both.
			target_copy="$tmpdir"/$$.tgt_copy
			iprmfile_copy="$tmpdir"/$$.prm_copy
			;;

                    14)
                        # Child node can not see the input series and the
                        # input parameter file.  Make a copy of all three.
			reference_copy="$tmpdir"/$$.ref_copy
			target_copy="$tmpdir"/$$.tgt_copy
			iprmfile_copy="$tmpdir"/$$.prm_copy
			;;

                    *)
                        # Presumably the rshcmd failed.
			echo "align_2d_pi_parallel: could not connect to the " \
                            "machine, $machine, with the command, $rshcmd" 1>&2
			exit 1
			;;
		esac
            fi
            iproc=`expr $iproc + 1`
	done
    fi
fi

if test $status -ne 0 ; then
    exit 1
fi

# Set the handler in case of unexpected termination.
trap 'test X"$reference" != X"$reference_copy" && rm "$reference_copy"; test X"$target" != X"$target_copy" && rm "$target_copy"; test X"$iprmfile" != X"$iprmfile_copy" && rm "$iprmfile_copy"; exit 1' INT QUIT TERM

# Copy over input files if necessary.
if test X"$reference" != X"$reference_copy"; then
    echo "*** Copying reference tilt series to $reference_copy"
    cp "$reference" "$reference_copy"
    if test $? -ne 0; then
        target_copy="$target"
        iprmfile_copy="$iprmfile"
        status=1
    fi
fi
if test X"$target" != X"$target_copy"; then
    echo "*** Copying target tilt series to $target_copy"
    cp "$target" "$target_copy"
    if test $? -ne 0; then
        iprmfile_copy="$iprmfile"
        status=1
    fi
fi
if test X"$iprmfile" != X"$iprmfile_copy"; then
    echo "*** Copying input parameter file to $iprmfile_copy"
    cp "$iprmfile" "$iprmfile_copy"
    if test $? -ne 0; then
        status=1
    fi
fi

# Reset the positional arguments to be the ones that are passed through to
# align_2d_pi.
old_ifs="$IFS"
# Just a newline.
IFS='
'
set -- $align_2d_options
IFS="$old_ifs"

# So the quoting of arguments can all be done on the local machine, set up
# a script to do the Priism setup and execute align_2d_pi.
temp_script="$tmpdir"/$$.sh
if test -n "$ompiexec" ; then
    if test -z "$IVE_ENV_SETUP"; then
        cat >"$temp_script" <<EOF
#!/bin/sh
. "$IVE_BASE"/Priism_setup.sh
EOF
    else
        cat >"$temp_script" <<EOF
#!/bin/sh
$IVE_ENV_SETUP
EOF
    fi
    if test $? -ne 0 ; then
        echo "align_2d_pi_parallel: could not create $temp_script" 1>&2
        status=1
    fi
    cat >>"$temp_script" <<EOF
nproc_used=\$OMPI_COMM_WORLD_SIZE
if test \$nproc_used -gt \`expr "$ivend" - "$ivstart" + 1\`; then
    nproc_used=\`expr "$ivend" - "$ivstart" + 1\`
fi
iv_part_inc=\`expr \\( "$ivend" - "$ivstart" + 1 \\) / \$nproc_used\`
iv_part_rem=\`expr "$ivend" - "$ivstart" + 1 - \$nproc_used \\* "\$iv_part_inc" \`
iproc=\$OMPI_COMM_WORLD_RANK
if test \$iproc -lt \$nproc_used ; then
    if test \$iproc -eq 0 ; then
        echo ${param_part_base}_0 > "$p_part_list"
        if test -n "$cfile" ; then
            echo ${c_part_base}_0 > "$c_part_list"
        fi
        if test -n "$ofile" ; then
            echo ${o_part_base}_0 > "$o_part_list"
        fi
        echo ${log_part_base}_0 > "$temp_log_list"
        jproc=1
        while test \$jproc -lt \$nproc_used ; do
            echo ${param_part_base}_\$jproc >> "$p_part_list"
            if test -n "$cfile" ; then
                echo ${c_part_base}_\$jproc >> "$c_part_list"
            fi
            if test -n "$ofile" ; then
                echo ${o_part_base}_\$jproc >> "$o_part_list"
            fi
            echo ${log_part_base}_\$jproc >> "$temp_log_list"
            jproc=\`expr \$jproc + 1\`
        done
    fi
    if test \$iproc -lt "\$iv_part_rem" ; then
        iv_part_start=\`expr "$ivstart" + \$iproc \\* \\( "\$iv_part_inc" + 1 \\)\`
        iv_part_end=\`expr "\$iv_part_start" + "\$iv_part_inc"\`
    else
        iv_part_start=\`expr "$ivstart" + \$iproc \\* "\$iv_part_inc" + "\$iv_part_rem"\`
        iv_part_end=\`expr "\$iv_part_start" + "\$iv_part_inc" - 1\`
    fi
else
    exit 0
fi
time align_2d_pi "$reference_copy" "$target_copy" -oprmfile="$tmpdir"/${param_part_base}_\$iproc -iprmfile="$iprmfile_copy" -iv="\$iv_part_start":"\$iv_part_end" ${cfile:+-cor_out="$tmpdir"/${c_part_base}_\$iproc} ${ofile:+-ofile="$tmpdir"/${o_part_base}_\$iproc} "\$@" >"$tmpdir"/${log_part_base}_\$iproc 2>&1
EOF
    if test $? -ne 0 ; then
        echo "align_2d_pi_parallel: could not append to $temp_script" 1>&2
        status=1
    fi
else
    if test -z "$IVE_ENV_SETUP"; then
	cat >"$temp_script" <<EOF
#!/bin/sh
. "$IVE_BASE"/Priism_setup.sh
align_2d_pi "\$@"
EOF
    else
	cat >"$temp_script" <<EOF
#!/bin/sh
$IVE_ENV_SETUP
align_2d_pi "\$@"
EOF
    fi
    if test $? -ne 0; then
        echo "align_2d_pi_parallel: could not create $temp_script" 1>&2
        status=1
    fi
fi
if test $status -eq 0; then
    chmod a+x "$temp_script"
    if test $? -ne 0; then
        echo "align_2d_pi_parallel: could not make $temp_script executable" 1>&2
        status=1
    fi
fi

trap 'test -e "$proc_list" && cat "$proc_list" | xargs kill; cd "$tmpdir"; cat "$p_part_list" "$temp_log_list" | xargs rm; test -e "$c_part_list" && cat "$c_part_list" | xargs rm; test -e "$o_part_list" && cat "$o_part_list" | xargs rm; rm "$p_part_list" "$c_part_list" "$o_part_list" "$temp_log_list" "$temp_script" ; test -e "$proc_list" && rm "$proc_list"; test X"$reference" != X"$reference_copy" && rm "$reference_copy"; test X"$target" != X"$target_copy" && rm "$target_copy"; test X"$iprmfile" != X"$iprmfile_copy" && rm "$iprmfile_copy"; exit 1' INT QUIT TERM

# Distribute the work.
if test -n "$ompiexec" ; then
    if test $status -eq 0 ; then
        echo "*** Running $ompiexec" ${ompiexec_np:+{"$opmiexec_np"} \
            "$temp_script" "$@"
        $ompiexec ${ompiexec_np:+"$ompiexec_np"} "$temp_script" "$@"
        if test $? -ne 0 ; then
            echo "align_2d_pi_parallel: OpenMPI's mpiexec, ${ompiexec}, failed" 1>&2
            status=1
	fi
    fi
else
    iproc=0
    jproc=0
    while test $iproc -lt $nproc_used; do
	p_part=${param_part_base}_$iproc
	c_part=${c_part_base}_$iproc
	o_part=${o_part_base}_$iproc
	if test $iproc -eq 0; then
            echo $p_part > "$p_part_list"
            if test $? -ne 0; then
		echo "align_2d_pi_parallel: unable to create $p_part_list" 1>&2
		status=1
            fi
            if test -n "$cfile"; then
		echo $c_part > "$c_part_list"
		if test $? -ne 0; then
                    echo "align_2d_pi_parallel: unable to create $c_part_list" 1>&2
                    status=1
		fi
            fi
            if test -n "$ofile"; then
		echo $o_part > "$o_part_list"
		if test $? -ne 0; then
                    echo "align_2d_pi_parallel: unable to create $o_part_list" 1>&2
                    status=1
		fi
            fi
	    echo ${log_part_base}_$iproc > "$temp_log_list"
            if test $? -ne 0; then
		echo "align_2d_pi_parallel: unable to create $temp_log_list" 1>&2
		status=1
            fi
            iv_part_start="$ivstart"
	else
	    echo $p_part >> "$p_part_list"
            if test $? -ne 0; then
		echo "align_2d_pi_parallel: unable to append to $p_part_list" 1>&2
		status=1
            fi
            if test -n "$cfile"; then
		echo $c_part >> "$c_part_list"
		if test $? -ne 0; then
                    echo "align_2d_pi_parallel: unable to append to $c_part_list" 1>&2
                    status=1
		fi
            fi
            if test -n "$ofile"; then
		echo $o_part >> "$o_part_list"
		if test $? -ne 0; then
                    echo "align_2d_pi_parallel: unable to append to $o_part_list" 1>&2
                    status=1
		fi
            fi
	    echo ${log_part_base}_$iproc >> "$temp_log_list"
            if test $? -ne 0; then
		echo "align_2d_pi_parallel: unable to append to $temp_log_list" 1>&2
		status=1
            fi
	    iv_part_start=`expr "$iv_part_end" + 1`
	fi
	if test $iproc -lt $iv_part_rem; then
	    iv_part_end=`expr "$iv_part_start" + "$iv_part_inc"`
	else
	    iv_part_end=`expr "$iv_part_start" + "$iv_part_inc" - 1`
	fi

	if test -z "$machinefile"; then
            echo "*** Running: $temp_script" "$reference_copy" "$target_copy" \
		-oprmfile="$tmpdir"/$p_part \
		-iprmfile="$iprmfile_copy" \
		-iv="$iv_part_start":"$iv_part_end" \
		${cfile:+-cor_out="$tmpdir"/$c_part} \
		${ofile:+-ofile="$tmpdir"/$o_part} "$@"
            time "$temp_script" "$reference_copy" "$target_copy" \
		-oprmfile="$tmpdir"/$p_part \
		-iprmfile="$iprmfile_copy" \
		-iv="$iv_part_start":"$iv_part_end" \
		${cfile:+-cor_out="$tmpdir"/$c_part} \
		${ofile:+-ofile="$tmpdir"/$o_part} "$@" \
		>"$tmpdir"/${log_part_base}_$iproc 2>&1 &
            if test $iproc -eq 0; then
		echo $! > "$proc_list"
            else
		echo $! >> "$proc_list"
            fi
            if test $? -ne 0; then
		echo "align_2d_pi_parallel: unable to write to $proc_list" 1>&2
		status=1
            fi
	else
            machine=`print_ith_processor $jproc "$machinefile"`
            if test $? -eq 0; then
		if test -z "$machine"; then
                    jproc=0
                    machine=`print_ith_processor $jproc "$machinefile"`
                    if test $? -ne 0; then
			status=1
                    fi
		fi
            else
		status=1
            fi
            if test $status -eq 0; then
		if test -n "$checkcmd"; then
                    eval $checkcmd
		fi
		echo "*** Running: $rshcmd $bkgopt $machine $temp_script" \
                    "$reference_copy" "$target_copy" -oprmfile="$tmpdir"/$p_part \
                    -iprmfile="$iprmfile_copy" \
                    -iv="$iv_part_start":"$iv_part_end" \
                    ${cfile:+-cor_out="$tmpdir"/$c_part} \
                    ${ofile:+-ofile="$tmpdir"/$o_part} "$@"
                # Escape quotes for where the quoting must be done on the
		# remote side.  This does not work for the quoting of $@ which
		# places limits on the characters that can be included in the
		# other options.
		$rshcmd $bkgopt "$machine" time \"$temp_script\" \
                    \"$reference_copy\" \"$target_copy\" \
                    -oprmfile=\"$tmpdir\"/$p_part \
                    -iprmfile=\"$iprmfile_copy\" \
                    -iv=\"$iv_part_start\":\"$iv_part_end\" \
                    ${cfile:+-cor_out=\"$tmpdir\"/$c_part} \
                    ${ofile:+-ofile=\"$tmpdir\"/$o_part} "$@" \
                    >"$tmpdir"/${log_part_base}_$iproc 2>&1 &
		if test $iproc -eq 0; then
                    echo $! > "$proc_list"
		else
                    echo $! >> "$proc_list"
		fi
		if test $? -ne 0; then
                    echo "align_2d_pi_parallel: unable to write to $proc_list" 1>&2
                    status=1
		fi
            fi
	fi
	iproc=`expr $iproc + 1`
	jproc=`expr $jproc + 1`
    done
    wait
    rm "$proc_list"
fi

if test X"$reference" != X"$reference_copy"; then
    rm "$reference_copy"
fi
if test X"$target" != X"$target_copy"; then
    rm "$target_copy"
fi
if test X"$iprmfile" != X"$iprmfile_copy"; then
    rm "$iprmfile_copy"
fi
trap 'cd "$tmpdir"; cat "$p_part_list" "$temp_log_list" | xargs rm; test -e "$c_part_list" && cat "$c_part_list" | xargs rm; test -e "o_part_list" && cat "$o_part_list" | xargs rm; rm "$p_part_list" "$c_part_list" "$o_part_list" "$temp_log_list" "$temp_script" ; exit 1' INT QUIT TERM

cd "$tmpdir"
if test $? -ne 0; then
    status=1
fi

# Merge the pieces.
cat "$temp_log_list" | xargs cat
if test $status -eq 0; then

    if test -n "$oprmfile"; then
        # Save old stdin.
        exec 3<&0
        exec < "$p_part_list"

        # Some parameter files contain trailing empty lines; to handle them
        # remove lines which are empty or only contain spaces.
        if read prm_part; then
            cat "$prm_part" | sed -e '/^ *$/ d' > "$oprmfile"
            if test $? -ne 0; then
                echo "align_2d_pi_parallel: could not merge $prm_part into $oprmfile"
                status=1
            fi
        else
            echo "align_2d_pi_parallel: empty part list" 1>&2
            status=1
        fi

        while read prm_part; do
            tail -n +3 "$prm_part" | sed -e '/^ *$/ d' >> "$oprmfile"
            if test $? -ne 0; then
                echo "align_2d_pi_parallel: could not merge $prm_part into $oprmfile"
                status=1
            fi
        done

        # Restore old stdin.
        exec 0<&3
    fi
fi

if test -n "$cfile" -a $status -eq 0; then
    echo "*** Running mergemrc $cfile -f=$c_part_list"
    time mergemrc "$cfile" -f="$c_part_list"
    if test $? -ne 0; then
        echo "align_2d_pi_parallel: could not merge results to form $cfile"
        status=1
    fi
    cat "$c_part_list" | xargs rm
    rm "$c_part_list"
fi

if test -n "$ofile" -a $status -eq 0; then
    echo "*** Running mergemrc $ofile -f=$o_part_list"
    time mergemrc "$ofile" -f="$o_part_list"
    if test $? -ne 0; then
        echo "align_2d_pi_parallel: could not merge results to form $ofile"
        status=1
    fi
    cat "$o_part_list" | xargs rm
    rm "$o_part_list"
fi

cat "$temp_log_list" "$p_part_list" | xargs rm
rm "$temp_log_list" "$p_part_list" "$temp_script"

exit $status

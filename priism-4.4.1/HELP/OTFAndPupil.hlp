KEYWORD
       selecting_otf measuring_otf otf_format

DESCRIPTION OTF
   Deconvolution algorithms frequently assume that one
   knows how the microscope blurs the image of the sample.
   The point spread function (PSF) is one way to describe
   the microscope's blur.  Deconvolution algorithms in
   Priism do not use the point spread function directly.
   Instead, they expect either the optical transfer
   function (OTF) or pupil function both of which can be
   derived from the point spread function.

   The point spread function is the image that a point
   source of light makes in the microscope.  Priism's
   deconvolution algorithms (with one exception) assume
   that the point spread function does not depend on the
   position of the point in the microscope's field of
   view.  The transfer function for the microscope is
   the Fourier transform of the point spread function.
   In Priism's documentation, we frequently use the
   terms optical transfer function or contrast transfer
   function (CTF) as synonyms for the transfer function
   of the microscope.  Others are more accurate with
   their terminology:  using optical transfer function
   to refer to the component of the net transfer
   function that arises from the optics of the microscope
   (excluding the contributions from the camera, for
   instance) and using the contrast function to refer to
   the squared modulus of the intensity of an image of a
   square-wave pattern.

   The pupil function describes the optics of the
   microscope.  Using a process called phase retrieval
   and assumptions about the other contributions to the
   point spread function that are not part of the optics
   (namely the camera), it is possible to compute a pupil
   functions from the point spread function.

selecting_otf
   Priism's deconvolution applications will automatically
   select an OTF or pupil function when you select a data
   file to deconvolve.  They do so based on the lens number
   recorded in the data file's header.  The mapping between
   lens number and an OTF or pupil function is defined by
   the CTF/CTF.def file in the Priism distribution (or on a
   per-user basis by a .iveprefs/CTF.def file in the user's
   home directory). The default mapping is to one of the
   two axially and radially symmetric OTFs for the old om1
   microscope that was in John Sedat's lab at UCSF.

   Several sample radially-symmetric OTFs are available in
   the CTF subdirectory of the Priism distribution that were
   measured on John Sedat's om1.  In general, you should use
   a measured (or theoretically modeled) OTF for your
   microscope rather than one of those sample OTFs:  the
   topic "measuring_otf" describes how to generate an OTF
   file.  Of the sample OTFs, the ones with "lens12" in the
   file name were taken with an Olympus 60x 1.4 NA objective
   and the ones with "lens13" in the file name were taken
   with a Nikon 100x objective.  lens12.realctf and
   lens13.realctf represent axially- and radially-symmetric
   PSFs which assume that you have adjusted the immersion
   oil to give a symmetric PSF.  If you have not adjusted
   the immersion oil, you should use an asymmetric PSF to
   obtain a better result from the deconvolution.  All
   asymmetric OTFs have names of the form

       lens12_refractive index_asym.ctf

   .  If you want to select the appropriate asymmetric OTF
   to use, first examine your data to see if the out-of-
   focus blur is mostly thrown below (lower z) the object
   or above it (higher z).  If most of the blur is thrown
   below, choose one of the asymmetric OTFs with a
   refractive index less than 1.5140 (the refractive index
   of the immersion oil that gave the most axially
   symmetric PSF with the lens).  If most of the blur is
   above the object, choose one of the asymmetric OTFs
   with a refractive index greater than 1.5140.

measuring_otf
   If you do not already have the OTF or pupil function for
   your imaging system, the recommended method for obtaining
   one is to measure it experimentally.  I'll outline a
   procedure for measuring the OTF or pupil function with an
   emphasis on the computational aspects or those peculiar to
   Priism's deconvolution application.  For a fuller
   consideration of the process, consult the literature;
   two references are:

       Hiraoka, Y., Sedat, J.W., and Agard, D.A. (1990).
       Determination of the three-dimensional imaging
       properties of an optical microscope system: partial
       confocal behavior in epi-fluorescence microscopy.
       Biophys. J., 57: 325-333.

       Hiraoka, Y., Sedat, J.W., and Agard, D.A. (1987).
       The use of a charge-coupled device for quantitative
       optical microscopy of biological structures. Science
       238: 36-41.

   To generate a 3D OTF for the deconvolution application,

   1) Image a single fluorescent bead at evenly spaced optical
      sections.  To improve the signal-to-noise ratio at the
      edges of the point spread function without saturating
      the peak, it can be useful to take n images at each
      section; these are then computationally combined offline.
      Because Priism's deconvolution program will modify the
      OTF to match different pixel spacings or wavelengths, it
      is not necessary to use the same pixel spacing and
      wavelength for imaging the bead and for imaging your
       normal samples.
   2) If you collected multiple images for each optical section,
      combine them.  To combine the sections using an unweighted
      sum, you can use RunProj or superimpose_psf.  superimpose_psf
      also sums the photosensor readings, interpolates a peak
      position, and can estimate and subtract a constant
      background level.
   3) Correct for variations in the illumination intensity.
      For data with one of the known extended header formats
      (the IM library documentation lists them), CCDCor can do
      this for you using the illumination intensity measurements
      in the extended header.
   4) Remove the background not due to the bead.  If the
      background can be assumed to be a constant and you have an
      estimate of its value, you can subtract that value during
      the calculation of the Fourier transform of the PSF (see
      below).  superimpose_psf includes the option to estimate
      (from the edge pixels of the in-focus section and the
      sections above and below the in-focus section) and subtract
      that estimate.  When removing the background, you'll also
      want to coerce to zero any elements of the PSF that are
      negative.  Threshold can do that (set the condition to
      "above or equal to threshold", the threshold and background
      to zero, and the result to "masked data").  If you are
      planning to correct the phases to subpixel accuracy, it's
      best to defer the coercion of the negative values until
      the Fourier transform step.
   5) Determine the position of the peak in order to correct the
      phases in the OTF.  The correction to the phases can either
      be done as part of the Fourier transform step or, if you use
      radially averaging, during the radially averaging step.
      superimpose_psf can interpolate the position of the peak; it
      uses a quadratic fit to the brightest pixel and that pixel's
      six immediate neighbors.
   6) At this point you have a measured PSF.  Perform a 3D Fourier
      transform to compute the OTF.  Priism's 3D Fourier transform
      can do that for you; it will also subtract a constant
      background and apply the shift to position the PSF peak at
      the origin.  If you use Priism's Fourier transform, keep
      the following points in mind:
      a) Do not turn on the "Fully complex" toggle button.
      b) Do not turn on the "Zero frequency centered" toggle button.
      c) Turn off the "Convert units" toggle button.
      d) If you use non-integral shifts, the result may not match
         the expected result if one or more dimensions have an
         even number of samples (see FTransform3D's documentation
         on the shift parameter for a fuller description of the
         problem).  Also, the shifted result could have negative
         values when reverse transformed (i.e. the interpolation
         of the PSF using the Fourier series is not guaranteed
         to be non-negative everywhere).  In that case, you could
         do the transform with this procedure:
         A) Perform an initial forward transform as a fully-complex
            transform with the non-integral shifts.  Do not convert
            the unit spacing or center the zero frequency.
         B) Reverse transform that result as a fully-complex
            transform with with the shifts set to zero.  Do not
            convert the unit spacing or center the frequency.
         C) Extract the real component of that result and coerce
            any negative values to zero by running Threshold on
            the result.  In Threshold, set it to write the output
            as floating-point and use the condition,
            "generic expression", with the expression set to
            "real(p) >= 0", the background set to zero, and the
            result set to "masked data".
         D) Perform a final forward transform without the
            "Fully complex" toggle button on and use shifts of
            zero.  Do not convert the unit spacing or center the
            zero frequency.
   7) At this point you have a full 3D OTF that is usable by the
      deconvolution application.  To improve the signal-to-noise
      ratio in the OTF, it has been common practice to radially
      average the OTF; this has the drawback of throwing away real
      radial asymmetries that are present.  If you wish to radially
      average the OTF, the command line application radialft_asym
      radialft_asym can do this for you.
   8) Once you have computed an OTF, you may want to add it the
      database of available OTFs and pupil functions; the front
      end to the deconvolution application consults that database
      to choose the default OTF or pupil function for a data set
      based on the lens number in the data set's header.  The
      database is stored in the CTF.def file which is in the CTF
      subdirectory of the Priism distribution; the comments at the
      beginning of the file describe the format of CTF.def.  An
      individual user may override some or all of the database by
      creating a CTF.def in the .iveprefs subdirectory of his or
      her home directory.

   The steps for generating a pupil function are similar, but
   instead of the 3D Fourier transform step and the optional
   radial averaging, do the following:

   1) Use the phase retrieval application, phretavr, to estimate
      an image of the pupil function from your measured PSF.
   2) You may want to fit Zernike polynomials to the pupil function
      image and use that fit instead of the full image.  The
      application, pffit, can do the fitting for you.
   3) Once you have the pupil function image or the fit to that
      image, you can enter it into the CTF.def database just as
      you would with an OTF.

otf_format
   The format for OTF files read by the deconvolution application
   is the standard Priism image file format (consult the IM
   library documentation for details).  If the OTF is one where
   radial symmetry has been imposed, the file also has the
   following special attributes:

   1) The file has only one 2D section per wavelength; that
      section represents the radially averaged OTF for the
      wavelength.
   2) The x dimension (fastest varying) of the 2D section
      represents the z direction from the image space; the y
      dimension of the 2D section represents the radial
      direction (i.e. perpendicular to the z axis) from the
      image space.
   3) The x and y pixel spacing in the header should be set
      so the units are in cycles/micron.
   4) The value at coordinates (i,j) in the 2D section (where
      i is greater than or equal to zero and less than nx, the
      size of the x dimension, and j is greater than or equal
      to zero and less than ny, the size of the y dimension)
      is the OTF for the axial frequency kz and and radial
      frequency kr.  kz is i*dkz if i is less than or equal
      to nx/2; dkz is the x pixel spacing in cycles/micron
      from the header.  If i is greater than nx/2, kz is
      (i-nx)*dkz.  kr is j*dkr where dkr is the y pixel
      spacing in cycles/micron from the header.
   5) For each wavelength, the data values have been multiplied
      by a constant so that the value at (0,0) is 1.

   For a full 2D or 3D OTF (no assumption of radial symmetry),
   the file has the following special attributes:

   1) The x and y pixel spacing (dx and dy respectively) in
      the header should be set to the spatial domain values,
      in units of microns.  For a 3D OTF, the z pixel spacing
      (dz) must also be set to the z spacing, in units of microns,
      for the spatial domain.
   2) The value at coordinates (i, j, k) in a volume (where i
      is greater than or equal to zero and less than nx, the size
      of the x dimension; j is greater than or equal to zero and
      less than ny, the size of the y dimension; k is greater
      than or equal to zero and less than nz, the size of the z
      dimension) is the OTF at the spatial frequencies kx, ky,
      and kz.  kx is i / (2 * (nx - 1) * dx).  ky is j / (ny * dy)
      if j is less than or equal to ny / 2 and is (j - ny) /
      (ny * dy) otherwise.  kz is k / (nz * dz) if k is less
      than or equal to nz / 2 and is (k - nz) / (ny * dz)
      otherwise.
   3) Unless you use the option, -nonorm_otf, the value at
      (0,0,0) for a wavelength must be non-zero (without
      -nonorm_otf, the deconvolution application will
      scale all values in the transfer function by the
      inverse of the zero frequency value).

   For either radially-symmetric or non-radially symmetric OTF
   files, the emission wavelength, in nanometers, should be
   specified in the header so that the deconvolution application
   can modify the OTF as necessary if there is a wavelength
   mismatch with the data to be deconvolved.

   The format for pupil function images is the standard Priism
   file format.  The file also has the following special attributes:

   1) The image type value stored in the header is 8000.  The value
      v1 in the header holds the numerical aperture times ten and
      the value v2 in the header holds the immersion media
      refractive index times one hundred.
   2) The x and y pixel spacing dx and dy respectively) in the
      header should be expressed in units cycles / microns.
   3) If dx and dy are the x and y pixel spacing values in the
      header and ox and oy are the x and y origin values in the
      header, the pixel coordinate pair, (i, j), corresponds to
      a spatial frequency, in cycles / micron, of
      ((i + nearest_integer(ox / dx)) * dx,
      (j + nearest_integer(oy / dy)) * dy).
   4) If the image data values are complex-valued, the first
      image in each wavelength is assumed to be the image of
      the pupil function.  If the image data values are not
      complex-valued, the first image in each wavelength is
      assumed to hold the amplitude component of the pupil
      and the second image in each wavelength is assumed to
      hold the phase component.

   Like OTF files, pupil function images should include the
   emission wavelength value or values, in nanometers, in the
   header so that the deconvolution application can modify
   the pupil function as necessary if there is a wavelength
   mismatch with the data to be deconvolved.

   The files used to store the result of fitting Zernike
   polynomials to the pupil function image are plain text.
   The first line of the file must be

   #parametric_pupil_format 0

   After that there are zero or more components each of which
   is either a blank line or one of the following:

   #attribute_name [attribute values]
   [coefficient values]

   or

   # label_text

   Valid attributes are:

   numerical_aperture
      Has a single attribute value, the assumed numerical
      aperture, and no coefficient values.

   immersion_refractive_index
      Has a single attribute value, the refractive index for
      the immersion media, and no coefficient values.

   lens_id
      Has a single attribute value, the integer lens
      identification number, and no coefficient values.

   zernike_set_for_amplitude
      Has two integer attribute values and no coefficient
      values.  The two attribute values, n and m, specify
      the set of Zernike polynomials that were used to fit
      the amplitude component of the pupil function.  If n,
      the first attribute, is less than zero, no Zernike
      polynomials were used to fit amplitude component.
      Otherwise, the Zernike polynomials that were used to
      fit the amplitude component are those whose radial
      component is of order n-1 or those whose radial
      component is of order n and whose angular dependence
      is k times the angle where k is greater than or equal
      to zero and less than or equal to m.  If n is greater
      than or equal to zero, then m must be greater than
      equal to zero and less than or equal to n; also, n
      minus m must be even.

   zernike_set_for_phase
      Has two integer attribute values and no coefficient
      values.  The two attribute values, n and m, specify
      the set of Zernike polynomials that were used to fit
      the phase component of the pupil function.  If n,
      the first attribute, is less than zero no Zernike
      polynomials were used to fit phase component.
      Otherwise, the Zernike polynomials that were used
      to fit the phase component are those whose radial
      component is of order n-1 or those whose radial
      component is of order n and whose angular dependence
      is k times the angle where k is greater than or equal
      to zero and less than or equal to m.  If n is greater
      than or equal to zero, then m must be greater than
      equal to zero and less than or equal to n; also, n
      minus m must be even.

   polar_fourier_set_for_amplitude
      Has two integer attribute values and no coefficient
      values.  The two attribute values, n and m, specify
      the set of polar Fourier terms used to fit the residual
      of the amplitude component of the pupil function after
      the fit to the Zernike polynomials.  If n is less than
      zero or m is less than zero, then no polar Fourier terms
      were used.  Otherwise there are 4 * n * m + 2 * (n + m) + 1
      terms.

   polar_fourier_set_for_phase
      Has two integer attribute values and no coefficient
      values.  The two attribute values, n and m, specify
      the set of polar Fourier terms used to fit the residual
      of the phase component of the pupil function after the
      fit to the Zernike polynomials.  If n is less than zero
      or m is less than zero, then no polar Fourier terms
      were used.  Otherwise there are 4 * n * m + 2 * (n + m)
      + 1 terms.

   wavelength_count
      Has a single attribute value, the number of wavelengths
      for which there are fit coefficients, and no coefficient
      values.

   wavelengths_um
      To be effective, this attribute should appear after
      the wavelength_count attribute in the file.  The
      wavelengths_um attribute is expected to have n
      attribute values which are the wavelengths, in
      microns; n is the number of wavelengths from the
      wavelength_count attribute.  This attribute has
      no coefficient values.

   zernike_coeff_amplitude_i
      Specifies the coefficients for the Zernike polynomials
      used to fit the pupil function amplitude for the ith
      wavelength (where i is greater than or equal to zero
      and less than the number of wavelengths set by the
      wavelength_count attribute).  To be effective, this
      attribute should appear after the wavelength_count
      and zernike_set_for_amplitude attributes in the file.
      This attribute has no attribute values and the coefficient
      values follow, one per line, where each line has the form
      g h c [s].  g is an integer greater than or equal to
      zero and less than or equal to the number of radial orders
      set by the zernike_set_for_amplitude attribute.  h is
      an integer greater than or equal to zero and less than
      or equal to g (and, if g is equal to the number of radial
      orders set by the zernike_set_for_amplitude attribute,
      h must also be less than or equal to the second attribute
      value, m from that attribute).  The difference between g
      and h must be divisible by two.  c is the coefficient for
      the Zernike polynomial,  cos(h*theta) * sum over s from
      0 to (g-h)/2 of (-1)^s r^(g-2s) (g-s)! / (s! ((g+h)/2-s)!
      ((g-h)/2-s)!).  If h is not zero, then s is the
      coefficient for the Zernike polynomial, sin(h*theta) *
      sum over s from 0 to (g-h)/2 of (-1)^s r^(g-2s) (g-s)! /
      (s! ((g+h)/2-s)! ((g-h)/2-s)!).

   zernike_coeff_phase_i
      Specifies the coefficients for the Zernike polynomials used
      to fit the pupil function phase for the ith wavelength
      (where i is greater than or equal to zero and less than the
      number of wavelengths set by the wavelength_count attribute).
      To be effective, this attribute should appear after the
      wavelength_count and zernike_set_for_phase attributes in
      the file.  This attribute has no attribute values and the
      coefficient values follow, one per line, where each line
      has the form:  g h c [s].  g is an integer greater than
      or equal to zero and less than or equal to the number of
      radial orders set by the zernike_set_for_phase attribute.
      h is an integer greater than or equal to zero and less
      than or equal to g (and, if g is equal to the number of
      radial orders set by the zernike_set_for_phase attribute,
      h must also be less than or equal to the second attribute
      value, m from that attribute).  The difference between
      g and h must be divisible by two.  c is the coefficient
      for the Zernike polynomial, cos(h*theta) * sum over s
      from 0 to (g-h)/2 of (-1)^s r^(g-2s) (g-s)! /
      (s! ((g+h)/2-s)! ((g-h)/2-s)!).  If h is not zero, then
      s is the coefficient for the Zernike polynomial,
      sin(h*theta) * sum over s from 0 to (g-h)/2 of (-1)^s
      r^(g-2s) (g-s)! / (s! ((g+h)/2-s)! ((g-h)/2-s)!).

   polar_fourier_coeff_amplitude_i
      Specifies the coefficients for the polar Fourier terms
      used to fit the residual of the pupil function amplitude
      for the ith wavelength (where i is greater than or equal
      to zero and less than the number of wavelengths set by
      the wavelength_count attribute).  To be effective, this
      attribute should appear after the wavelength_count and
      polar_fourier_set_for_amplitude attributes in the file.
      This attribute has no attribute values and the
      coefficient values follow, one per line, where each
      line has the form:  g h p1 [p2 [p3 p4]].  g is an
      integer greater than or equal to zero and less than
      or equal to the first attribute value, n, set by the
      polarf_set_for_amplitude attribute.  h is an integer
      greater than or equal to zero and less than or equal
      to the second attribute value, m, set by the
      polarf_set_for_amplitude attribute.  p1 is the
      coefficient for the polar Fourier term, cos(2*pi*g*r) *
      cos(h*theta).  If g is not zero and h is zero, p2 is
      the coefficient for the polar Fourier term, sin(2*pi*g*r) *
      cos(h*theta).  If g is zero and h is not zero, p2
      is the coefficient for the polar Fourier term,
      cos(2*pi*g*r) * sin(h*theta).  If g and h are both not
      zero, then p2 is the coefficient for the polar Fourier
      term, cos(2*pi*g*r) * sin(h*theta), p3 is the
      coefficient for the polar Fourier term, sin(2*pi*g*r) *
      cos(h*theta), and p4 is the coefficient for the polar
      Fourier term, sin(2*pi*g*r) * sin(h*theta).

   polar_fourier_coeff_phase_i
      Specifies the coefficients for the polar Fourier terms
      used to fit the residual of the pupil function phase
      for the ith wavelength (where i is greater than or equal
      to zero and less than the number of wavelengths set by
      the wavelength_count attribute).  To be effective, this
      attribute should appear after the wavelength_count and
      polar_fourier_set_for_phase attributes in the file.  This
      attribute has no attribute values and the coefficient
      values follow, one per line, where each line has the form:
      g h p1 [p2 [p3 p4]].  g is an integer greater than or
      equal to zero and less than or equal to the first
      attribute value, n, set by the polarf_set_for_phase
      attribute.  h is an integer greater than or equal to
      zero and less than or equal to the second attribute
      value, m, set by the polarf_set_for_phase attribute.
      p1 is the coefficient for the polar Fourier term,
      cos(2*pi*g*r) * cos(h*theta).  If g is not zero and
      h is zero, p2 is the coefficient for the polar Fourier
      term, sin(2*pi*g*r) * cos(h*theta).  If g is zero and
      h is not zero, p2 is the coefficient for the polar
      Fourier term, cos(2*pi*g*r) * sin(h*theta).  If g
      and h are both not zero, then p2 is the coefficient
      for the polar Fourier term, cos(2*pi*g*r) * sin(h*theta),
      p3 is the coefficient for the polar Fourier term,
      sin(2*pi*g*r) * cos(h*theta), and p4 is the
      coefficient for the polar Fourier term, sin(2*pi*g*r) *
      sin(h*theta).

   As an example, here's what the file would look like for
   an ideal pupil (no variation in amplitude or phase out
   to the limit imposed by the numerical aperture) with
   numerical aperture of 1.3, immersion media refractive
   index of 1.5180, and a wavelength of 630 nanometers:

   #parametric_pupil_format 0
   #numerical_aperture 1.3
   #immersion_refractive_index 1.5180
   #lens_id 0
   #zernike_set_for_amplitude 0 0
   #zernike_set_for_phase -1 0
   #polar_fourier_set_for_amplitude -1 -1
   #polar_fourier_set_for_phase -1 -1
   #wavelength_count 1
   #wavelengths_um 0.63
   #zernike_coeff_amplitude_0
   0 0 1
